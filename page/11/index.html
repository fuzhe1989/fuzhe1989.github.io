<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://fuzhe1989.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="High-Flyer AIPingCAPGoogleAlibaba CloudHarbin Institute of Technology">
<meta property="og:type" content="website">
<meta property="og:title" content="Fu Zhe&#39;s Blog">
<meta property="og:url" content="http://fuzhe1989.github.io/page/11/index.html">
<meta property="og:site_name" content="Fu Zhe&#39;s Blog">
<meta property="og:description" content="High-Flyer AIPingCAPGoogleAlibaba CloudHarbin Institute of Technology">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fu Zhe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://fuzhe1989.github.io/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Fu Zhe's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4HC396822H"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-4HC396822H');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?df45b34764dad306c840c8f1da5faf14";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Fu Zhe's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fu Zhe's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/04/21/crtp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/21/crtp/" class="post-title-link" itemprop="url">Curiously Recurring Template Pattern(CRTP)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-21 00:53:59" itemprop="dateCreated datePublished" datetime="2018-04-21T00:53:59+08:00">2018-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CRTP"><a href="#CRTP" class="headerlink" title="CRTP"></a>CRTP</h2><p>C++中有一种很特别的模式，称为Curiously Recurring Template Pattern，缩写是CRTP。从它的名字看，前三个词都是关键字。Curiously，意思是奇特的。Recurring，说明它是递归的。Template，说明它与模板有关。</p>
<p>最常见的CRTP形式就很符合这三个关键字：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;Derived&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>猛一看这段代码，确实挺奇特的：派生类继承自一个用派生类特化的基类，相当于自己特化了自己。</p>
<p>这里面应用到了C++模板的一个特性：与模板参数有关的代码的编译会推迟到模板实例化时进行。</p>
<h2 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a>静态多态</h2><p>CRTP的第一个用途就是实现静态多态。</p>
<p>传统的C++中我们想要实现多态首先要有继承和虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Foo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Foo</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>并通过基类的指针或引用来触发多态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(Base&amp; b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; b.<span class="built_in">Foo</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这套方案有两个问题：</p>
<ol>
<li>虚函数会影响类型的内存布局，空间上增加一个虚表指针。</li>
<li>虚函数调用需要增加一次跳转，增加了运行时开销。</li>
</ol>
<p>而用CRTP，我们可以实现编译时的静态多态。在这个方案中，基类负责定义接口，而派生类则负责实现接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">Foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;Derived&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个方案中，基类的<code>Foo()</code>会去调用派生类的<code>Foo()</code>，相当于前者是接口，而后者是实现。</p>
<p>注意在<code>Base::Foo</code>中，我们为了调用<code>Derived::Foo</code>，需要通过<code>static_cast</code>来显式转换<code>this</code>的类型。为什么这里用<code>static_cast</code>而不是<code>dynamic_cast</code>呢？因为<code>Base</code>自己是不知道<code>T</code>是它的派生类的，因此这里也不应该用<code>dynamic_cast</code>，而因为这里我们没有虚函数，用<code>static_cast</code>也是安全的。</p>
<p>CRTP方案的优点：</p>
<ol>
<li>没有虚函数，不会改变派生类的内存布局，空间上开销更小。</li>
<li><code>b.Foo()</code>不是虚函数调用，不会增加一次跳转，运行时开销更小。</li>
<li><code>Base::Foo()</code>甚至可以内联掉，进一步降低了运行时开销。</li>
<li>模板对接口的要求是“Duck Typing”，比虚函数的要求更低。这个例子中，只要派生类满足有一个public的，名字为<code>Foo</code>，接受0个参数，返回类型可隐式转换为<code>int</code>的函数，就满足了<code>Base</code>的接口要求。</li>
</ol>
<p>当然静态多态就导致了<code>Base</code>的不同的派生类实际继承自不同的基类，因此没有办法把它们的指针或引用放到某个容器中。另外，这样每个派生类都会实例化一个基类类型，会导致目标代码多于普通的继承。</p>
<h2 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h2><p>CRTP的第二个用途就是为其它类型增加功能，此时CRTP的基类就是一种mixin类型。</p>
<p>当CRTP用于mixin时，它的写法与静态多态很类似，只不过此时我们要的不是多态，而是新的功能，因此基类与派生类的方法名要不同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Repeatable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Repeat</span><span class="params">(<span class="type">int</span> n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">const</span> T*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">Foo</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroPrinter</span> : <span class="keyword">public</span> Repeatable&lt;ZeroPrinter&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们用CRTP为<code>ZeroPrinter</code>增加了一个<code>Repeat</code>功能，此时<code>Repeatable</code>就是一种mixin。而在这个方案中，我们不需要让<code>ZeroPrinter</code>去实现某个接口，去把自己已有的函数改成虚函数。</p>
<p>而且我们还可以为已经存在的类型增加功能。假如<code>ZeroPrinter</code>是第三方库提供的类型，我们没办法让它继承自<code>Repeatable</code>，那么我们可以增加一种新类型，同时继承<code>ZeroPrinter</code>和<code>Repeatable</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RepeatableZeroPrinter</span>: <span class="keyword">public</span> ZeroPrinter, <span class="keyword">public</span> Repeatable&lt;RepeatableZeroPrinter&gt; &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，当我们用CRTP来实现mixin时，要注意派生类与基类的函数名不能相同，因为派生类会屏蔽掉基类的名字，而导致我们想增加的功能无法被使用。</p>
<p>另一个mixin的例子是<code>Counter</code>，我们可以利用<code>Base&lt;T&gt;</code>和<code>Base&lt;R&gt;</code>不是一个类型的特性，为不同的类型增加实例个数的Counter统计的功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> mObjectsCreated;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> mObjectsAlive;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Counter</span>() &#123;</span><br><span class="line">        ++mObjectsCreated;</span><br><span class="line">        ++mObjectsAlive;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">const</span> Counter&amp;) &#123;</span><br><span class="line">        ++mObjectsCreated;</span><br><span class="line">        ++mObjectsAlive;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// objects should never be removed through pointers of this type</span></span><br><span class="line">    ~<span class="built_in">Counter</span>() &#123;</span><br><span class="line">        --mObjectsAlive;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="type">int</span> Counter&lt;T&gt;::<span class="built_in">mObjectsCreated</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="type">int</span> Counter&lt;T&gt;::<span class="built_in">mObjectsAlive</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> : Counter&lt;X&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span> : Counter&lt;Y&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>X</code>和<code>Y</code>各自通过<code>Counter&lt;X&gt;</code>和<code>Counter&lt;Y&gt;</code>来实现统计功能。</p>
<h2 id="链式多态"><a href="#链式多态" class="headerlink" title="链式多态"></a>链式多态</h2><p>假设有基类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Printer</span><span class="params">(ostream&amp; pstream)</span> : mStream(pstream) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">Printer&amp; <span class="title">Print</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">        mStream &lt;&lt; t;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">Printer&amp; <span class="title">Println</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">        mStream &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ostream&amp; mStream;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以链式调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Printer&#123;myStream&#125;.<span class="built_in">Println</span>(<span class="string">&quot;hello&quot;</span>).<span class="built_in">Println</span>(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>但派生类就不行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoutPrinter</span> : <span class="keyword">public</span> Printer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CoutPrinter</span>() : <span class="built_in">Printer</span>(cout) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">CoutPrinter&amp; <span class="title">SetConsoleColor</span><span class="params">(Color c)</span> </span>&#123; ... <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                             v-- we have a &#x27;Printer&#x27; here, not a &#x27;CoutPrinter&#x27;</span><br><span class="line">CoutPrinter().Print(&quot;Hello &quot;).SetConsoleColor(Color.red).Println(&quot;Printer!&quot;); // compile error</span><br></pre></td></tr></table></figure>

<p>因为<code>print</code>只会返回<code>Printer&amp;</code>。</p>
<p>用CRTP就可以解决这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConcretePrinter&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Printer</span><span class="params">(ostream&amp; pstream)</span> : mStream(pstream) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">ConcretePrinter&amp; <span class="title">Print</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mStream &lt;&lt; t;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ConcretePrinter&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">ConcretePrinter&amp; <span class="title">Println</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mStream &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ConcretePrinter&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ostream&amp; mStream;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Derived class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoutPrinter</span> : <span class="keyword">public</span> Printer&lt;CoutPrinter&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CoutPrinter</span>() : <span class="built_in">Printer</span>(cout) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">CoutPrinter&amp; <span class="title">SetConsoleColor</span><span class="params">(Color c)</span> </span>&#123; ... <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line"><span class="built_in">CoutPrinter</span>().<span class="built_in">Print</span>(<span class="string">&quot;Hello &quot;</span>).<span class="built_in">SetConsoleColor</span>(Color.red).<span class="built_in">Println</span>(<span class="string">&quot;Printer!&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="利用CRTP提供默认Clone"><a href="#利用CRTP提供默认Clone" class="headerlink" title="利用CRTP提供默认Clone"></a>利用CRTP提供默认Clone</h2><p>当要通过基类指针获得对象的拷贝时，通常做法是加个虚的<code>Clone</code>函数，而用CRTP可以避免在每个派生类中重复这个函数，只要派生类允许复制构造即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base class has a pure virtual function for cloning</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Shape* <span class="title">Clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This CRTP class implements clone() for Derived</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape_CRTP</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shape* <span class="title">Clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Derived</span>(<span class="built_in">static_cast</span>&lt;Derived <span class="type">const</span>&amp;&gt;(*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape_CRTP&lt;Square&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape_CRTP&lt;Circle&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="摆脱static-cast"><a href="#摆脱static-cast" class="headerlink" title="摆脱static_cast"></a>摆脱<code>static_cast</code></h2><p>上面每个CRTP例子中都有<code>static_cast</code>，我们可以通过一个辅助类来避免每次都直接调用<code>static_cast</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CRTP</span> &#123;</span><br><span class="line">    <span class="function">T&amp; <span class="title">Underlying</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">Underlying</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T <span class="type">const</span>&amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样前面的例子就可以写成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">emplate &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> : <span class="keyword">private</span> CRTP&lt;T&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">Underlying</span>().<span class="built_in">Foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意1：这里要private继承，是因为我们不想把<code>Underlying</code>函数暴露出去。</p>
<p>注意2：这里为什么要用<code>this-&gt;Underlying()</code>而不是直接使用<code>Underlying()</code>？参见<a href="/2017/09/05/how-to-call-method-of-base-class-in-template/">模板类中如何调用其模板基类中的函数</a>。</p>
<h2 id="避免继承错误的基类"><a href="#避免继承错误的基类" class="headerlink" title="避免继承错误的基类"></a>避免继承错误的基类</h2><p>当我们写多个CRTP类型时，可能会因为copy&#x2F;paste而不小心继承错基类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base&lt;Derived1&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base&lt;Derived1&gt; &#123; <span class="comment">// bug in this line of code</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解法很简单，将<code>Base</code>的构造函数声明为private，并将<code>T</code>设置为友元，这样<code>Derived2</code>根本就没办法调用<code>Base&lt;Derived1&gt;</code>的构造函数，从而制造编译错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="避免菱形继承"><a href="#避免菱形继承" class="headerlink" title="避免菱形继承"></a>避免菱形继承</h2><p>想象我们有两个mixin类型，都使用了CRTP来实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Scalable</span> : <span class="keyword">private</span> CRTP&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Scale</span><span class="params">(<span class="type">double</span> multiplicator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Underlying</span>().<span class="built_in">SetValue</span>(<span class="keyword">this</span>-&gt;<span class="built_in">Underlying</span>().<span class="built_in">GetValue</span>() * multiplicator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Squarable</span> : <span class="keyword">private</span> CRTP&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Square</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> v = <span class="keyword">this</span>-&gt;<span class="built_in">Underlying</span>().<span class="built_in">GetValue</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Underlying</span>().<span class="built_in">SetValue</span>(v * v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在我们把这两个功能加到一个类型上：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sensitivity</span> : <span class="keyword">public</span> Scalable&lt;Sensitivity&gt;, <span class="keyword">public</span> Squarable&lt;Sensitivity&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> mValue; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetValue</span><span class="params">(<span class="type">double</span> value)</span> </span>&#123; mValue = value; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> mValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BOOM！编译错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: &#x27;CRTP&lt;Sensitivity&gt;&#x27; is an ambiguous base of &#x27;Sensitivity&#x27;</span><br></pre></td></tr></table></figure>

<p>问题出在我们不小心搞出来菱形继承了！</p>
<ul>
<li><code>Sensitivity</code> -&gt; <code>Scalable&lt;Sensitivity&gt;</code> -&gt; <code>CRTP&lt;Sensitivity&gt;</code></li>
<li><code>Sensitivity</code> -&gt; <code>Squarable&lt;Sensitivity&gt;</code> -&gt; <code>CRTP&lt;Sensitivity&gt;</code></li>
</ul>
<p>一种解法是将mixin的类型也加到<code>CRTP</code>的模板参数中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">CrtpType</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CRTP</span> &#123;</span><br><span class="line">    <span class="function">T&amp; <span class="title">Underlying</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">Underlying</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T <span class="type">const</span>&amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CRTP</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> CrtpType&lt;T&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意这里的<code>CrtpType</code>不是普通的模板参数类型，它前面的<code>template</code>说明它本身也是一个模板类型。我们没有直接用到<code>CrtpType</code>，只是用它保证同样的<code>T</code>加上不同的mixin会产生不同的<code>CRTP</code>类型。</p>
<p>新的<code>Sensitivity</code>的继承关系：</p>
<ul>
<li><code>Sensitivity</code> -&gt; <code>Scalable&lt;Sensitivity&gt;</code> -&gt; <code>CRTP&lt;Sensitivity, Scalable&gt;</code></li>
<li><code>Sensitivity</code> -&gt; <code>Squarable&lt;Sensitivity&gt;</code> -&gt; <code>CRTP&lt;Sensitivity, Squarable&gt;</code></li>
</ul>
<p>这样我们只要保证一个类型不要多次集成了同一个mixin，就没问题了。</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">Curiously recurring template pattern</a></li>
<li><a target="_blank" rel="noopener" href="https://www.fluentcpp.com/2017/05/12/curiously-recurring-template-pattern/">The Curiously Recurring Template Pattern (CRTP)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.fluentcpp.com/2017/05/16/what-the-crtp-brings-to-code/">What the Curiously Recurring Template Pattern can bring to your code</a></li>
<li><a target="_blank" rel="noopener" href="https://www.fluentcpp.com/2017/05/19/crtp-helper/">An Implementation Helper For The Curiously Recurring Template Pattern</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/25/cpp-object-model-copy-move/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/25/cpp-object-model-copy-move/" class="post-title-link" itemprop="url">C++对象模型（六）复制与移动</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-25 00:02:52" itemprop="dateCreated datePublished" datetime="2018-03-25T00:02:52+08:00">2018-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>C++里类有4种特殊的成员函数：</p>
<ul>
<li>构造函数。</li>
<li>析构函数。</li>
<li>复制函数，包括复制构造函数和复制赋值函数。</li>
<li>移动函数，包括移动构造函数和移动赋值函数。</li>
</ul>
<p>这些函数的特点是：有些时候，编译器会帮你生成这些函数；有些时候，编译器又会拒绝生成这些函数；还有些时候，编译器还会往你自己写的特殊函数中添加操作。鉴于这些特殊函数的重要性，我们有必要好好了解一下它们背后的故事。</p>
<p>本文介绍的是后两类，复制函数和移动函数。</p>
<p>注1：本文环境为Ubuntu 16.04，gcc5.4.0，使用c++14标准。<br>注2：本文大量内容来自<a target="_blank" rel="noopener" href="https://book.douban.com/subject/10427315/">《深入探索C++对象模型》</a>。</p>
<h1 id="复制函数"><a href="#复制函数" class="headerlink" title="复制函数"></a>复制函数</h1><h2 id="复制函数的签名"><a href="#复制函数的签名" class="headerlink" title="复制函数的签名"></a>复制函数的签名</h2><p>通常我们说到复制函数，是指：</p>
<ul>
<li>复制构造函数：<code>S(const S&amp; ano)</code>。</li>
<li>复制赋值函数：<code>S&amp; operator=(const S&amp;)</code>。</li>
</ul>
<p>其中后者返回<code>S&amp;</code>是为了能模仿C的连续赋值：<code>a = b = c</code>。</p>
<p>复制构造函数还可以是<code>S(S&amp; ano)</code>，但这样会给人一种可能修改源对象的错觉。</p>
<p>复制赋值函数可以有很多签名，比如返回值改为<code>const S&amp;</code>或者干脆是<code>void</code>，但这样的赋值函数可能不会有太多用处。如果把它的参数类型改为<code>S</code>或<code>const S</code>，这也是复制赋值函数。如果参数类型为其它类型，则不再满足复制赋值函数的要求。</p>
<h2 id="什么时候发生复制"><a href="#什么时候发生复制" class="headerlink" title="什么时候发生复制"></a>什么时候发生复制</h2><p>如下三个场景都会调用到复制构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 0</span></span><br><span class="line"><span class="function">S <span class="title">s1</span><span class="params">(s0)</span></span>;</span><br><span class="line"><span class="comment">// case 1</span></span><br><span class="line">S s2 = s0;</span><br><span class="line"><span class="comment">// case 2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(S s3)</span></span>;</span><br><span class="line"><span class="built_in">Func</span>(s0);</span><br></pre></td></tr></table></figure>

<p>实际上，这也是构造函数会被调用的三个场景，只是它的参数恰好与类相同。</p>
<p>而当我们对一个已定义的对象进行赋值时，如果<code>=</code>右边的表达式类型与类相同（去掉cv与左值引用后），那么就会调用复制赋值函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = s0;</span><br><span class="line">s2 = <span class="built_in">GetTempS</span>();</span><br></pre></td></tr></table></figure>

<h2 id="编译器生复制函数的条件"><a href="#编译器生复制函数的条件" class="headerlink" title="编译器生复制函数的条件"></a>编译器生复制函数的条件</h2><p>当一个类满足以下条件时，编译器就会为其生成复制构造函数或复制赋值函数：</p>
<ul>
<li>没有自定义的复制函数或声明复制函数为<code>= default</code>，且</li>
<li>没有用<code>= delete</code>删除复制函数，且</li>
<li>所有非静态成员变量都可复制，且</li>
<li>代码中调用了复制函数。</li>
</ul>
<p>其中，如果类定义了一个复制函数而没有定义另一个，且满足上述条件，那么编译器也会为其生成另一个复制函数。</p>
<p>根据上面的要求，如果一个类有const成员或引用类型的成员，那么这个类显然没办法复制了。</p>
<p>然而我们又要重复说bitwise与memberwise了。</p>
<p>如果编译器在为一个类生成复制函数时，发现这个类满足bitwise标准，只需要trivial的复制函数，那么就不会真的生成这个函数。前文中我们说，对于满足bitwise构造的类型来说，不建议放任编译器生成trivial的默认构造函数，原因是trivial的默认构造函数会导致成员变量没有确定的初值。但与默认构造函数不同，bitwise的复制函数的确定性取决于它的参数值，因此一个类型如果复制函数是trivial的，但通过自定义默认构造函数的方式保证了不会有trivial的默认构造函数，那么trivial的复制函数就是安全的。</p>
<p>而如果类不满足bitwise条件，编译器就会为其生成memberwise的复制函数，即按声明顺序，依次调用每个非静态成员变量的相应复制函数。</p>
<h2 id="复制与析构的“三法则”"><a href="#复制与析构的“三法则”" class="headerlink" title="复制与析构的“三法则”"></a>复制与析构的“三法则”</h2><p>以下内容来自<a href="/2017/07/09/effective-modern-cpp-chapter3-iterm15-17/">Effective Modern C++ Item17</a>。</p>
<blockquote>
<p>C++98中有所谓的“三法则”：如果你声明了复制构造函数、复制赋值函数或析构函数中的一个，你也应该定义另外两个。该原则的原因是如果你声明了其中任意一个函数，就表明你要自己管理资源，而这三个函数都会参与到资源管理中，因此如果声明就要全声明掉。STL中的每个容器类都声明了这三个函数。</p>
<p>三法则的一个推论就是，自定义了析构函数往往意味着逐一的复制语义并不适用于这个类，因此自定义析构函数也应该阻止编译器生成复制函数。但在C++98标准产生过程中，三法则还没有被广泛认可，因此C++98中自定义析构函数并不会影响编译器生成复制函数。</p>
</blockquote>
<h2 id="设置虚表指针"><a href="#设置虚表指针" class="headerlink" title="设置虚表指针"></a>设置虚表指针</h2><p>当发生派生类到基类对象的复制时，很重要的事情就是保证基类对象的虚表指针指向正确的虚表。对于<code>Base b = Derived()</code>这种情况，我们知道其中发生Slicing，即只有<code>Derived</code>对象中的基类子对象复制给了<code>b</code>。但其中编译器还会正确地设置虚表指针，保证这样构造出来的<code>b</code>的虚表指针指向的是<code>Base</code>的虚表，而不是<code>Derived</code>的虚表。</p>
<p>如果我们自定义了复制函数，编译器会插入相应的代码，保证复制过程中虚表指针被正确设置了。</p>
<h2 id="正确复制基类子对象"><a href="#正确复制基类子对象" class="headerlink" title="正确复制基类子对象"></a>正确复制基类子对象</h2><p>我们在实现派生类的复制函数时，通常会比较注意是不是有成员忘了处理。但除了派生类本身的成员变量外，有时候我们可能会忘了复制基类子对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="built_in">Base</span>(): <span class="built_in">x</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp; b): <span class="built_in">x</span>(b.x) &#123;&#125;</span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp; b) &#123;</span><br><span class="line">        x = b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="built_in">Derived</span>(): <span class="built_in">y</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">const</span> Derived&amp; d): <span class="built_in">y</span>(d.y) &#123;&#125;</span><br><span class="line">    Derived&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Derived&amp; d) &#123;</span><br><span class="line">        y = d.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d0;</span><br><span class="line">    d0.x = <span class="number">2</span>;</span><br><span class="line">    d0.y = <span class="number">2</span>;</span><br><span class="line">    Derived d1 = d0;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, d1.x, d1.y);</span><br><span class="line">    d1.x = <span class="number">3</span>;</span><br><span class="line">    d1 = d0;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, d1.x, d1.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 2</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure>

<p>这个例子中<code>Derived</code>的两个复制函数都错了。</p>
<p>复制构造函数中，没有显式调用基类的复制构造函数，导致基类子对象被默认构造，丢失了<code>d0.x</code>。而复制赋值函数中，忘记调用了基类的复制赋值函数，同样导致<code>d1.x</code>没有被修改。</p>
<p>此时似乎编译器应该介入，但回想一下C++的设计理念，充分信任程序员，如果作者真的就预期这种行为呢？所以编译器不会帮我们把基类复制好。</p>
<p>因此一定要记住，在派生类的复制构造函数中，成员初始化列表的第一项就要是基类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived::<span class="built_in">Derived</span>(<span class="type">const</span> Derived&amp; d): <span class="built_in">Base</span>(d), <span class="built_in">y</span>(d.y) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>而在复制赋值函数中，没有初始化列表，我们就在第一行显式调用基类的复制赋值函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Derived&amp; Derived::<span class="keyword">operator</span>=(<span class="type">const</span> Derived&amp; d) &#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>=(d);</span><br><span class="line">    y = d.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说实话这么写代码有点丑，但我们还是要认清现实，毕竟保证正确性更重要。</p>
<h2 id="判断是否为自身"><a href="#判断是否为自身" class="headerlink" title="判断是否为自身"></a>判断是否为自身</h2><p>本节与下节来自<a target="_blank" rel="noopener" href="https://book.douban.com/subject/5387403/">《Effective C++》</a>的Item11（“Handle assignment to self in operator&#x3D;”）与Item25（“Consider support for a non-throwing swap”）。</p>
<p>当复制赋值函数被调用时，如果不判断源与目标是否为相同对象，可能会导致资源泄漏甚至进程崩溃。比如有这么个类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这里<code>rhs</code>与<code>*this</code>是相同对象：</p>
<ul>
<li>pb被删除，析构了，之后pb变成了空悬指针。</li>
<li>解引用pb导致未定义行为。</li>
</ul>
<p>因此传统做法是在赋值函数中先判断一下是否为自身：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">delete</span> pb;</span><br><span class="line">        pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这个函数还是有问题：它不是异常安全的，如果<code>new Bitmap</code>抛了异常，被赋值的对象的pb已经析构，没办法恢复了。怎么解决呢？看下节。</p>
<h2 id="使用swap实现异常安全的复制"><a href="#使用swap实现异常安全的复制" class="headerlink" title="使用swap实现异常安全的复制"></a>使用swap实现异常安全的复制</h2><p>对于上节提到的<code>Widget</code>赋值的异常安全问题，传统做法是先复制，再赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">        Bitmap* pOrig = pb;</span><br><span class="line">        pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">        delet pOrig;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而更优雅的方式为<code>Widget</code>增加一个<code>swap</code>函数，并直接利用复制构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">        Widget <span class="built_in">tmp</span>(rhs);</span><br><span class="line">        <span class="built_in">swap</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式将复制相关的逻辑都集中在了一个地方，复制构造函数中，更不容易弄错，代码也更整洁。</p>
<p>接下来是一个小要求：保证<code>swap</code>不抛异常。各个类型的<code>swap</code>很多时候都是用来实现强的异常安全的，因此会有<code>swap</code>不抛异常的假设。如果打破了这个假设，当我们用一些第三方库时，可能会遇到麻烦。一般来说，如果我们用指针或智能指针或STL容器来管理资源，还是很容易保证<code>swap</code>不抛异常的。</p>
<p>如果我们能假设<code>Widget</code>不会自身赋值，那么还有一种写法，可以更简洁地实现赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们利用了函数参数，省掉了一个临时变量，且因为<code>rhs</code>现在是一个local变量，不可能与<code>*this</code>相同，我们也不需要判断是否是自身，函数实现只剩下了两行代码。</p>
<h2 id="禁止复制"><a href="#禁止复制" class="headerlink" title="禁止复制"></a>禁止复制</h2><p>有些类型并不适合被复制，比如一些用于RAII的类型。为了安全，我们需要禁止这些类型的复制。</p>
<p>C++98中常用的做法是声明private的复制函数但不实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Lock</span>(<span class="type">const</span> Lock&amp;);</span><br><span class="line">    Lock&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Lock&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样类的外部（非友元）因访问权限问题而无法调用到复制函数，类的内部和友元则因复制函数没有定义，在链接时会报错。</p>
<p>在C++11中我们可以声明这些函数为deleted，从而更优雅更明显地禁止复制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Lock</span>(<span class="type">const</span> Lock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Lock&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Lock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多内容参见<a href="/2017/07/05/effective-modern-cpp-chapter3-iterm11-14/">Effective Modern C++ Item11</a>。</p>
<h2 id="赋值函数可以是虚函数吗"><a href="#赋值函数可以是虚函数吗" class="headerlink" title="赋值函数可以是虚函数吗"></a>赋值函数可以是虚函数吗</h2><p>我们知道构造函数不可以是虚函数，那么赋值函数可以是虚函数吗？比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp; b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="keyword">virtual</span> Derived&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Derived&amp; d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样下面的调用就有多态的效果了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p0 = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    Base* p1 = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    *p0 = *p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而很遗憾，错了，没有多态。编译器在判断派生类有没有改写基类的虚函数时，会判断返回值类型是否兼容，但不会判断参数类型是否兼容，因此实际上<code>Derived</code>中有两个赋值函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="keyword">virtual</span> Derived&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp;);</span><br><span class="line">    <span class="keyword">virtual</span> Derived&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Derived&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中第一个赋值函数继承了基类的实现。因此<code>*p0 = *p1</code>实际调用的还是基类的赋值函数，只复制了基类子对象部分。</p>
<p>怎么改正确？为了正确赋值派生类自己的成员，我们需要用到RTTI：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Derived&amp; Derived::<span class="keyword">operator</span>=(<span class="type">const</span> Base&amp; b) &#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>=(b);</span><br><span class="line">    <span class="type">const</span> Derived* p = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derived*&gt;(&amp;b);</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="comment">// 赋值派生类的成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后我们该怎么处理<code>Derived</code>“正常”的那个赋值函数呢？就是参数为<code>const Derived&amp;</code>那个。</p>
<p>我们可以同样实现它，但这样<code>Derived</code>中就需要实现两个赋值函数，而派生自<code>Derived</code>的类型则需要实现三个，等等，太恐怖了。另一种做法是干脆不要这个“正常”的赋值函数，这样所有赋值都会走基类定义的那个虚函数。这样我们只需要实现一个赋值函数，但缺点是所有赋值都要用到RTTI，开销比较大。</p>
<p>这两种方法都不太好，看起来它们指向一个结论：赋值函数不应该是虚函数。通常我们认为重载的操作符函数都不适合作为虚函数。</p>
<p>那么如果我们真的要实现一种多态的复制操作，该怎么做？一种常见做法是基类定义一个虚的<code>Clone</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Base* <span class="title">Clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样各个子类只要实现自己的<code>Clone</code>函数，就可以完成多态的复制了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/669818/virtual-assignment-operator-c">virtual assignment operator C++</a></li>
<li><a target="_blank" rel="noopener" href="http://icu-project.org/docs/papers/cpp_report/the_assignment_operator_revisited.html">The Assignment Operator Revisited</a></li>
<li><a target="_blank" rel="noopener" href="http://icu-project.org/docs/papers/cpp_report/the_anatomy_of_the_assignment_operator.html">The Anatomy of the Assignment Operator</a></li>
</ul>
<h1 id="移动函数"><a href="#移动函数" class="headerlink" title="移动函数"></a>移动函数</h1><p>移动函数可以参考以下文章：</p>
<ul>
<li><a href="/2017/07/09/effective-modern-cpp-chapter3-iterm15-17/">Effective Modern C++ Item17: 理解特殊成员函数的产生机制</a></li>
<li><a href="/2017/08/08/effective-modern-cpp-chapter5-iterm23-26/">Effective Modern C++ Chapter5 右值引用、移动语义、完美转发（Item 23-26)</a></li>
<li><a href="/2017/08/22/effective-modern-cpp-chapter5-iterm27-30/">Effective Modern C++ Chapter5 右值引用、移动语义、完美转发（Item 27-30)</a></li>
<li><a href="/2017/08/24/cpp-function-type-perfect-forward-universal-reference-collapse/">关于函数的类型、完美转发、普适引用与引用折叠的一些尝试和解释</a></li>
</ul>
<p>本文就不再重复了。</p>
<h1 id="返回值优化（RVO）"><a href="#返回值优化（RVO）" class="headerlink" title="返回值优化（RVO）"></a>返回值优化（RVO）</h1><p>所谓RVO就是Return Value Optimization，是一种编译器优化，即当编译器返回一个local变量时，如果接收返回值的是一个相同类型的新对象（即构造，而不是赋值），编译器可能会省掉这次构造，就在这个返回值的内存位置构造这个local变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">GetNameList</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        l.<span class="built_in">push_back</span>(<span class="built_in">GetRandomName</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; nameList = <span class="built_in">GetNameList</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>如果没有RVO，这个例子中会有两次<code>vector&lt;string&gt;</code>的构造，一次是默认构造，一次是复制构造。但在有RVO时，<code>GetNameList</code>中的<code>l</code>实际就是<code>nameList</code>，编译器直接用了返回值的地址来构造<code>l</code>，这样最后就不需要真正“返回”一个值了，省掉了100个<code>string</code>的复制。</p>
<p>这里能体现RVO的几个要求：</p>
<ul>
<li>返回local变量的值，而不是指针、引用、或是local变量的成员。</li>
<li>接收变量要是新对象，不能是已有的对象，即这个表达式是用来构造它的，而不是给它赋值的。</li>
<li>接收变量的类型要与local变量的类型<strong>完全</strong>相同。</li>
</ul>
<p>C++98中RVO属于编译器自己的一种优化，我们不能预期编译器真的会执行优化。因此上面的写法通常不被推荐，我们更习惯这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNameList</span><span class="params">(<span class="type">int</span> n, vector&lt;string&gt;* nameList)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这能保证省掉一次复制构造。但在C++11中，标准规定了满足上述要求后，编译器<strong>必须</strong>使用RVO，RVO成了可预期的行为，那么我们就可以放心使用前面的写法了，毕竟它更干净。</p>
<p>有些人会为了省掉一次复制构造，而选择返回local变量的右值引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">GetNameList</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; l;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用下面链接中黄尼玛的回答：</p>
<blockquote>
<p>此时返回的并不是一个局部对象，而是局部对象的右值引用。编译器此时无法进行rvo优化，能做的只有根据std::move(w)来移动构造一个临时对象，然后再将该临时对象赋值到最后的目标。所以，不要试图去返回一个局部对象的右值引用。</p>
</blockquote>
<p>引用<a href="/2017/08/08/effective-modern-cpp-chapter5-iterm23-26/">Effective Modern C++ Item25</a>：</p>
<blockquote>
<p>如果函数的返回类型就是值类型，那么编译器可以直接将这个local对象构造在接收函数返回值的对象上，省掉中间的复制过程。换句话说，在RVO的帮助下，直接返回这个local对象要比返回它的右值还要节省。</p>
<p>既然直接返回local对象不会比手动调用<code>std::move</code>差，还有很大概率更好一些，我们还有什么理由去手动move呢？</p>
</blockquote>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27000013">什么时候应当依靠返回值优化</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/23/cpp-object-model-ctor-dtor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/23/cpp-object-model-ctor-dtor/" class="post-title-link" itemprop="url">C++对象模型（五）构造与析构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-23 00:23:16" itemprop="dateCreated datePublished" datetime="2018-03-23T00:23:16+08:00">2018-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>C++里类有4种特殊的成员函数：</p>
<ul>
<li>构造函数。</li>
<li>析构函数。</li>
<li>复制函数，包括复制构造函数和复制赋值函数。</li>
<li>移动函数，包括移动构造函数和移动赋值函数。</li>
</ul>
<p>这些函数的特点是：有些时候，编译器会帮你生成这些函数；有些时候，编译器又会拒绝生成这些函数；还有些时候，编译器还会往你自己写的特殊函数中添加操作。鉴于这些特殊函数的重要性，我们有必要好好了解一下它们背后的故事。</p>
<p>本文介绍的是前两类，构造函数和析构函数。</p>
<p>注1：本文环境为Ubuntu 16.04，gcc5.4.0，使用c++14标准。<br>注2：本文大量内容来自<a target="_blank" rel="noopener" href="https://book.douban.com/subject/10427315/">《深入探索C++对象模型》</a>。</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="什么类没有构造函数"><a href="#什么类没有构造函数" class="headerlink" title="什么类没有构造函数"></a>什么类没有构造函数</h2><p>我们知道构造函数是一种非常重要的函数，也是C++诞生的一个主要原因。那么，第一个问题，每个类都有构造函数吗？</p>
<p>对于下面这个平凡类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Trivial</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> x;</span><br><span class="line">    <span class="type">int64_t</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Trivial t;</span><br><span class="line">    t.x = <span class="number">1</span>;</span><br><span class="line">    t.y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main</code>函数对应的汇编指令为（未开任何优化）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000000004006b6 &lt;main&gt;:</span><br><span class="line">  4006b6:   55                      push   %rbp</span><br><span class="line">  4006b7:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  4006ba:   48 c7 45 f0 01 00 00    movq   $0x1,-0x10(%rbp)</span><br><span class="line">  4006c1:   00</span><br><span class="line">  4006c2:   48 c7 45 f8 02 00 00    movq   $0x2,-0x8(%rbp)</span><br><span class="line">  4006c9:   00</span><br><span class="line">  4006ca:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  4006cf:   5d                      pop    %rbp</span><br><span class="line">  4006d0:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>没有<code>Trivial</code>的构造函数的影子。整个binary中也找不到<code>Trivial</code>的构造函数。</p>
<p>事实上，平凡类就是没有构造函数的，或者说编译器会为它生成一个<strong>trivial</strong>的构造函数。而一个trivial的构造函数就类似于C中struct的初始化：什么都不做。因此编译器实际上不会为平凡类生成构造函数。而平凡类不允许有自定义的构造函数，结论就是平凡类就不可能有构造函数。</p>
<p>然而有一种情况下，编译器还真会给平凡类生成一个构造函数，那就是显式声明一个<code>= default</code>的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Trivial</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> x;</span><br><span class="line">    <span class="type">int64_t</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trivial</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000000004009e8 &lt;_ZN7TrivialC1Ev&gt;:</span><br><span class="line">  4009e8:   55                      push   %rbp</span><br><span class="line">  4009e9:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  4009ec:   48 89 7d f8             mov    %rdi,-0x8(%rbp)</span><br><span class="line">  4009f0:   90                      nop</span><br><span class="line">  4009f1:   5d                      pop    %rbp</span><br><span class="line">  4009f2:   c3                      retq</span><br><span class="line">  4009f3:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">  4009fa:   00 00 00</span><br><span class="line">  4009fd:   0f 1f 00                nopl   (%rax)</span><br></pre></td></tr></table></figure>

<p>虽然这个函数里明显什么事情都没做，但它确实存在了。</p>
<p>当然，加上“-O2”你会发现，它又没了。</p>
<p>实际上，所有没有自定义构造函数的，满足bitwise语义的类，都可能没有构造函数。这个范围会比平凡类大一些。</p>
<h2 id="编译器生成默认构造函数的条件"><a href="#编译器生成默认构造函数的条件" class="headerlink" title="编译器生成默认构造函数的条件"></a>编译器生成默认构造函数的条件</h2><p>第二个问题，编译器什么时候会为一个类生成一个默认构造函数？</p>
<p>编译器只会在<strong>必要</strong>的时候为一个类生成默认构造函数。所谓必要，指：</p>
<ul>
<li>这个类没有自定义的构造函数或声明默认构造函数为<code>= default</code>，且</li>
<li>没有用<code>= delete</code>删除默认构造函数，且</li>
<li>代码中调用到了这个类的默认构造函数。</li>
</ul>
<p>第一个条件很好理解，C++的编译器是充分相信程序员的，如果一个程序员写了随便一个构造函数，编译器会尊重Ta，不再为其生成默认构造函数。</p>
<p>第二个条件是指，编译器不会在看到这个类的定义时就为其生成一个默认构造函数，而是会推迟这个生成时机，直到有代码真的调用了才生成。</p>
<p>然而，即使满足上面的条件，如果类中默认构造函数没有声明为<code>= default</code>，且编译器判断这个类可以bitwise构造，编译器仍然不会真的生成一个默认构造函数。</p>
<h2 id="bitwise与memberwise"><a href="#bitwise与memberwise" class="headerlink" title="bitwise与memberwise"></a>bitwise与memberwise</h2><p>当我们说到构造函数时，一个不得不提的概念是bitwise与memberwise。实际上这两个概念更多的是用来描述拷贝，但在构造上也有着类似的效果。</p>
<p>一个类型，如果满足：</p>
<ul>
<li>是标量类型，或</li>
<li>是自定义类型，且满足：<ul>
<li>没有虚函数。</li>
<li>没有虚基类。</li>
<li>没有不符合bitwise语义的非静态成员变量。</li>
<li>没有不符合bitwise语义的基类。</li>
<li>没有自定义的构造函数。</li>
</ul>
</li>
</ul>
<p>那它就满足bitwise构造的条件，即它在构造时没有任何特殊的操作（除了给它分配内存外），它的默认构造函数就是trivial的，实际上编译器不会真的生成这个函数。</p>
<p>而反过来，不满足这个条件的类，它就需要依次初始化每个成员，即是memberwise。</p>
<p>trivial的构造函数要比自定义的构造函数低很多（什么都不做），但它伤害到了正确性，即类的成员是没有一个可预期的初始值的的。从这个角度讲，即使是满足上面条件的类，我们也不应放任编译器选择trivial的默认构造函数，而应该自己定义一个正确初始化每个成员值的默认构造函数。当然，如果你要定义一个POD类型的话，除外。</p>
<h2 id="构造函数的内容"><a href="#构造函数的内容" class="headerlink" title="构造函数的内容"></a>构造函数的内容</h2><p>一个构造函数有哪些内容？比如，对于一个有着两个基类A和B的有虚函数的类型C，它的构造函数需要完成以下工作：</p>
<ul>
<li>初始化基类A。</li>
<li>初始化基类B。</li>
<li>确保虚表指针指向正确的位置。</li>
<li>初始化每个成员。</li>
<li>依次调用构造函数体中的语句。</li>
</ul>
<p>很显然，C要先完成A和B的构造，才能保证C自己的构造过程开始时，它已经“is a”A和B的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> x;</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        x = <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">F</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> y;</span><br><span class="line">    <span class="built_in">B</span>() &#123;</span><br><span class="line">        y = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>: <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line">    <span class="type">int32_t</span> z;</span><br><span class="line">    <span class="built_in">C</span>(): <span class="built_in">z</span>(<span class="number">3</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个例子中，在<code>A::A</code>中我们调用了一个虚函数<code>F</code>，假如整个过程发生在C的构造中，它调用的是哪个<code>F</code>？<code>A::F</code>还是<code>C::F</code>？</p>
<p>我们知道，在C去构造它的A的子对象时，它自己的成员都还没有初始化，那么此时去调用<code>C::F</code>显然是不合理的。因此我们有一个结论：构造函数中虚函数没有动态绑定，只有静态绑定。</p>
<p>《深入探索C++对象模型》中提到，当时的编译器在初始化基类子对象时，是通过将虚表指针指向基类的虚表，来实现一种伪的静态绑定。这么做的理由是不区别对待构造函数与其它函数。但这显然会伤害到效率。因此现代的编译器都会区别对待构造函数，真的静态绑定其中每个成员变量的调用。</p>
<p>通常我们会显式的把基类的构造写到派生类的初始化列表中。但即使不这么做，编译器也会将基类子对象的构造插到派生类的每个构造函数的开头，当然这要求基类有一个默认构造函数，或编译器能为其生成一个默认构造函数。</p>
<p>OK，在成功地构造完基类子对象后，C开始忙自己的构造了。</p>
<p>首先，如果C有虚表，那么要把虚表设置到正确地位置上。</p>
<p>之后开始按<strong>声明</strong>顺序依次构造C的每个非静态成员变量。</p>
<p>这里的“声明”要加粗，是因为如果忽略这一点，我们很可能会得到一个编译器的警告。</p>
<p>在这个阶段，每个非静态成员变量的初始值可能会来自三个地方：</p>
<ul>
<li>初始化列表中的表达式。</li>
<li>成员初始化式（C++11新增）中的表达式。</li>
<li>该成员的默认构造函数（如果非trivial）。</li>
</ul>
<p>其优先级依次下降。其中最后一项不涉及顺序，而前两项都可能会涉及到不同成员变量间的构造顺序。</p>
<p>对于下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y = z + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="built_in">S</span>(): <span class="built_in">z</span>(<span class="number">0</span>), <span class="built_in">x</span>(y + <span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们构造出一个<code>S</code>的对象时，会发现它的<code>x</code>和<code>y</code>两个成员的值是未初始化的！这就是因为，<code>x</code>依赖了它后面声明的<code>y</code>，而<code>y</code>依赖了它后面声明的<code>z</code>，导致当它们进行初始化时，依赖的值都还没有初始化，自然会得到一个错误的值。</p>
<p>OK，初始化列表结束后，此时c已经是一个合法的，所有成员和函数都可用的C对象了。接下来要执行的就是构造函数体本身了。</p>
<p>这里有一个值得注意的点。执行到构造函数体前，类的所有成员变量都已经初始化过了，如果我们在构造函数体中再对其进行赋值，大概率浪费了前面的初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="built_in">S</span>(<span class="type">const</span> std::string&amp; s) &#123;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，在整个构造过程中，<code>name</code>执行了一次默认构造函数，和一次赋值。而如果将这次赋值放到初始化列表中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="built_in">S</span>(<span class="type">const</span> std::string&amp; s): <span class="built_in">name</span>(s) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>name</code>就只执行了一次复制构造函数。对于很多类型来说，后者的好处还是很明显的。</p>
<h2 id="单参数构造函数要声明为explicit"><a href="#单参数构造函数要声明为explicit" class="headerlink" title="单参数构造函数要声明为explicit"></a>单参数构造函数要声明为<code>explicit</code></h2><p>某种说法认为C++不是强类型语言，因为它允许类型间的隐式转换。C++中的隐式转换有一部分是因为要兼容C而背的包袱，导致整型的重载无比混乱。而另一部分隐式转换就是C++自己设计的问题了。</p>
<p>在某些场景下，C++的隐式转换是很有用的，但在很可能多得多的场景下，如果滥用隐式转换，就会带来潜在的问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    std::vector&lt;std::string&gt; v;</span><br><span class="line">    <span class="built_in">S</span>(<span class="type">int</span> x): <span class="built_in">v</span>(x, <span class="string">&quot;aaa&quot;</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> S&amp; s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v.size:&quot;</span> &lt;&lt; s.v.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Func</span>(<span class="number">100</span>); <span class="comment">// oops!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>Func</code>实际只接受<code>const S&amp;</code>类型的参数，但我们搞错了，传进去了100。我们预期的结果当然是编译器报错，找不到<code>Func(int)</code>，但实际呢？程序编译通过，成功运行，结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.size:100</span><br></pre></td></tr></table></figure>

<p>发生了什么？隐式转换。编译器看到<code>Func(100)</code>时，它首先会去找<code>Func</code>，只找到了<code>Func(const S&amp;)</code>，没找到<code>Func(int)</code>。于是编译器会找有没有哪种隐式转换，允许将一个<code>int</code>转换为<code>S</code>，还真有，<code>S</code>正好有个构造函数是<code>S(int)</code>！于是编译器这里就执行了<code>S</code>的构造函数，构造出一个有着100个元素的对象。</p>
<p>怎么避免上面的场景发生？我们就要想办法禁止<code>int</code>到<code>S</code>的隐式转换，而<code>explicit</code>就是这个作用。当它被用来修饰一个单参数的构造函数时，就会阻止编译器产生一种隐式转换的关系：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    std::vector&lt;std::string&gt; v;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">S</span><span class="params">(<span class="type">int</span> x)</span>: v(x, <span class="string">&quot;aaa&quot;</span>) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然而当我们真的想将<code>int</code>转换为<code>S</code>时，该怎么办？两种方法：</p>
<ul>
<li>显式构造：<code>Func(S(100))</code>。</li>
<li>static_cast：<code>Func(static_cast&lt;S&gt;(100))</code>。</li>
</ul>
<h2 id="全局变量的初始化不要依赖其它编译单元的全局变量"><a href="#全局变量的初始化不要依赖其它编译单元的全局变量" class="headerlink" title="全局变量的初始化不要依赖其它编译单元的全局变量"></a>全局变量的初始化不要依赖其它编译单元的全局变量</h2><p>这句话有两个前提：</p>
<ul>
<li>全局变量的初始化发生在<code>main</code>函数之前，串行进行。</li>
<li>不同的实现文件（.cpp或.cc）属于不同的编译单元，而不同编译单元的全局变量的初始化顺序在链接时由链接器决定。</li>
</ul>
<p>这就导致了一个类似于上面构造函数初始化列表的顺序问题，且它没有一个确定的顺序。</p>
<p>因此，如果一个全局变量在初始化时依赖了另一个编译单元的全局变量，很可能你会发现前者初始化时后者还没有初始化。</p>
<p>这里的全局变量也包括类的静态成员变量。</p>
<p>那么，如果真有这种全局变量的初始值依赖于其它变量，该怎么做呢：</p>
<ul>
<li><p>相同编译单元的全局变量的初始化顺序是确定的，可依赖的。</p>
</li>
<li><p>如果必须跨编译单元依赖，那么把被依赖的变量放到一个函数里作为static变量。标准规定了函数中的static变量其初始化是在第一次调用时（运行到此行时），这是确定的，可依赖的：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="function">TypeA <span class="title">gX</span><span class="params">(SomeFunc())</span></span>;</span><br><span class="line"><span class="comment">// b.h</span></span><br><span class="line"><span class="function"><span class="type">const</span> TypeB&amp; <span class="title">SomeFunc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="function"><span class="type">const</span> TypeB&amp; <span class="title">SomeFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> TypeB b;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  别担心这里构造static变量没加锁，C++11后标准中规定了这种构造是线程安全的。</p>
</li>
</ul>
<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><h2 id="编译器生成析构函数的条件"><a href="#编译器生成析构函数的条件" class="headerlink" title="编译器生成析构函数的条件"></a>编译器生成析构函数的条件</h2><p>与默认构造函数类似，编译器为一个类生成析构函数的条件为：</p>
<ul>
<li>这个类没有自定义的析构函数或声明析构函数为<code>= default</code>，且</li>
<li>没有用<code>= delete</code>删除析构函数，且</li>
<li>代码中调用到了这个类的析构函数。</li>
</ul>
<p>同样地，如果一个类符合bitwise析构的标准，编译器为它生成的析构函数就是trivial的，就是可以忽略的，此时这个类就没有析构函数了。</p>
<h2 id="析构函数的内容"><a href="#析构函数的内容" class="headerlink" title="析构函数的内容"></a>析构函数的内容</h2><p>析构函数实际就是构造函数的逆过程。参考前面的类C，它的析构函数有以下内容：</p>
<ul>
<li>依次调用析构函数体中的语句。</li>
<li>按<strong>声明</strong>逆序调用每个成员变量的析构函数。</li>
<li>按<strong>声明</strong>逆序调用每个基类子对象的析构函数。</li>
</ul>
<p>同样地，析构函数中也会遇到虚函数的绑定问题。与构造函数类型，所有出现在析构函数中的虚函数，都是静态绑定，因为在析构基类子对象时，派生类自己的成员已经都析构掉了，此时再调用派生类改写的方法大概率会出问题。</p>
<h2 id="有虚函数的类也需要一个虚析构函数的定义"><a href="#有虚函数的类也需要一个虚析构函数的定义" class="headerlink" title="有虚函数的类也需要一个虚析构函数的定义"></a>有虚函数的类也需要一个虚析构函数的定义</h2><p>这里有两个值得注意的点。</p>
<p>第一个，一个类有虚函数，但析构函数不是虚函数，会有大问题的。我们为一个类增加虚函数时，一定是准备实现运行期多态的（否则声明虚函数干什么）。而我们知道运行期多态是要靠基类的指针和引用来触发的。对于下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> p;  <span class="comment">// oops!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~Base</span><br></pre></td></tr></table></figure>

<p>没有调用真正类型的析构函数，是个大问题！尤其是，<code>Derived::name</code>也没有被析构，出现了内存泄漏！</p>
<p>因此，第一个结论：有虚函数的类，一定要有虚的析构函数。</p>
<p>第二个值得注意的点，纯虚基类，析构函数也要有定义，不能是纯虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的问题在于，它的所有派生类在析构时都会调用到<code>Base</code>的析构函数，然而发现这个函数没有定义！编译会因此失败。</p>
<p>因此，第二个结论：不能有纯虚的析构函数，也不能禁止生成析构函数（通过声明为<code>= delete</code>或声明为private却不给定义），一定要给析构函数一个定义（或等待编译器为你生成一个）。</p>
<h2 id="变量的析构时间"><a href="#变量的析构时间" class="headerlink" title="变量的析构时间"></a>变量的析构时间</h2><p>标准规定了一个local变量的析构时间是在它出scope时，这个规则很简单，但有些特殊场景还是要单独说一下：</p>
<ul>
<li><p>全局变量、静态变量的构造时间是在<code>main</code>函数以前，而析构时间则是在<code>main</code>函数以后。同样地，不同编译单元间全局&#x2F;静态变量的析构函数也是不确定的。</p>
</li>
<li><p>临时变量的析构时间为代码中其所在的最外层表达式执行完成后，即：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* s = <span class="built_in">getStringObject</span>().<span class="built_in">c_str</span>();</span><br><span class="line"><span class="comment">// temp obj destructs here and s becomes danling!</span></span><br></pre></td></tr></table></figure>

<p>  这里<code>getStringObject()</code>会返回一个临时的<code>std::string</code>对象，这个对象的生命期会直到完成<code>s</code>的赋值后，下一行调用开始前。</p>
</li>
<li><p>但被赋值给const引用的临时变量，其生命期会与这个const引用保持一致，直到这个引用出scope才析构：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> std::string&amp; s = <span class="built_in">getStringObject</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="comment">// temp obj destructs here</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果<code>goto</code>跳回到函数前面，则这段代码中定义的变量都会被析构：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RETRY:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">goto</span> RETRY; <span class="comment">// name and v will be destructed.</span></span><br></pre></td></tr></table></figure></li>
<li><p>存在短路逻辑的表达式中，编译器需要插入一些代码才能确定临时对象的析构时间：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((s + t) || (u + v)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里面<code>s + t</code>会产生临时对象，但<code>u + v</code>只能说<strong>可能</strong>产生临时对象，因为如果表达式被短路，根本走不到后半截，就不会产生这个临时对象，那么这个临时对象也就不需要被析构。编译期怎么会知道这个表达式会不会被短路呢？因此编译器需要插入一些代码来产生不同分支。这也稍稍增加了些运行期的开销。</p>
</li>
</ul>
<p>当一个函数有着很多出口时，想决定一个local变量的scope就变困难了，编译器需要在每个可能<code>return</code>的地方都加上一些用于析构已经存在的变量，这也会增大binary的体积。</p>
<h2 id="不要手动调用local变量的析构函数"><a href="#不要手动调用local变量的析构函数" class="headerlink" title="不要手动调用local变量的析构函数"></a>不要手动调用local变量的析构函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    b.<span class="built_in">f</span>();</span><br><span class="line">    b.~<span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">new</span>(&amp;b) Derived;</span><br><span class="line">    b.<span class="built_in">f</span>();            <span class="comment">// which f?</span></span><br><span class="line">&#125; <span class="comment">// which dtor?</span></span><br></pre></td></tr></table></figure>

<p>上面是一个很tricky的例子，我们手动调用了<code>b</code>的析构函数，又在其原地构造了一个派生类对象。此时再调用<code>f</code>，调用的会是哪个版本？出scope时，调用的是谁的析构函数？</p>
<p>实际这都是未定义的问题，编译器很可能不会按我们的想法去实现。因此结论就是不要这么用。</p>
<h1 id="异常场景"><a href="#异常场景" class="headerlink" title="异常场景"></a>异常场景</h1><p>当有了异常之后，构造函数和析构函数就更复杂了：</p>
<ul>
<li>构造函数抛了异常后，已经构造完的基类子对象和成员变量要析构，但未构造的成员不要析构，因此编译器需要插入大量代码。</li>
<li>构造函数如果在进入函数体之前抛异常，此时对象本身还不完整（有成员未构造完），那么就不能执行析构函数。</li>
<li>异常会导致函数栈unwind，期间每个还存活的对象都要析构，同样需要插入大量代码。</li>
<li>异常还可能会被catch住，此时unwind停止，不再析构存活对象，又要做一些判断。</li>
<li>当异常未被catch住时，如果unwind导致的析构抛了异常，同时存在两个异常会导致程序crash。</li>
</ul>
<p>因此异常是一种比较昂贵的特性，想实现好异常安全也不那么容易，比如STL容器为了保证修改时的异常安全，做了非常多的事情。</p>
<p>但辩证的看，异常本身还是一种很有用的特性，至少我是支持使用异常的，只要知道上面这些开销，尽量避免错误的使用就好了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/18/cpp-object-model-inheritance-and-polymorphism/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/18/cpp-object-model-inheritance-and-polymorphism/" class="post-title-link" itemprop="url">C++对象模型（四）继承与多态</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-18 23:21:14" itemprop="dateCreated datePublished" datetime="2018-03-18T23:21:14+08:00">2018-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当C++刚刚问世时，它的两大卖点是：</p>
<ul>
<li>与C兼容。</li>
<li>面向对象。</li>
</ul>
<p>而说到面向对象时，就绕不开多态。说到多态，就绕不开继承。</p>
<p>所谓多态，即同样的代码，不同的行为。根据这种行为差异的发生时机，我们把多态分成了编译时多态和运行时多态。继承能实现的就是运行时多态。</p>
<p>本文想讨论的是C++为继承和运行时多态准备了什么样的对象模型</p>
<ul>
<li>注1：本文中的“多态”特指“运行时多态”。</li>
<li>注2：本文不讨论虚继承及其背后的对象模型。</li>
<li>注3：本文主要内容来自<a target="_blank" rel="noopener" href="https://book.douban.com/subject/10427315/">《深入探索C++对象模型》</a>。</li>
</ul>
<h1 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h1><h2 id="简单对象模型"><a href="#简单对象模型" class="headerlink" title="简单对象模型"></a>简单对象模型</h2><p>第一种模型十分简单，每个对象就是一个表格，其中每个slot按成员的声明顺序指向对应的成员，包括成员函数与成员变量。</p>
<p>即对于下面的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="built_in">Base</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">int64_t</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">G</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="type">int32_t</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">H</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它的一个对象为：</p>
<p><img src="http://7xipsa.com1.z0.glb.clouddn.com/cpp_object_model_one_member_one_slot.png" alt="one slot per member"></p>
<p>这个模型是为了尽量降低C++编译器的设计复杂度，这样我们不需要知道每个成员的大小，只要知道成员的数量，就能计算出对象本身需要占的空间了。每个成员都有着固定的偏移量，因此如果要实现多态，只要改变这个slot对应的函数地址即可。实际我们可以看到，这个模型下每个函数都可以是虚函数，即派生类可以改写基类的任何函数。</p>
<p>它的缺点也很明显：不与C的struct兼容；访问成员需要至少一次间接寻址，开销大。</p>
<p>没有哪个编译器真的采用了这个模型，但它的思想，即每个成员对应一个slot，被吸收到了“指向成员的指针”中。</p>
<h2 id="双表格对象模型"><a href="#双表格对象模型" class="headerlink" title="双表格对象模型"></a>双表格对象模型</h2><p>第二种模型使用了两个表格，一个对应成员函数，一个对应成员变量，而对象内则只有指向这两个表格的指针。</p>
<p>对于上面的<code>Base</code>类，新的对象模型为：</p>
<p><img src="http://7xipsa.com1.z0.glb.clouddn.com/cpp_object_model_double_table.png" alt="double_table"></p>
<p>这个模型的好处是令所有对象都有着相同的大小和表现形式。它也是一种停留在理论中的模型，但“函数表格”这一思想却启发了后面的虚表模型。</p>
<h2 id="虚表对象模型"><a href="#虚表对象模型" class="headerlink" title="虚表对象模型"></a>虚表对象模型</h2><p>Stroustrup在设计C++时的一个理念就是，让用户不使用的特性零开销。C++的class就体现了这一点。</p>
<p>从演化路径来看，从C的struct到C++的class，大致过程为：</p>
<p>纯数据的结构体 -&gt; 数据+操作的抽象数据类型 -&gt; 能表现多态的类型。</p>
<p>参考之前的文章，我们可以看到：</p>
<ul>
<li>纯数据的结构体，对应C++中的标准布局类，其相比C的struct没有任何额外开销。</li>
<li>抽象数据类型（ADT），对应C++中的无虚函数的class，其成员变量均有着固定的偏移，与纯结构体相比无额外开销；其成员函数不占用对象本身体积，且调用一个成员函数与调用一个全局函数相比也无额外开销。</li>
</ul>
<p>现在到了最后一种，当class需要能支持多态，我们该如何设计，来保证上面这两种使用方式不受影响？</p>
<p>Stroustrup选择了一种折衷的方案，即：</p>
<ul>
<li>每个有虚函数的类型对应一个表格，称为虚表，其中每个slot对应一个虚函数的实际地址。另外虚表的第0个slot指向了这个类型的<code>type_info</code>，用于RTTI。</li>
<li>有虚函数的对象内会增加一个指向虚表的指针，这样在运行时可以通过虚表跳转来实现多态。</li>
</ul>
<p>对于上面的<code>Base</code>类，虚表对象模型为：</p>
<p><img src="http://7xipsa.com1.z0.glb.clouddn.com/cpp_object_model_vtpr.png" alt="vtpr"></p>
<p>当我们不向class中增加虚函数时，编译器不会生成虚表，也不会向对象内增加一个虚表指针，一切都和原来一样。当我们加入虚函数，编译器才会为了这种运行时特性而做上述工作。</p>
<p>之所以不把虚表直接放到对象中，是为了避免对象体积太大，因此我们宁愿多一次虚表指针的跳转。</p>
<p>这个模型下每个成员变量就在对象中，因此在定义类时我们要能看到每个成员变量的布局，知道它的大小，因此无论哪个成员变量发生了变化，我们都要重新编译、链接。这是为了运行效率而付出的代价。</p>
<p>标准中并没有规定编译器一定要这么实现，但目前几乎所有编译器都采用了这种虚表模型，且几乎都选择了把虚表指针放到对象头部（而CFront则放到尾部）。</p>
<h3 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h3><p>以下内容参考GCC的实现，部分脑补，总之理论上是个可以工作的模型。</p>
<p>每个有虚函数的类都对应着一个单独的虚表，而这个类的所有对象中只有指向它的指针。</p>
<p>非派生类型的虚表长度为N+2，其中N为虚函数的个数，按虚函数声明顺序对应，另外的2则分别为第0个位置的<code>type_info*</code>，和最后一个位置的<code>NULL</code>。</p>
<p>派生类型的虚表长度为S0+S1+…+N+1，其中S0、S1等分别为其第0个基类、第1个基类等的虚表长度，N为该派生类型自己增加的虚函数数量，1是最后一个位置的<code>NULL</code>（如果N不为0的话）。按上一条，S0、S1的长度是N0+2、N1+2，已经包含了<code>type_info*</code>和<code>NULL</code>，因此派生类的虚表中有K个<code>type_info*</code>，且都指向派生类自己的<code>type_info</code>，这里K是其基类数量。</p>
<p>因此派生类的虚表取不同的偏移，就可以得到与其某个基类完全兼容的虚表，但其中每个slot指向的函数则可能是派生类自己的实现。</p>
<h2 id="单继承下的对象模型"><a href="#单继承下的对象模型" class="headerlink" title="单继承下的对象模型"></a>单继承下的对象模型</h2><p>从前文中我们知道派生类对象中会有一个基类的子对象，而标准规定了这个基类子对象要“有其完整原样性”，即与一个独立的基类对象有着完全相同的性质。</p>
<p>编译器要首先保证这一点，再去安排派生类对象自己的成员。标准未规定基类子对象在派生类对象中该处于什么位置，但几乎所有编译器都将基类子对象放到了派生类对象的头部。</p>
<h3 id="无虚函数"><a href="#无虚函数" class="headerlink" title="无虚函数"></a>无虚函数</h3><p>当基类与派生类均无虚函数时，也就意味着派生类对象中不需要有虚表。此时的派生类对象的内存布局见<a href="/2018/03/11/cpp-object-model-struct/#%E4%B8%BAstruct%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%97%A0%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%9D%9E%E8%99%9A%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%B1%BB">为struct添加一个无虚函数的非虚继承基类</a>。</p>
<p>这种继承有一个很不一样的地方：它没有产生多态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> Base&amp; b)</span> </span>&#123;</span><br><span class="line">    b.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，当我们在<code>Func</code>中调用<code>b.Print()</code>时，编译器知道<code>Base::Print</code>不是虚函数，也就意味着它不可能被任何派生类改写，因此编译器会直接将其绑定到<code>Base::Print</code>上，即<code>Func</code>的运行时行为在编译时已经确定了。</p>
<h3 id="基类有虚函数"><a href="#基类有虚函数" class="headerlink" title="基类有虚函数"></a>基类有虚函数</h3><p>当基类有虚函数时，意味着派生类也有虚函数，即派生类对象与其中的基类子对象都需要有一个虚表指针，且要指向正确的虚表。</p>
<p>前面我们介绍虚表的时候提到，对派生类的虚表加上不同的偏移量，就能得到与其每个基类虚表完全兼容的虚表，其中第0个基类的偏移量就是0。因此单继承下，派生类对象中也不需要有多个虚表指针，只要头部放置一个虚表指针，就可以同时满足基类子对象与派生类对象的需求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> x;</span><br><span class="line">    <span class="type">int32_t</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int32_t</span> z;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    Base&amp; b = d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(Base):%d sizeof(Derived):%d &amp;d:%x &amp;b:%x\n&quot;</span>, <span class="built_in">sizeof</span>(Base), <span class="built_in">sizeof</span>(Derived), &amp;d, &amp;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sizeof(Base):24 sizeof(Derived):24 &amp;d:edcc4968 &amp;b:edcc4968</span><br></pre></td></tr></table></figure>

<p>此时<code>Derived</code>对象长成这样：</p>
<p><img src="http://7xipsa.com1.z0.glb.clouddn.com/cpp_object_model_single_inherit.png" alt="single"></p>
<p>可以看到：</p>
<ul>
<li>基类子对象的偏移确实是0，说明它与派生类对象共享了虚表指针。</li>
<li>基类子对象与派生类自己的成员之间没有加padding，这与标准布局差别很大，更紧凑了。实际上标准没有对非标准布局有任何明确规定，且对于有虚函数的类型，直接bitwise操作本身就是未定义行为，因此编译器就可以自由选择一种比较紧凑的布局，而不需要担心我们直接操作基类子对象时把派生类的成员变量给破坏了。</li>
</ul>
<h3 id="基类无虚函数，派生类有虚函数"><a href="#基类无虚函数，派生类有虚函数" class="headerlink" title="基类无虚函数，派生类有虚函数"></a>基类无虚函数，派生类有虚函数</h3><p>如果基类没有虚函数，那么基类子对象就不需要有虚表指针；派生类有虚函数，那么派生类对象就需要有虚表指针。因此派生类对象内还是需要一个虚表指针。</p>
<p>GCC的实现是仍然把虚表指针放到派生类对象头部，而基类子对象在其后，此时基类子对象有一个指针的偏移。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> x;</span><br><span class="line">    <span class="type">int32_t</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int32_t</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sizeof(Base):16 sizeof(Derived):32 &amp;d:e1855960 &amp;b:e1855968</span><br></pre></td></tr></table></figure>

<p>此时<code>Derived</code>对象长成这样：<br><img src="http://7xipsa.com1.z0.glb.clouddn.com/cpp_object_model_single_base_nonvirtual.png" alt="base_non_virtual"></p>
<p>可以看到：</p>
<ul>
<li>基类子对象的偏移量为8。</li>
<li>基类子对象后加了padding。此时基类是平凡类，是有可能被人直接以bitwise的方式操作，不加padding就会有危险。</li>
</ul>
<h2 id="多继承下的多对象模型"><a href="#多继承下的多对象模型" class="headerlink" title="多继承下的多对象模型"></a>多继承下的多对象模型</h2><p>当派生类有多个基类时，每个基类自身可能有虚函数，可能没有。对于有虚函数的基类，派生类对象需要为其准备一个虚表指针。对于没有虚函数的基类，则不需要有虚表指针。</p>
<p>如果第0个基类是有虚函数的，那么派生类对象就可以与其共享虚表指针。因此GCC会将其第一个有虚函数的基类子对象放到派生类对象的头部，从而节省一个虚表指针。</p>
<p>而后面的基类则因为其虚表在派生类虚表中的偏移量不为0，无法共享虚表指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> x;</span><br><span class="line">    <span class="type">int32_t</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line">    <span class="type">int32_t</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sizeof(Base1):24 sizeof(Base2):4 sizeof(Derived):32 &amp;d:e5fe3960 &amp;b1:e5fe3960 &amp;b2:e5fe3974</span><br></pre></td></tr></table></figure>

<p>即使我们把<code>public Base1, public Base2</code>换成<code>public Base2, public Base1</code>，结果也没有任何变化。</p>
<p>此时<code>Derived</code>对象长成这样：<br><img src="http://7xipsa.com1.z0.glb.clouddn.com/cpp_object_model_one_virtual_one_nonvirtual.png"></p>
<p>而当我们为<code>Base2</code>也添加一个虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> z;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">G</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line">    <span class="type">int32_t</span> r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">G</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sizeof(Base1):24 sizeof(Base2):16 sizeof(Derived):40 &amp;d:e2c5d958 &amp;b1:e2c5d958 &amp;b2:e2c5d970</span><br></pre></td></tr></table></figure>

<p>此时<code>Derived</code>对象长成这样：<br><img src="http://7xipsa.com1.z0.glb.clouddn.com/cpp_object_model_both_virtual.png"></p>
<p>可以看到：</p>
<ul>
<li>每个基类子对象都有自己的虚表指针。其中第0个基类子对象的虚表指针与派生类对象本身是共享的。</li>
<li>但两个虚表指针实际都指向派生类自己的虚表，只不过指向的位置不同。</li>
<li>除了第0个基类子对象，其它基类子对象的偏移量都不是0。</li>
</ul>
<h1 id="指向成员的指针"><a href="#指向成员的指针" class="headerlink" title="指向成员的指针"></a>指向成员的指针</h1><p>C++中有一类指针比较特殊，它们是指向类型成员的指针，比如上例中的<code>&amp;Derived::x</code>、<code>&amp;Derived::G</code>等，它们的类型分别是<code>int64_t Base1::*</code>和<code>void (Derived::*)()</code>。这些指针是不能单独使用的，必须要通过一个对应类型的对象来解引用，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">d.x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> px = &amp;Derived::x;</span><br><span class="line">d.*px = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pf = &amp;Derived::F;</span><br><span class="line"><span class="type">int</span> ret = d.*<span class="built_in">pf</span>();</span><br></pre></td></tr></table></figure>

<p>这里我们已经能感觉到它们的不一样了。</p>
<p>指向成员的指针，真的是指针吗？</p>
<p>是指针，但与普通的指针不一样：</p>
<ul>
<li>不能转换为<code>void*</code>或<code>intptr_t</code>等类型。</li>
<li>与普通指针的大小不一定相同，比如在我的环境（64位clang）下，<code>&amp;Derived::x</code>是8字节，而<code>&amp;Derived::F</code>则是16字节。</li>
<li>其值不一定表示地址。</li>
</ul>
<p>对于第三条，大致有以下规则：</p>
<ul>
<li>指向成员变量的指针，其值为该变量在对象内的偏移量，比如<code>&amp;Derived::x</code>就是8，而<code>&amp;Base1::x</code>则是0，这样我们能通过一个对象直接寻址到这个变量。</li>
<li>指向非虚成员函数的指针，其大小仍是16字节（我的环境中），但其值真的是这个函数的入口地址，而不是偏移量。</li>
<li>指向虚的成员函数的指针，其值是该函数在该类型的虚表中的偏移量。我们知道虚表的第0位不是虚函数，因此任何指向虚函数的合法指针都不可能是0，通过这一点我们也保证了，如果一个指向虚函数的成员指针为0，那么它一定是空指针。</li>
</ul>
<p>实际上指向成员函数的指针占两个普通指针的长度，其中就包含了一些辅助信息，来帮助我们在运行时无论遇到虚函数指针还是非虚函数指针，都能正确跳转。</p>
<h1 id="static-cast、dynamic-cast、reinterpret-cast"><a href="#static-cast、dynamic-cast、reinterpret-cast" class="headerlink" title="static_cast、dynamic_cast、reinterpret_cast"></a><code>static_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code></h1><p>对于基类和派生类，我们有两种cast，分别是down-cast与up-cast，即基类-&gt;派生类和派生类-&gt;基类。</p>
<h2 id="up-cast"><a href="#up-cast" class="headerlink" title="up-cast"></a>up-cast</h2><p>up-cast通常不需要我们显式调用，因为这就是多态正常的使用方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(Base&amp; b)</span> </span>&#123;</span><br><span class="line">    b.<span class="built_in">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="built_in">Func</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们把<code>Derived&amp;</code>传给<code>Func</code>，后者看到的却是一个<code>Base&amp;</code>，这里就是发生了up-cast，也是一次隐式转换。如果在某个地方，我们要显式做up-cast，就要使用<code>static_cast</code>了。</p>
<p>重点来了：当编译器做up-cast时，它会根据基类子对象在派生类对象中的偏移量，修改对应指针的值。即当代码里写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base* pb = pd;</span><br></pre></td></tr></table></figure>

<p>时，实际发生的是（假设翻译成C）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* p = pd;</span><br><span class="line">Base* pb = (Base*)(p == <span class="number">0</span>? <span class="number">0</span>: p + offset);</span><br></pre></td></tr></table></figure>

<p>因此每次up-cast都会有一次分支。而对于基类无虚函数派生类有虚函数，以及多基类场景下，我们都能看到地址发生了变化。</p>
<p>C++标准保证了即使我们使用C风格的转换（即<code>(Base*)pd</code>），编译器也会在其上进行正确的偏移。</p>
<p>而如果我们使用<code>interpret_cast</code>就得不到正确的结果了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">Base2* x = &amp;d;</span><br><span class="line">Base2* y = <span class="built_in">reinterpret_cast</span>&lt;Base2*&gt;(&amp;d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x:%p y:%p\n&quot;</span>, x, y);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x:0x7ffee7990968 y:0x7ffee7990950</span><br></pre></td></tr></table></figure>

<p>在我的环境中，这里还有个warning，提醒我换成<code>static_cast</code>。</p>
<p>因此结论是：如果要做up-cast，一定不能用<code>reinterpret_cast</code>，要用<code>static_cast</code>，最差也要用C风格的转换。</p>
<h2 id="down-cast"><a href="#down-cast" class="headerlink" title="down-cast"></a>down-cast</h2><p>而down-cast就是基类指针转派生类指针。这里正确的做法是使用<code>dynamic_cast</code>，它会做以下事情：</p>
<ul>
<li>通过基类指针找到其虚表。</li>
<li>从虚表的第0位找到<code>type_info*</code>。</li>
<li>对比<code>type_info*</code>与目标类型，如果无法转换，则返回<code>nullptr</code>。</li>
<li>根据基类子对象在派生类对象中的偏移，计算出派生类指针并返回。</li>
</ul>
<p>而有些人会使用<code>static_cast</code>或C风格的转换来做down-cast。它们的问题都在于：不会做前三步的检查，只会做最后一步。</p>
<p>这就导致了，如果转换失败，<code>dynamic_cast</code>会返回<code>nullptr</code>，而<code>static_cast</code>或C风格转换则只会返回一个看似正确地减去了偏移量，实际指向了不知道哪里的派生类指针。</p>
<p>当然，<code>reinterpret_cast</code>就更不对了：它连偏移量都不会算。</p>
<h1 id="警惕Slicing"><a href="#警惕Slicing" class="headerlink" title="警惕Slicing"></a>警惕Slicing</h1><p>在<a href="/2018/03/11/cpp-object-model-struct/#%E4%B8%BAstruct%E6%B7%BB%E5%8A%A0%E8%99%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">为struct添加虚成员函数</a>中我们提到，只有通过引用或指针调用虚函数，编译器才会走虚表，才会有多态。实际上，为了与C兼容，保证运行效率，标准规定了这一点。因此直接操作对象时，我们只能得到确定的结果，而不是预期中的运行时多态。</p>
<p>这里有一个陷阱：当我们用派生类对象去赋值或初始化一个基类对象时，派生类的信息会被抹掉，最终我们仅仅得到一个基类对象。这种现象叫Slicing。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">Base2 b2 = d;</span><br><span class="line">b2.<span class="built_in">G</span>();</span><br></pre></td></tr></table></figure>

<p>也许我们预期<code>b2.G()</code>会调用<code>Derived::G</code>，但实际此时<code>b2</code>完完全全就是<code>Base2</code>的对象，因此它只会调用<code>Base2::G</code>。</p>
<p>这么做的原因是，<code>b2</code>是一个栈上对象，给它分配的空间就只有<code>sizeof(Base2)</code>这么多，因此它只能是一个<code>Base2</code>对象，而无法是派生类的对象。</p>
<p>这也是一个函数传递要传指针或引用的理由（除了开销与启用多态外），避免Slicing。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/17/redis-on-the-respberry-pi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/17/redis-on-the-respberry-pi/" class="post-title-link" itemprop="url">[翻译] Redis on the Raspberry Pi: adventures in unaligned lands</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-17 15:05:18" itemprop="dateCreated datePublished" datetime="2018-03-17T15:05:18+08:00">2018-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="http://antirez.com/news/111">原文地址</a></p>
<p>在售出1000万台设备，实际上是诸如传感器和显示器这样无数不同的应用和辅助设备后，可以说树莓派不仅仅是取得了成功，它还成为了一种程序员最喜爱的嵌入式实验平台。像是Pi zero这样的产品也在成为创造硬件产品的平台，且不会引入设计、构建、为车载设备写软件等方面的风险和开销。</p>
<p>同样地，我也认同Redis是一个程序员乐于去冒险、实验、构建新事物的平台。而且，能用于嵌入式&#x2F;物联网应用的设备，通常会有暂时或长期存储数据的需求，像是从传感器接收到的数据，需要在这台设备上运算的数据，或是要发往远程服务器的数据。Redis正在加入一种Stream数据类型，非常适合流式数据和时间序列存储，撰写本文时（2017年初）这个特性快要完成了，后续工作会在接下来几周内开始。Redis现存的数据结构，以及新增的Stream类型，以及它较小的内存使用，以及它即使在小型硬件（低功耗）上也能提供相当不错的性能，都让Redis看起来非常适合应用在树莓派，进而是其它小型ARM设备上。中间缺失的部分也很明显：在树莓派上把Redis跑起来。</p>
<p>树莓派的一个很酷的特点就是，它的开发环境不像过去的嵌入式系统那样，它上面跑的就是正常的Linux，还包括各种Debian系的工具。简单地说在树莓派上适配Redis不算很困难。Linux程序移植到树莓派上最常见的问题就是性能或内存占用不匹配，但在Redis上这不是问题，因为它本身就被设计为：空实例只占用1MB内存，且查询请求会走内存，因此它足够快，也不会给闪存太高的压力，而且在需要持久化时，它只会用AOF（Append Only File）。但树莓派上用的是ARM处理器，意味着我们要小心处理未对齐的内存访问。</p>
<p>本文会展示我为了让Redis能愉快地跑在树莓派上都做了什么，我会试着给出一个如何应对那些不能透明地处理非对齐内存访问的平台上（不像x86）的概述。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/03/17/redis-on-the-respberry-pi/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/15/cpp-object-model-pod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/15/cpp-object-model-pod/" class="post-title-link" itemprop="url">C++对象模型（三）POD</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-15 18:37:59" itemprop="dateCreated datePublished" datetime="2018-03-15T18:37:59+08:00">2018-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>注：本节不讨论<code>union</code>。</p>
<h1 id="Scalar-Type"><a href="#Scalar-Type" class="headerlink" title="Scalar Type"></a>Scalar Type</h1><p>第一个概念，Scalar Type，即标量类型。</p>
<p>所谓标量，就是一个数字，而标量类型，就是可以表示为一个数字的类型。</p>
<p>C++的标量类型为：</p>
<ul>
<li>各种整数&#x2F;浮点类型，如<code>int8_t</code>、<code>uint32_t</code>、<code>char</code>、<code>float</code>等，可满足<code>std::is_arithmetic&lt;T&gt;</code>为true。</li>
<li>枚举类型，可满足<code>std::is_enum&lt;T&gt;</code>为true。</li>
<li>各种指针类型，包括<code>std::nullptr_t</code>，可满足<code>std::is_pointer&lt;T&gt;</code>或<code>std::is_member_pointer&lt;T&gt;</code>为true。</li>
</ul>
<p>以上类型都属于标量类型，都可满足<code>std::is_scalar&lt;T&gt;::value</code>为true。</p>
<h1 id="Aggregate-Type"><a href="#Aggregate-Type" class="headerlink" title="Aggregate Type"></a>Aggregate Type</h1><p>第二个概念，Aggregate Type，即聚合类型。</p>
<p>所谓聚合类型，就是可以使用<code>= &#123;v1, v2, v3&#125;</code>这样语法（注意不是C++11的<code>std::initializer_list</code>特性）进行初始化或赋值的类型，对应C的数组和struct。</p>
<p>C++的聚合类型为：</p>
<ul>
<li>所有数组类型。</li>
<li>满足以下条件的类（包括<code>class</code>、<code>struct</code>）：<ul>
<li>所有非静态成员变量的访问权限都是<code>public</code>。</li>
<li>没有用户自定义的构造函数（但允许使用<code>= default</code>来显式使用编译器合成的构造函数，或使用<code>= delete</code>来显式禁止某种构造函数）。</li>
<li>没有基类（C++17后允许有<code>public</code>的非虚基类）。</li>
<li>没有虚函数。</li>
<li>成员变量没有默认初始化式（不在构造函数里那种）（C++11新增，但似乎C++14又去掉了此限制）。</li>
</ul>
</li>
</ul>
<p>根据上面的定义，聚合类型还有下面的几个特点：</p>
<ul>
<li>不要求其所有非静态成员变量均为聚合类型。</li>
<li>对静态成员没有任何限制。</li>
<li>只对构造函数有限制，对析构函数、赋值函数等无限制。</li>
<li>非聚合类型的数组也是聚合类型。</li>
</ul>
<p>当我们写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type a[m] = &#123;b0, b1, ..., bn-1&#125;;</span><br></pre></td></tr></table></figure>

<p>时：</p>
<ul>
<li>若m &#x3D;&#x3D; n，则会发生b0到a[0]、b1到a[1]等等n次复制初始化。</li>
<li>若m &lt; n，则报错。</li>
<li>若m &gt; n，则a[0]-a[n-1]发生复制初始化，而a[n]-a[m-1]则发生默认初始化。</li>
<li>若m为空，则a的长度会被设定为n，同样发生n次复制初始化。</li>
</ul>
<p>对于下面的聚合类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    TypeA a;</span><br><span class="line">    TypeB b;</span><br><span class="line">    TypeC c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S s = &#123;a<span class="number">&#x27;</span>, b<span class="number">&#x27;</span>, c<span class="number">&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>时：</p>
<ul>
<li>若<code>&#123;&#125;</code>内元素数量与<code>S</code>中非静态成员变量数量相等，会按a’-&gt;a、b’-&gt;b、c’-&gt;c的方式进行复制初始化。</li>
<li>若<code>&#123;&#125;</code>内元素数量更多，则报错。</li>
<li>若<code>S</code>中非静态成员变量数量更多，则后面的成员发生默认初始化。</li>
</ul>
<p>在初始化时：</p>
<ul>
<li>若发生复制初始化，则会调用相应类型的复制构造函数或赋值函数。</li>
<li>若列表中某项为表达式，则复制&#x2F;赋值时允许发生隐式转换（C++11开始要求不能是narrow转换）。</li>
<li>若列表中某项本身也是个<code>&#123;&#125;</code>列表，则要求对应的数组元素&#x2F;非静态成员变量也是聚合类型，尝试递归聚合赋值。</li>
<li>标量类型的默认初始化会将其初始化为0、0.0、false等。</li>
<li>引用类型的默认初始化会报错。</li>
</ul>
<p>在对聚合类型（非数组）做列表赋值时，我们还可以指定成员的名字，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a = &#123;.x = <span class="number">1</span>, .z = <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>它有以下特点：</p>
<ul>
<li>列表中名字顺序必须符合成员顺序，即<code>&#123;.z = 2, .x = 1&#125;</code>是不行的。（注意，<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/c/language/struct_initialization">C允许乱序，还允许其它多种初始化方式</a>，但C++不允许）</li>
<li>列表中元素数量可以少于成员数量，未在列表中出现的成员发生默认初始化，即上例中<code>a.y</code>为0。</li>
</ul>
<h1 id="Trivial-Type"><a href="#Trivial-Type" class="headerlink" title="Trivial Type"></a>Trivial Type</h1><p>第三个概念，Trivial Type，即平凡类型。</p>
<p>所谓平凡类型，可以认为是有bitwise语义的类型，即可以直接按字节复制的类型。C中的所有类型都是Trivial Type。</p>
<p>Trivial Type有两个标准：</p>
<ul>
<li>能trivial静态构造，即要有一个trivial的默认构造函数。</li>
<li>能trivial拷贝，即满足Trivial Copyable标准。</li>
</ul>
<p>Trivial Copyable类型即是满足<code>std::is_trivially_copyable&lt;T&gt;::value</code>为true的类型，它要求：</p>
<ul>
<li>所有复制构造、赋值函数要么是trivial的，要么是deleted。</li>
<li>所有移动构造、赋值函数要么是trivial的，要么是deleted。</li>
<li>至少有一个非deleted复制或移动的构造或赋值函数。</li>
<li>析构函数为trivial，且非deleted。</li>
</ul>
<p>构造函数、析构函数、复制构造&#x2F;赋值函数、移动构造&#x2F;赋值函数的trivial是指：</p>
<ul>
<li>满足bitwise语义。</li>
<li>要么是编译器隐式合成的版本。</li>
<li>要么通过<code>= default</code>显式使用编译器的合成版本。</li>
</ul>
<p>以上条件也就意味着一个Trivial Type：</p>
<ul>
<li>不能有虚函数（会导致构造函数等失去bitwise语义）。</li>
<li>不能有虚基类（同上）。</li>
<li>如果有基类，基类也要是Trivial Type。</li>
<li>不能有自定义的构造、析构、复制、移动函数。</li>
<li>不能有非Trivial Type类型的非静态成员变量。</li>
</ul>
<p>标量类型、Trivial Type的数组也是Trivial Type。</p>
<p>Trivial Type是用来区分那些可以像C一样通过<code>memset</code>、<code>memcpy</code>等函数直接构造和复制的类型，C++11中增加了<code>std::is_trivial</code>模板来判断一个类型是否是trivial的。</p>
<p>注意，Trivial Type还有以下特点：</p>
<ul>
<li>不限制成员变量的访问限制，即<code>public</code>、<code>protected</code>、<code>private</code>都可以。</li>
<li>只要求默认构造函数是trivial的，对其它构造函数没有要求。</li>
</ul>
<h1 id="Standard-Layout-Type"><a href="#Standard-Layout-Type" class="headerlink" title="Standard Layout Type"></a>Standard Layout Type</h1><p>第四个概念，Standard Layout Type，即标准布局类型。</p>
<p>标准布局的目的是定义一种与C兼容的内存布局，满足标准布局的类型即为标准布局类型，Standard Layout Type。</p>
<p>关于不同C++类型的内存布局，可以见上一篇文章<a href="/2018/03/11/cpp-object-model-struct/">C++对象模型（二）struct&#x2F;class的内存布局</a>。</p>
<p>C++的Standard Layout Type要求：</p>
<ul>
<li><p>所有非静态成员变量有着相同的访问权限。</p>
</li>
<li><p>没有虚函数或虚基类。</p>
</li>
<li><p>没有引用类型的非静态成员变量。</p>
</li>
<li><p>所有基类和非静态成员变量本身也是Standard Layout Type。</p>
</li>
<li><p>该类型与其所有基类中，最多只能有一个类型有非静态成员变量（其它类型都需要是空类型），即所有非静态成员变量都在一个类型中。</p>
</li>
<li><p>第一个非静态成员变量（包括继承自基类的成员）其类型不能与任一空基类相同（影响空基类优化）。</p>
</li>
<li><p>该类型的继承树中同一类型不能出现多次。</p>
<p>  例子：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Q</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: Q &#123;&#125;；</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span>: Q &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">U</span>: S, T &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>  <code>U</code>的继承树中<code>Q</code>出现了两次，则<code>Q</code>、<code>S</code>、<code>T</code>都是Standard Layout Type，但<code>U</code>不是。</p>
</li>
</ul>
<p>相同访问权限的原因：标准只规定了同一个section内成员的顺序，未规定不同section之间的顺序，因此若非静态成员变量分布在不同section下，无法给出一个确定的布局。</p>
<p>所有非静态成员变量都在一个类型中的原因：标准未规定基类子对象的位置，因此不同基类、或基类与子类的非静态成员变量间的顺序是未定义的。</p>
<p>没有虚函数或虚基类的原因：虚函数和虚基类会影响类的内存布局，但标准未规定其实现方式，因此有虚函数或虚基类的类型无法给出一个确定的布局。</p>
<p>第一个非静态成员变量不能与空基类类型相同的原因：标准规定同时存在的两个变量不能有相同地址，若应用空基类优化，则第一个非静态成员变量的地址与对象地址相同，也与所有空基类地址相同，若其中有相同类型，则导致该地址同时对应了多个变量。</p>
<p>C++11新增了<code>std::is_standard_layout</code>来判断一个类型是不是Standard Layout Type。</p>
<h2 id="标准布局"><a href="#标准布局" class="headerlink" title="标准布局"></a>标准布局</h2><p>C++的标准布局实际就是C中struct的布局，对于一个标准布局类的对象：</p>
<ul>
<li>其本身的地址与其所有基类子对象的地址相同，即基类子对象的地址无偏移。</li>
<li>其各个非静态成员变量的位置按声明顺序从对象地址开始由低到高排列。</li>
<li>其第一个非静态成员变量的地址与对象地址相同。</li>
<li>其各个非静态成员变量的地址均满足对齐要求。</li>
</ul>
<h1 id="POD-Type"><a href="#POD-Type" class="headerlink" title="POD Type"></a>POD Type</h1><p>最后一个概念，POD Type，即Plain Old Data Type，即可导出，可跨语言使用的类型（通常也意味着与C二进制兼容）。</p>
<p>一个POD类型为：</p>
<ul>
<li>标量类型。</li>
<li>满足以下条件的自定义类型：<ul>
<li>C++11之前：<ul>
<li>聚合类型。</li>
<li>没有非POD类型的非静态成员变量。</li>
<li>没有引用类型的非静态成员变量。</li>
<li>没有自定义的构造函数或析构函数。</li>
</ul>
</li>
<li>C++11之后：<ul>
<li>是平凡类。</li>
<li>是标准布局类。</li>
<li>没有非POD类型的非静态成员变量。</li>
</ul>
</li>
</ul>
</li>
<li>POD类型的数组。</li>
</ul>
<p>可以看到POD的标准在C++11前后发生了很大的变化。C++11里放宽了对POD的限制，且根据这些限制的目的，提出了平凡类和标准布局类这两个更清晰的概念。在C++20后POD这个概念本身都会被去掉，而是在不同场合直接使用平凡类、标准布局类等概念。</p>
<p>一个类型可以只是平凡类或只是标准布局类：</p>
<ul>
<li>如果是平凡类，则意味着它可以直接通过<code>memcpy</code>、<code>memset</code>等函数来操作。</li>
<li>如果是标准布局类，则意味着它的布局是确定的，可以与其它语言交互。</li>
</ul>
<p>可以用<code>is_pod</code>来判断一个类型是不是POD类型。</p>
<h1 id="POD的用途"><a href="#POD的用途" class="headerlink" title="POD的用途"></a>POD的用途</h1><p>平凡类的用途：</p>
<ul>
<li>平凡类的对象可以与字节流之间安全转换，即：<ul>
<li>若要将对象转为字节流，直接取其地址即可。</li>
<li>若要将字节流转为对象，直接将该地址cast为对象指针即可。</li>
<li>直接通过复制字节的方式复制对象。</li>
</ul>
</li>
<li>安全的静态初始化。<ul>
<li>C++11的<code>thread_local</code>变量可以是非平凡类型，但在某些编译器下会有比较大的性能开销。gcc扩展的<code>__thread</code>只能使用POD类型。</li>
</ul>
</li>
</ul>
<p>标准布局类的用途：</p>
<ul>
<li>跨进程、跨语言使用。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/11/cpp-object-model-struct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/11/cpp-object-model-struct/" class="post-title-link" itemprop="url">C++对象模型（二）struct/class的内存布局</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-11 15:53:13" itemprop="dateCreated datePublished" datetime="2018-03-11T15:53:13+08:00">2018-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>运行环境：x86-64。</li>
<li>编译器：gcc4.8.5。</li>
<li>编译选项：-O2。</li>
<li>语言标准：以c++98为主，兼顾c++11&#x2F;14。</li>
</ul>
<h1 id="c-中的struct与c中的struct"><a href="#c-中的struct与c中的struct" class="headerlink" title="c++中的struct与c中的struct"></a>c++中的struct与c中的struct</h1><p>第一个问题：c++中的struct与c中的struct相同吗？</p>
<p>答案是，有时相同，有时不同。</p>
<h2 id="像c一样定义struct"><a href="#像c一样定义struct" class="headerlink" title="像c一样定义struct"></a>像c一样定义struct</h2><p>如果我们简单的按照c的方式定义一个struct，如c代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    S ss = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    S s = ss;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;size:%d &amp;a-&amp;s:%d, &amp;b-&amp;s:%d &amp;c-&amp;s:%d\n&quot;</span>,</span><br><span class="line">        <span class="keyword">sizeof</span>(s),</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.a - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.b - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.c - (<span class="type">char</span>*)&amp;s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和c++代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S ss = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    S s = ss;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;size:%d &amp;a-&amp;s:%d, &amp;b-&amp;s:%d &amp;c-&amp;s:%d\n&quot;</span>,</span><br><span class="line">        <span class="built_in">sizeof</span>(s),</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.a - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.b - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.c - (<span class="type">char</span>*)&amp;s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别用gcc和g++编译上面两段代码，结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size:24 &amp;a-&amp;s:0, &amp;b-&amp;s:8 &amp;c-&amp;s:16</span><br><span class="line"></span><br><span class="line">size:24 &amp;a-&amp;s:0, &amp;b-&amp;s:8 &amp;c-&amp;s:16</span><br></pre></td></tr></table></figure>

<p>完全一样对不对？再看下汇编指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">400440:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">400444:   41 b8 10 00 00 00       mov    $0x10,%r8d</span><br><span class="line">40044a:   b9 08 00 00 00          mov    $0x8,%ecx</span><br><span class="line">40044f:   31 d2                   xor    %edx,%edx</span><br><span class="line">400451:   be 18 00 00 00          mov    $0x18,%esi</span><br><span class="line">400456:   bf f0 05 40 00          mov    $0x4005f0,%edi</span><br><span class="line">40045b:   31 c0                   xor    %eax,%eax</span><br><span class="line">40045d:   e8 ae ff ff ff          callq  400410 &lt;printf@plt&gt;</span><br><span class="line">400462:   31 c0                   xor    %eax,%eax</span><br><span class="line">400464:   48 83 c4 08             add    $0x8,%rsp</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">400504:   41 b8 10 00 00 00       mov    $0x10,%r8d</span><br><span class="line">40050a:   b9 08 00 00 00          mov    $0x8,%ecx</span><br><span class="line">40050f:   31 d2                   xor    %edx,%edx</span><br><span class="line">400511:   be 18 00 00 00          mov    $0x18,%esi</span><br><span class="line">400516:   bf b0 06 40 00          mov    $0x4006b0,%edi</span><br><span class="line">40051b:   31 c0                   xor    %eax,%eax</span><br><span class="line">40051d:   e8 ae ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">400522:   31 c0                   xor    %eax,%eax</span><br><span class="line">400524:   48 83 c4 08             add    $0x8,%rsp</span><br></pre></td></tr></table></figure>

<p>是不是也完全一样？当我们在c++里像c一样定义struct时，编译器会给我们一个与c的struct完全相同的结构。</p>
<h2 id="为struct添加静态成员"><a href="#为struct添加静态成员" class="headerlink" title="为struct添加静态成员"></a>为struct添加静态成员</h2><p>我们为<code>S</code>添加一个静态成员变量与静态成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> S::d = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>仍然运行上面的<code>main</code>函数，结果就不贴了，我们会发现与c的struct仍然相同。这说明：</p>
<ol>
<li>静态成员变量不会影响struct布局。换句话说，静态成员变量不存在于对象内部。</li>
<li>静态成员方法也不会影响struct布局，即也不存在于对象内部。</li>
</ol>
<h2 id="为struct添加非静态非虚成员函数"><a href="#为struct添加非静态非虚成员函数" class="headerlink" title="为struct添加非静态非虚成员函数"></a>为struct添加非静态非虚成员函数</h2><h3 id="为struct添加构造、析构、复制、移动函数"><a href="#为struct添加构造、析构、复制、移动函数" class="headerlink" title="为struct添加构造、析构、复制、移动函数"></a>为struct添加构造、析构、复制、移动函数</h3><p>假设我们向<code>S</code>中添加上述函数，上面的结论会有什么变化？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">S</span>(<span class="type">int8_t</span> x, <span class="type">int64_t</span> y, <span class="type">int32_t</span> z) &#123;</span><br><span class="line">        a = x;</span><br><span class="line">        b = y;</span><br><span class="line">        c = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">S</span>() &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">        b = <span class="number">0</span>;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">S</span>(<span class="type">const</span> S&amp; s) &#123;</span><br><span class="line">        a = s.a;</span><br><span class="line">        b = s.b;</span><br><span class="line">        c = s.c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">S</span>(S&amp;&amp; s) &#123;</span><br><span class="line">        a = s.a;</span><br><span class="line">        b = s.b;</span><br><span class="line">        c = s.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行结果没有任何变化，汇编指令也完全相同。这说明struct加上构造函数并没有改变它的布局，即：</p>
<ul>
<li>以上函数均不存在于对象内部。</li>
<li>以上函数均未带来额外开销。</li>
</ul>
<p>但我们不能说这些函数对struct没有任何影响，后面会讲到，当我们添加了这些函数后：</p>
<ul>
<li>这个struct不再满足POD的定义，即不再有bitwise语义。</li>
<li>如果上述函数未被定义为内联（inline）函数，则其会带来额外开销。</li>
</ul>
<h3 id="为struct添加普通非虚函数"><a href="#为struct添加普通非虚函数" class="headerlink" title="为struct添加普通非虚函数"></a>为struct添加普通非虚函数</h3><p>我们比较以下两种写法。写法一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(S* s)</span> </span>&#123;</span><br><span class="line">    s-&gt;a += <span class="number">1</span>;</span><br><span class="line">    s-&gt;b -= <span class="number">1</span>;</span><br><span class="line">    s-&gt;c *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:%d b:%ld c:%d\n&quot;</span>, s-&gt;a, s-&gt;b, s-&gt;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与写法二：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        b -= <span class="number">1</span>;</span><br><span class="line">        c *= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a:%d b:%ld c:%d\n&quot;</span>, a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应的<code>main</code>函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    s.<span class="built_in">Func</span>(); <span class="comment">// or Func(&amp;s);</span></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;size:%d &amp;a-&amp;s:%d, &amp;b-&amp;s:%d &amp;c-&amp;s:%d\n&quot;</span>,</span><br><span class="line">        <span class="built_in">sizeof</span>(s),</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.a - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.b - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.c - (<span class="type">char</span>*)&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法一的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a:2 b:1 c:6</span><br><span class="line">size:24 &amp;a-&amp;s:0, &amp;b-&amp;s:8 &amp;c-&amp;s:16</span><br><span class="line"></span><br><span class="line">  400500:   48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  400504:   48 89 e7                mov    %rsp,%rdi</span><br><span class="line">  400507:   c6 04 24 01             movb   $0x1,(%rsp)</span><br><span class="line">  40050b:   48 c7 44 24 08 02 00    movq   $0x2,0x8(%rsp)</span><br><span class="line">  400512:   00 00</span><br><span class="line">  400514:   c7 44 24 10 03 00 00    movl   $0x3,0x10(%rsp)</span><br><span class="line">  40051b:   00</span><br><span class="line">  40051c:   e8 1f 01 00 00          callq  400640 &lt;_Z4FuncP1S&gt;</span><br><span class="line">  400521:   41 b8 10 00 00 00       mov    $0x10,%r8d</span><br><span class="line">  400527:   b9 08 00 00 00          mov    $0x8,%ecx</span><br><span class="line">  40052c:   31 d2                   xor    %edx,%edx</span><br><span class="line">  40052e:   be 18 00 00 00          mov    $0x18,%esi</span><br><span class="line">  400533:   bf 18 07 40 00          mov    $0x400718,%edi</span><br><span class="line">  400538:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40053a:   e8 91 ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">  40053f:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400541:   48 83 c4 28             add    $0x28,%rsp</span><br></pre></td></tr></table></figure>

<p>写法二的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a:2 b:1 c:6</span><br><span class="line">size:24 &amp;a-&amp;s:0, &amp;b-&amp;s:8 &amp;c-&amp;s:16</span><br><span class="line"></span><br><span class="line">  400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400504:   b9 06 00 00 00          mov    $0x6,%ecx</span><br><span class="line">  400509:   ba 01 00 00 00          mov    $0x1,%edx</span><br><span class="line">  40050e:   be 02 00 00 00          mov    $0x2,%esi</span><br><span class="line">  400513:   bf c0 06 40 00          mov    $0x4006c0,%edi</span><br><span class="line">  400518:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40051a:   e8 b1 ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">  40051f:   41 b8 10 00 00 00       mov    $0x10,%r8d</span><br><span class="line">  400525:   b9 08 00 00 00          mov    $0x8,%ecx</span><br><span class="line">  40052a:   31 d2                   xor    %edx,%edx</span><br><span class="line">  40052c:   be 18 00 00 00          mov    $0x18,%esi</span><br><span class="line">  400531:   bf d8 06 40 00          mov    $0x4006d8,%edi</span><br><span class="line">  400536:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400538:   e8 93 ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">  40053d:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40053f:   48 83 c4 08             add    $0x8,%rsp</span><br></pre></td></tr></table></figure>

<p>对比两种写法的结果，我们发现：</p>
<ul>
<li>成员布局上，两者相同，即普通的非虚成员函数不存在于对象中，不会占用空间。</li>
<li>汇编指令上，第一种写法调用了<code>Func(S*)</code>，而第二种写法完全看不到<code>S::Func</code>，而是直接调用了<code>printf</code>。</li>
</ul>
<p>上面的第二条发现，实际上就是inline的效果。c++标准规定了定义在类（无论是class还是struct）定义中的函数都默认带有inline效果，因此它被编译器直接展开到调用处了。</p>
<p>如果我们给<code>Func(S*)</code>前面加上<code>inline</code>，我们会得到与写法二完全相同的汇编指令（不贴了）。因此结论就是：</p>
<ul>
<li>普通的非虚成员函数不会占用对象空间，也不会带来额外开销，与对应的非成员函数完全相同。</li>
<li><code>Func(S*)</code>等效于<code>S::Func()</code>。</li>
</ul>
<p>针对上面的第二点，实际上<code>S::Func()</code>会被编译器变成一个非成员函数，类似为<code>S_Func(S* const this)</code>，而<code>S::Func() const</code>则对应<code>S_Func(const S* const this)</code>。</p>
<h2 id="为struct添加虚成员函数"><a href="#为struct添加虚成员函数" class="headerlink" title="为struct添加虚成员函数"></a>为struct添加虚成员函数</h2><p>我们将<code>S::Func</code>改为一个虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        b -= <span class="number">1</span>;</span><br><span class="line">        c *= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a:%d b:%ld c:%d\n&quot;</span>, a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应的<code>main</code>函数不变，直接运行会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct.cpp: In function ‘int main()’:</span><br><span class="line">struct.cpp:18:19: error: in C++98 ‘s’ must be initialized by constructor, not by ‘&#123;...&#125;’</span><br><span class="line">     S s = &#123;1, 2, 3&#125;;</span><br><span class="line">                   ^</span><br><span class="line">struct.cpp:18:19: error: could not convert ‘&#123;1, 2, 3&#125;’ from ‘&lt;brace-enclosed initializer list&gt;’ to ‘S’</span><br></pre></td></tr></table></figure>

<p>似乎此时struct与c的struct已经不一样了。我们给它加上一个构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S::<span class="built_in">S</span>(<span class="type">int8_t</span> x, <span class="type">int64_t</span> y, <span class="type">int32_t</span> z) &#123;</span><br><span class="line">    a = x;</span><br><span class="line">    b = y;</span><br><span class="line">    c = z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以编译过了。先运行前面的<code>main</code>函数（构造那行要改），结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:32 &amp;a-&amp;s:8, &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>我们发现：</p>
<ul>
<li>加入虚函数后，对象变大了，说明虚函数占用了一部分对象空间。</li>
<li>对象变大了8字节（实际是虚表指针），且正好在对象的最前面，其它成员变量的位置依次向下8字节。</li>
</ul>
<p>这是第一个与c的struct布局不同的场景。我们知道虚函数是为了实现运行期多态的，那么就需要有信息来帮助程序在运行期根据对象的不同而选择不同的行为，这种信息就会带来运行期的额外开销。</p>
<p>但调用虚函数真的就会有运行期开销吗？我们分别看一下直接通过对象来调用虚函数，与通过指针或引用调用虚函数的区别。</p>
<p>我们添加三个Test函数，并在main函数中调用它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">(S s)</span> </span>&#123;</span><br><span class="line">    s.<span class="built_in">Func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test2</span><span class="params">(S* s)</span> </span>&#123;</span><br><span class="line">    s-&gt;<span class="built_in">Func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test3</span><span class="params">(S&amp; s)</span> </span>&#123;</span><br><span class="line">    s.<span class="built_in">Func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的汇编指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">0000000000400710 &lt;_Z5Test11S&gt;:</span><br><span class="line">  400710:   0f b6 47 08             movzbl 0x8(%rdi),%eax</span><br><span class="line">  400714:   8d 70 01                lea    0x1(%rax),%esi</span><br><span class="line">  400717:   48 8b 47 10             mov    0x10(%rdi),%rax</span><br><span class="line">  40071b:   40 88 77 08             mov    %sil,0x8(%rdi)</span><br><span class="line">  40071f:   40 0f be f6             movsbl %sil,%esi</span><br><span class="line">  400723:   48 8d 50 ff             lea    -0x1(%rax),%rdx</span><br><span class="line">  400727:   8b 47 18                mov    0x18(%rdi),%eax</span><br><span class="line">  40072a:   48 89 57 10             mov    %rdx,0x10(%rdi)</span><br><span class="line">  40072e:   8d 0c 00                lea    (%rax,%rax,1),%ecx</span><br><span class="line">  400731:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400733:   89 4f 18                mov    %ecx,0x18(%rdi)</span><br><span class="line">  400736:   bf 20 08 40 00          mov    $0x400820,%edi</span><br><span class="line">  40073b:   e9 20 fe ff ff          jmpq   400560 &lt;printf@plt&gt;</span><br><span class="line"></span><br><span class="line">0000000000400740 &lt;_Z5Test2P1S&gt;:</span><br><span class="line">  400740:   48 8b 07                mov    (%rdi),%rax</span><br><span class="line">  400743:   48 8b 00                mov    (%rax),%rax</span><br><span class="line">  400746:   ff e0                   jmpq   *%rax</span><br><span class="line">  400748:   0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)</span><br><span class="line">  40074f:   00</span><br><span class="line"></span><br><span class="line">0000000000400750 &lt;_Z5Test3R1S&gt;:</span><br><span class="line">  400750:   48 8b 07                mov    (%rdi),%rax</span><br><span class="line">  400753:   48 8b 00                mov    (%rax),%rax</span><br><span class="line">  400756:   ff e0                   jmpq   *%rax</span><br><span class="line">  400758:   0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)</span><br><span class="line">  40075f:   00</span><br></pre></td></tr></table></figure>

<p>我们发现：</p>
<ul>
<li><code>Test1</code>中<code>Func</code>被展开了，看不到直接的<code>Func</code>调用，这点与调用一个非虚函数的行为相同。</li>
<li><code>Test2</code>中通过间接跳转（jmpq）调用了<code>Func</code>，方法是先取出<code>s</code>（%rdi）的前8字节到%rax，再从%rax取出前8字节放到%rax，这就是<code>Func</code>的地址，之后就是一次间接跳转。</li>
<li><code>Test3</code>与<code>Test2</code>完全相同。</li>
</ul>
<p>结论：</p>
<ul>
<li>通过一个对象调用虚函数时，编译器没有采用运行期多态，而是直接像调用一个非虚函数一样，没有运行期开销。</li>
<li>通过指针调用虚函数时，有运行期开销，即需要一次间接跳转，此时虚函数无法展开。</li>
<li>引用与指针此处无区别，引用就是一种语法糖。</li>
</ul>
<h2 id="为struct添加一个非虚继承的基类"><a href="#为struct添加一个非虚继承的基类" class="headerlink" title="为struct添加一个非虚继承的基类"></a>为struct添加一个非虚继承的基类</h2><h3 id="为struct添加一个无虚函数的非虚继承基类"><a href="#为struct添加一个无虚函数的非虚继承基类" class="headerlink" title="为struct添加一个无虚函数的非虚继承基类"></a>为struct添加一个无虚函数的非虚继承基类</h3><p>我们修改一下<code>S</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行前面的<code>main</code>函数，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:24 &amp;a-&amp;s:4, &amp;b-&amp;s:8 &amp;c-&amp;s:16</span><br></pre></td></tr></table></figure>

<p>此时<code>S</code>的布局可以认为是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> ba;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    Base base;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>两者的区别在于，前者是基类的所有成员都可以被当作子类的成员，而后者是基类子对象就是子类的第一个成员。</p>
<p>到底是哪种呢？当基类为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> ba;</span><br><span class="line">    <span class="type">int8_t</span> bb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时，如果按前者，<code>Base::bb</code>和<code>S::a</code>之间应该没有padding，即此时<code>S</code>的大小仍然是24；如果按后者，<code>Base</code>的alignment为8，此时<code>Base::bb</code>后面会有padding，<code>S</code>的大小应该是32。我们试一下，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:32 &amp;a-&amp;s:8, &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>说明：基类子对象可以被当作子类对象的第一个成员，且保持自己的alignment和padding。</p>
<h3 id="为struct添加第二个非虚基类"><a href="#为struct添加第二个非虚基类" class="headerlink" title="为struct添加第二个非虚基类"></a>为struct添加第二个非虚基类</h3><p>我们再加一个基类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> ba;</span><br><span class="line">    <span class="type">int8_t</span> bb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> ca;</span><br><span class="line">    <span class="type">int8_t</span> cb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> Base, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据上节的结论，我们可以认为<code>Base2</code>也是<code>S</code>的一个成员，且应排列在<code>Base</code>后面，<code>S</code>的大小应该是40。实验结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:40 &amp;a-&amp;s:16, &amp;b-&amp;s:24 &amp;c-&amp;s:32</span><br></pre></td></tr></table></figure>

<p>证实了我们的猜测。</p>
<h3 id="为struct添加空的基类"><a href="#为struct添加空的基类" class="headerlink" title="为struct添加空的基类"></a>为struct添加空的基类</h3><p>所谓空类型，指：</p>
<ul>
<li>没有任何非静态成员变量。</li>
<li>没有任何虚函数。</li>
<li>没有任何虚基类。</li>
<li>其上没有基类，或只有空基类。</li>
</ul>
<p>当我们给<code>S</code>添加一个空类型的基类时，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int64_t</span> b; <span class="comment">// 注意该场景中没有成员a</span></span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据之前的结论，<code>S</code>应该相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    Base base;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们知道，c++中任何类型的size都至少是1，这是为了避免不同变量对应相同的内存地址。那么<code>base</code>的size就是1，<code>S</code>的size就应该是24。实际上呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:16 &amp;b-&amp;s:0 &amp;c-&amp;s:8</span><br></pre></td></tr></table></figure>

<p>居然是16！这就是c++的空基类优化（Empty Base Optimization，EBO），当基类子对象为空时，其不必在子类对象中占据空间，且与子类对象共享相同的地址。这里是一个c的oop无法模拟的点。</p>
<h2 id="为struct添加有虚函数的非虚继承基类"><a href="#为struct添加有虚函数的非虚继承基类" class="headerlink" title="为struct添加有虚函数的非虚继承基类"></a>为struct添加有虚函数的非虚继承基类</h2><h3 id="基类无成员变量"><a href="#基类无成员变量" class="headerlink" title="基类无成员变量"></a>基类无成员变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;Base:%d S:%d &amp;base-&amp;s:%d &amp;a-&amp;s:%d &amp;b-&amp;s:%d &amp;c-&amp;s:%d\n&quot;</span>,</span><br><span class="line">        <span class="built_in">sizeof</span>(Base),</span><br><span class="line">        <span class="built_in">sizeof</span>(S),</span><br><span class="line">        (<span class="type">char</span>*)<span class="built_in">static_cast</span>&lt;Base*&gt;(&amp;s) - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.a - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.b - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.c - (<span class="type">char</span>*)&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:8 S:32 &amp;base-&amp;s:0 &amp;a-&amp;s:8 &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>有虚函数的类型，其对象中需要有1个虚表指针来存放运行期信息，不再是空类型，作为基类也没办法应用EBO。</li>
<li>子类对象中不会有2个虚表指针（基类子对象1个，子类对象1个），而是与基类共用1个虚表指针。</li>
</ul>
<h3 id="基类有成员变量"><a href="#基类有成员变量" class="headerlink" title="基类有成员变量"></a>基类有成员变量</h3><p>假设我们给基类添加一个成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="type">int8_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据前文规则，<code>Base</code>大小为16，其alignment为8，<code>S</code>的大小就会是40，且<code>Base::bb</code>与<code>S::a</code>之间有padding。但运行结果却是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:16 S:32 &amp;base-&amp;s:0 &amp;a-&amp;s:9 &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>与我们的猜测不符，<code>Base::bb</code>与<code>S::a</code>之间没有padding。</p>
<p>后面我们会说到c++有一种标准布局（Standard Layout），这种布局需要与c的struct布局兼容（外加空基类优化）。而当<code>Base</code>或<code>S</code>中加入虚函数后，它们就不再符合标准布局了，编译器就可以应用更紧凑的布局了。</p>
<p>为什么标准布局需要与c的struct布局兼容？因为POD（Plain Old Data）类型首先需要是标准布局类型，而POD类型本身就是为了与c兼容而提出的概念。</p>
<h2 id="为struct添加虚继承基类"><a href="#为struct添加虚继承基类" class="headerlink" title="为struct添加虚继承基类"></a>为struct添加虚继承基类</h2><p>注：大多数c++项目都禁止使用虚继承，因此下面的几个场景我们只给输出和大概的结论，不进行更多的探索和解释了。</p>
<h3 id="基类为空类型"><a href="#基类为空类型" class="headerlink" title="基类为空类型"></a>基类为空类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:1 S:32 &amp;base-&amp;s:0 &amp;a-&amp;s:8 &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>虚基类会在子类中占用额外空间（1个指针），位置在子类最前面，此时无法应用EBO。</li>
</ul>
<h3 id="基类为非空无虚函数类型"><a href="#基类为非空无虚函数类型" class="headerlink" title="基类为非空无虚函数类型"></a>基类为非空无虚函数类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:1 S:32 &amp;base-&amp;s:28 &amp;a-&amp;s:8 &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>子类对象最前面仍然是1个指针。</li>
<li>此时基类子对象位于子类最后。</li>
</ul>
<h3 id="基类为非空有虚函数类型"><a href="#基类为非空有虚函数类型" class="headerlink" title="基类为非空有虚函数类型"></a>基类为非空有虚函数类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="type">int8_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:16 S:48 &amp;base-&amp;s:32 &amp;a-&amp;s:8 &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>此时子类对象的前8字节不再是虚表指针，而是指向虚基类子对象的指针。</li>
<li>基类子对象的前8字节是虚表指针，且其整体位于子类最后一个成员变量的后面。</li>
</ul>
<h3 id="无虚函数的菱形继承"><a href="#无虚函数的菱形继承" class="headerlink" title="无虚函数的菱形继承"></a>无虚函数的菱形继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int32_t</span> ca;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int32_t</span> da;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> C, <span class="keyword">public</span> D &#123;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:1 C:16 D:16 S:48 &amp;Base-&amp;S:44 &amp;C-&amp;S:0 &amp;D-&amp;S:16 &amp;b-&amp;s:32 &amp;c-&amp;s:40</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>此时<code>C</code>的子对象与<code>S</code>对象共享一个虚基类指针，而<code>D</code>则自己使用一个虚基类指针。</li>
<li><code>C</code>与<code>D</code>依次位于<code>S</code>的前端，而<code>Base</code>依然在最后端。</li>
<li>调用来自虚基类的虚函数时，相比非虚基类的虚函数，要多一次间接跳转：先通过虚基类指针找到虚表指针，再通过虚表指针找到对应函数地址。</li>
</ul>
<h3 id="有虚函数的菱形继承"><a href="#有虚函数的菱形继承" class="headerlink" title="有虚函数的菱形继承"></a>有虚函数的菱形继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="type">int8_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int32_t</span> ca;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int32_t</span> da;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> C, <span class="keyword">public</span> D &#123;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:16 C:32 D:32 S:64 &amp;Base-&amp;S:48 &amp;C-&amp;S:0 &amp;D-&amp;S:16 &amp;b-&amp;s:32 &amp;c-&amp;s:40</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li><code>C</code>和<code>D</code>依然位于<code>S</code>的前端，而<code>Base</code>位于后端。</li>
<li><code>C</code>与<code>S</code>共享一个虚基类指针，<code>D</code>自己使用一个虚基类指针。</li>
<li><code>C</code>与<code>D</code>与<code>S</code>与<code>Base</code>共享一个虚表指针。</li>
</ul>
<h1 id="struct与class"><a href="#struct与class" class="headerlink" title="struct与class"></a>struct与class</h1><p>第二个问题，c++中的struct和class有什么区别？</p>
<p>答案是，除了默认访问权限不同（struct默认为public，而class默认为private）外，其它完全相同。</p>
<p>上面的例子中，我们把每个struct都换成class，仍然能得到相同的结论。决定对象模型的不是用哪个关键字修饰它，而是它本身的性质，是否有基类，是否有虚函数，是否有虚基类。</p>
<h2 id="然而struct不能用于修饰模板参数类型"><a href="#然而struct不能用于修饰模板参数类型" class="headerlink" title="然而struct不能用于修饰模板参数类型"></a>然而struct不能用于修饰模板参数类型</h2><p>但struct却不能用于下面这个场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">struct</span> <span class="title class_">X</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">sizeof</span>(X));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们编译时，报错信息为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct.cpp:19:18: error: ‘struct X’ is not a valid type for a template non-type parameter</span><br><span class="line"> template &lt;struct X&gt;</span><br><span class="line">                  ^</span><br></pre></td></tr></table></figure>

<p>而当我们把struct改成class或typename后，就可以编译成功了。</p>
<h1 id="struct的零额外开销"><a href="#struct的零额外开销" class="headerlink" title="struct的零额外开销"></a>struct的零额外开销</h1><p>众所周知，c++的一个核心理念就是保证某个功能对不使用它的用户零额外开销。我们从几方面看一下struct是如何实现零额外开销的。</p>
<h2 id="使用栈上的struct成员"><a href="#使用栈上的struct成员" class="headerlink" title="使用栈上的struct成员"></a>使用栈上的struct成员</h2><p>下面两段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">Func</span><span class="params">(<span class="type">int8_t</span> x, <span class="type">int64_t</span> y, <span class="type">int32_t</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">    a = x;</span><br><span class="line">    b = y;</span><br><span class="line">    c = z;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">Func</span><span class="params">(<span class="type">int8_t</span> x, <span class="type">int64_t</span> y, <span class="type">int32_t</span> z)</span> </span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    s.a = x;</span><br><span class="line">    s.b = y;</span><br><span class="line">    s.c = z;</span><br><span class="line">    <span class="keyword">return</span> s.a + s.b + s.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们对应的汇编指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000004005b0 &lt;_Z4Funcali&gt;:</span><br><span class="line">  4005b0:   48 0f be ff             movsbq %dil,%rdi</span><br><span class="line">  4005b4:   48 63 d2                movslq %edx,%rdx</span><br><span class="line">  4005b7:   48 01 fe                add    %rdi,%rsi</span><br><span class="line">  4005ba:   48 8d 04 16             lea    (%rsi,%rdx,1),%rax</span><br><span class="line">  4005be:   c3                      retq</span><br><span class="line">  4005bf:   90                      nop</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000004005b0 &lt;_Z4Funcali&gt;:</span><br><span class="line">  4005b0:   48 0f be ff             movsbq %dil,%rdi</span><br><span class="line">  4005b4:   48 63 d2                movslq %edx,%rdx</span><br><span class="line">  4005b7:   48 01 fe                add    %rdi,%rsi</span><br><span class="line">  4005ba:   48 8d 04 16             lea    (%rsi,%rdx,1),%rax</span><br><span class="line">  4005be:   c3                      retq</span><br><span class="line">  4005bf:   90                      nop</span><br></pre></td></tr></table></figure>

<p>完全相同，说明使用栈上的struct成员，与使用栈上变量完全相同，零额外开销。</p>
<h2 id="传递小struct"><a href="#传递小struct" class="headerlink" title="传递小struct"></a>传递小struct</h2><p>下面两段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">int32_t</span> x, <span class="type">int32_t</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x:%d y:%d\n&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int32_t</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> x;</span><br><span class="line">    <span class="type">int32_t</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(S s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x:%d y:%d\n&quot;</span>, s.x, s.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    s.x = <span class="number">1</span>;</span><br><span class="line">    s.y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Func</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的汇编指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000400500 &lt;main&gt;:</span><br><span class="line">  400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400504:   ba 02 00 00 00          mov    $0x2,%edx</span><br><span class="line">  400509:   be 01 00 00 00          mov    $0x1,%esi</span><br><span class="line">  40050e:   bf b0 06 40 00          mov    $0x4006b0,%edi</span><br><span class="line">  400513:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400515:   e8 b6 ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">  40051a:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40051c:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  400520:   c3                      retq</span><br><span class="line">  400521:   0f 1f 00                nopl   (%rax)</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000400500 &lt;main&gt;:</span><br><span class="line">  400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400504:   ba 02 00 00 00          mov    $0x2,%edx</span><br><span class="line">  400509:   be 01 00 00 00          mov    $0x1,%esi</span><br><span class="line">  40050e:   bf c0 06 40 00          mov    $0x4006c0,%edi</span><br><span class="line">  400513:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400515:   e8 b6 ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">  40051a:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40051c:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  400520:   c3                      retq</span><br><span class="line">  400521:   0f 1f 00                nopl   (%rax)</span><br></pre></td></tr></table></figure>

<p>注意此时两个<code>Func</code>函数都被inline掉了，因此我们可以直接对应<code>main</code>的汇编代码。可以看到它们完全相同，也符合上节的结论。</p>
<p>当我们把inline关掉后，先看一下<code>main</code>（看参数是如何传递的）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000000000400500 &lt;main&gt;:</span><br><span class="line">  400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400504:   be 02 00 00 00          mov    $0x2,%esi</span><br><span class="line">  400509:   bf 01 00 00 00          mov    $0x1,%edi</span><br><span class="line">  40050e:   e8 fd 00 00 00          callq  400610 &lt;_Z4Funcii&gt;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000000000400500 &lt;main&gt;:</span><br><span class="line">  400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400504:   48 bf 01 00 00 00 02    movabs $0x200000001,%rdi</span><br><span class="line">  40050b:   00 00 00</span><br><span class="line">  40050e:   e8 fd 00 00 00          callq  400610 &lt;_Z4Func1S&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到直接传递一个struct反倒少了一条指令！原因是此时<code>S</code>为8个字节，刚好可以放入一个寄存器中，因此可以一条指令传递过去。而如果分成两个<code>int32_t</code>，则编译器必须用两个寄存器传递，多了一条指令。</p>
<p>再对比一下<code>Func</code>的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0000000000400610 &lt;_Z4Funcii&gt;:</span><br><span class="line">  400610:   89 f2                   mov    %esi,%edx</span><br><span class="line">  400612:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400614:   89 fe                   mov    %edi,%esi</span><br><span class="line">  400616:   bf b0 06 40 00          mov    $0x4006b0,%edi</span><br><span class="line">  40061b:   e9 b0 fe ff ff          jmpq   4004d0 &lt;printf@plt&gt;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0000000000400610 &lt;_Z4FuncS&gt;:</span><br><span class="line">  400610:   48 89 fa                mov    %rdi,%rdx</span><br><span class="line">  400613:   89 fe                   mov    %edi,%esi</span><br><span class="line">  400615:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400617:   48 c1 fa 20             sar    $0x20,%rdx</span><br><span class="line">  40061b:   bf c0 06 40 00          mov    $0x4006c0,%edi</span><br><span class="line">  400620:   e9 ab fe ff ff          jmpq   4004d0 &lt;printf@plt&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到传递<code>S</code>的版本多了一条<code>sar $0x20,%rdx</code>，这是因为我们用一个寄存器传递了两个值，但在调用<code>printf</code>时还是要把它们分开，因此这里需要先把低4字节放到另一个寄存器里，再把%rdx的内容右移32位，从而得到高4字节的值。</p>
<p>把<code>main</code>和<code>Func</code>加起来，两个版本的汇编指令数量仍然完全相同，区别在于前者传递时多一次赋值，后者运算时多一次右移，可以认为开销相同。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/07/cpp-object-model-alignment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/07/cpp-object-model-alignment/" class="post-title-link" itemprop="url">C++对象模型（一）Alignment</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-07 20:31:30" itemprop="dateCreated datePublished" datetime="2018-03-07T20:31:30+08:00">2018-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="word"><a href="#word" class="headerlink" title="word"></a>word</h1><p>第一个概念，word（字）。</p>
<p>word是cpu领域的一个重要概念，它被定义为cpu使用数据的一个自然单位（natural unit），cpu的很多数据长度都与其相关，比如：</p>
<ul>
<li>通常cpu的大多数寄存器长度为一个word。</li>
<li>通常cpu最大寻址空间为一个word（即指针大小通常是一个word）。</li>
<li>总线宽度通常为一个word，即cpu单次读写内存的量通常最大为一个word。</li>
<li>很多cpu每条指令的长度也为一个word。</li>
</ul>
<p>32位&#x2F;64位cpu中的32位和64位就是指它的字长（word-length或word-size）为32位或64位。</p>
<p>这里不详细介绍不同cpu的word的具体含义。我们说一下word对内存读写的影响：</p>
<ul>
<li>早期的cpu通常只能沿着一个word的边界读写数据，如果一次读&#x2F;写操作的目标地址不是字长的整数倍，cpu会报错。</li>
<li>现代的X86 cpu可以在任意地址读写数据，但如果目标地址不是字长的整数倍，底层会将这次操作按word分界分成多个读写操作，对性能有明显影响。</li>
<li>X86-64 cpu可以在任意地址读写数据，且不会有明显的性能影响。</li>
</ul>
<p><img src="http://7xipsa.com1.z0.glb.clouddn.com/alignment.png" alt="alignment"></p>
<p>上图的第一个例子，我们按alignment存放了1个int（4字节数据），cpu只需要一次内存操作就可以完成存取。而第二个例子中，cpu需要两次内存操作来完成int的存取。</p>
<p>现代的cpu通常有多个字长概念（word、1&#x2F;2word、1&#x2F;4word等），针对不同的数据长度，可以有不同的字长。X86和X86-64对长度为1&#x2F;2&#x2F;4&#x2F;8字节的数据，其字长也为1&#x2F;2&#x2F;4&#x2F;8字节。</p>
<h1 id="alignment和padding"><a href="#alignment和padding" class="headerlink" title="alignment和padding"></a>alignment和padding</h1><p>第二个概念，alignment。</p>
<p>考虑到数据不按word边界存放可能引起的问题，编译器在排列变量时，会尽量将其按对应的字长来排列。这种行为就被称为对齐（alignment），而因为alignment导致的数据间产生未使用的空洞，则被称为填充（padding）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int16_t</span> i16;</span><br><span class="line">    <span class="type">int32_t</span> i32;</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c:%ld i16:%ld i32:%ld i64:%ld\n&quot;</span>, &amp;c, &amp;i16, &amp;i32, &amp;i64);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我的环境下（X86-64，gcc4.8.5），输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:140730763468703 i16:140730763468700 i32:140730763468696 i64:140730763468688</span><br></pre></td></tr></table></figure>

<p>可以看到<code>i16</code>与<code>c</code>之间有2字节的padding，<code>i32</code>与<code>i16</code>之间有2字节的padding，<code>i64</code>与<code>i32</code>之间有4字节的padding，实际上是这么排列的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">char</span> padding0[<span class="number">2</span>];</span><br><span class="line"><span class="type">int16_t</span> i16;</span><br><span class="line"><span class="type">char</span> padding1[<span class="number">2</span>];</span><br><span class="line"><span class="type">int32_t</span> i32;</span><br><span class="line"><span class="type">char</span> padding2[<span class="number">4</span>];</span><br><span class="line"><span class="type">int64_t</span> i64;</span><br></pre></td></tr></table></figure>

<h1 id="struct的alignment"><a href="#struct的alignment" class="headerlink" title="struct的alignment"></a>struct的alignment</h1><p>struct的alignment规则很简单：</p>
<ul>
<li>空struct的size与alignment均为1。</li>
<li>非空的struct，其alignment为各成员的alignment的最大值。其最后一个成员后面若有需要，也要padding。</li>
</ul>
<p>注意第2条规则，会导致struct占用的空间比我们预期的更多，例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c0;</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它的自然大小为10B（1+8+1），但考虑到alignment的影响，真实大小却是24B（8+8+8）！</p>
<p>因此<code>S</code>的真实布局为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c0;</span><br><span class="line">    <span class="type">char</span> padding0[<span class="number">7</span>]；</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">char</span> padding1[<span class="number">7</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而当<code>S</code>作为其它struct的成员时，它的size和alignment分别是24和8，会影响到上层struct的alignment。</p>
<p>适当的重新排列<code>S</code>的成员，可以显著减小它的size：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c0;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时它的真实布局为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c0;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">char</span> padding[<span class="number">6</span>];</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>S</code>的size减小到了16B。</p>
<h1 id="与alignment有关的编译器扩展"><a href="#与alignment有关的编译器扩展" class="headerlink" title="与alignment有关的编译器扩展"></a>与alignment有关的编译器扩展</h1><p>这里只介绍gcc的相关扩展。</p>
<p>gcc允许我们用<code>__attribute__</code>来修饰变量，其中用于改变alignment的有以下几种。</p>
<p>注意：修改alignment可能会影响ABI兼容性和可移植性，通常不推荐。</p>
<h2 id="aligned"><a href="#aligned" class="headerlink" title="aligned"></a>aligned</h2><p>语法1：<code>__attribute__ ((aligned (size_in_byte)))</code>，显式指定alignment。注意：指定比默认更小的alignment是无效的，会被编译器忽略。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x __attribute__ ((aligned (<span class="number">16</span>))) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x[<span class="number">2</span>] __attribute__ ((aligned (<span class="number">8</span>)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">R</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; __attribute__ ((aligned (<span class="number">8</span>)));</span><br></pre></td></tr></table></figure>

<p>语法2：<code>__attribute__ ((aligned))</code>，让编译器选择可能的最大alignment，对64位环境而言通常是8。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">R</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; __attribute__ ((aligned));</span><br></pre></td></tr></table></figure>

<h2 id="packed"><a href="#packed" class="headerlink" title="packed"></a>packed</h2><p>语法：<code>__attribute__ ((packed))</code>，表示该变量或struct选择可能的最小alignment，对64位环境而言通常是1。</p>
<p>下面这个struct，加上<code>packed</code>后其大小变为10，与其自然大小相等：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c0;</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p>编译时如果加上<code>-fpack-struct</code>，则默认所有变量和struct都会按<code>packed</code>处理。</p>
<p>如果加上<code>-Wpadded</code>，则编译器增加padding的地方会有warning。注意只包含struct场景。</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a target="_blank" rel="noopener" href="https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-paper.pdf">Alignment in C</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Word_(computer_architecture)">Wiki - Word</a></li>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html">Specifying Attributes of Variables</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/05/high-concurrency-work/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/05/high-concurrency-work/" class="post-title-link" itemprop="url">高并发工作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-05 13:56:37" itemprop="dateCreated datePublished" datetime="2018-03-05T13:56:37+08:00">2018-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大体来讲，我们每个人头上都不会只有一项工作，很可能在某阶段，头上会有N项工作。我们当然希望这些工作能按部就班的、一项一项的顺序完成。但现实是残酷的，总有些工作会depend其它人，而不得不暂停下来；也总有些工作每天都有人催，需要尽快完成。所以，结论就是每个人都需要高并发工作，也需要知道怎么实现高并发工作。</p>
<p>有种观点是，编程中的所有概念都是人类活动的延续，反映了人类自己的思维方式与组织架构。这句话反过来说也不无道理，即人类的思维方式与组织架构，往往可以从编程中找到对应的概念。</p>
<p>某种程度上，实现高并发工作的方法与实现高并发编程是类似的。本文就参照高并发编程的一些要素，来分析一下如何达到高并发工作。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/03/05/high-concurrency-work/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/01/30/future-promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/30/future-promise/" class="post-title-link" itemprop="url">Future与Promise</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-30 11:55:30" itemprop="dateCreated datePublished" datetime="2018-01-30T11:55:30+08:00">2018-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Future和Promise</p>
<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p>有没有某个时刻，你觉得你的程序可以分成多个部分，其中一些部分不需要等待其它部分运行结束？比如当程序发出一个http请求后，在它返回之前，程序似乎还可以做点别的事情；比如当程序在等待一个请求的response的序列化完成时，似乎它可以做下个请求的参数检查了。这时候，你就需要了解异步编程了。</p>
<p>当程序分成多部分，这些部分之间的消息通信就成了一件很重要的事情。通常我们将消息通信分成同步和异步两种，其中同步就是消息的发送方要等待消息返回才能继续处理其它事情，而异步就是消息的发送方不需要等待消息返回就可以处理其它事情。很显然异步允许我们同时做更多事情，往往也能获得更高的性能。尤其对于JavaScript这种通常是单线程环境的语言，更需要将长延时的阻塞操作异步化来保证其它操作的顺利进行。</p>
<p>异步编程的核心问题是如何处理通信：要么有办法知道通信有没有完成，要么能保证在通信完成后执行一段特定的逻辑。前者就是通知机制，比如信号量、条件变量等；后者就是callback，即回调。</p>
<h2 id="回调噩梦"><a href="#回调噩梦" class="headerlink" title="回调噩梦"></a>回调噩梦</h2><p>当一项任务需要分成多个异步阶段完成时，就需要在每个阶段的回调函数中加入下阶段回调的代码，最终产生下面这样金字塔形状的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">getData = <span class="keyword">function</span>(<span class="params">param, callback</span>)&#123;</span><br><span class="line">  $.<span class="title function_">get</span>(<span class="string">&#x27;http://example.com/get/&#x27;</span>+param,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">responseText</span>)&#123;</span><br><span class="line">      <span class="title function_">callback</span>(responseText);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getData</span>(<span class="number">0</span>, <span class="keyword">function</span>(<span class="params">a</span>)&#123;</span><br><span class="line">  <span class="title function_">getData</span>(a, <span class="keyword">function</span>(<span class="params">b</span>)&#123;</span><br><span class="line">    <span class="title function_">getData</span>(b, <span class="keyword">function</span>(<span class="params">c</span>)&#123;</span><br><span class="line">      <span class="title function_">getData</span>(c, <span class="keyword">function</span>(<span class="params">d</span>)&#123;</span><br><span class="line">        <span class="title function_">getData</span>(d, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以想象当回调层次继续增加时，代码有多恐怖。这就是回调噩梦。</p>
<h1 id="Future和Promise"><a href="#Future和Promise" class="headerlink" title="Future和Promise"></a>Future和Promise</h1><p>Future指一个<strong>只读</strong>的值的容器，这个值可能立即可用，也可能在未来某个时间可用。而Promise则是一个只能写入一次的对象。每个Promise关联一个Future，对Promise的写入会令Future的值可用。我们只讨论Promise和Future一对一的场景，在这个场景中Future就是值，而Promise是产生值的方法。</p>
<p>Future和Promise来源于函数式语言，其目的是分离一个值和产生值的方法，从而简化异步代码的处理。</p>
<h2 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h2><p>Future与Promise配合起来可以实现一种可靠的通知机制，即我们可以异步执行一个方法，通过返回的Future来知道异步方法何时结束、是否成功、返回值是什么。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SyncOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">    <span class="built_in">RunAsync</span>(std::<span class="built_in">bind</span>(AsyncFunc, promise));</span><br><span class="line">    Future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">GetFuture</span>();</span><br><span class="line">    <span class="type">int</span> result = future.<span class="built_in">Get</span>(); <span class="comment">// wait until future is done</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收方</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncFunc</span><span class="params">(Promise&lt;<span class="type">int</span>&gt; promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    promise.<span class="built_in">Done</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式回调"><a href="#链式回调" class="headerlink" title="链式回调"></a>链式回调</h2><p>Promise的一个重要特性就是它支持<code>then</code>，可以将金字塔式的回调组织为链式，极大地降低了理解和维护的难度：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getData = <span class="keyword">function</span>(<span class="params">param, callback</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    $.<span class="title function_">get</span>(<span class="string">&#x27;http://example.com/get/&#x27;</span>+param,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">responseText</span>)&#123;</span><br><span class="line">      <span class="title function_">resolve</span>(responseText);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getData</span>(<span class="number">0</span>).<span class="title function_">then</span>(getData)</span><br><span class="line">  .<span class="title function_">then</span>(getData)</span><br><span class="line">  .<span class="title function_">then</span>(getData)</span><br><span class="line">  .<span class="title function_">then</span>(getData);</span><br></pre></td></tr></table></figure>

<h2 id="Async和Await"><a href="#Async和Await" class="headerlink" title="Async和Await"></a>Async和Await</h2><p>C#在5.0之后支持了<code>async</code>和<code>await</code>关键字，允许写出这样的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">AccessTheWebAsync</span>()</span>  </span><br><span class="line">&#123;   </span><br><span class="line">    HttpClient client = <span class="keyword">new</span> HttpClient();  </span><br><span class="line">    Task&lt;<span class="built_in">string</span>&gt; getStringTask = client.GetStringAsync(<span class="string">&quot;http://msdn.microsoft.com&quot;</span>);  </span><br><span class="line">    DoIndependentWork();  </span><br><span class="line">    <span class="built_in">string</span> urlContents = <span class="keyword">await</span> getStringTask;  </span><br><span class="line">    <span class="keyword">return</span> urlContents.Length;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> urlContents = <span class="keyword">await</span> client.GetStringAsync();</span><br></pre></td></tr></table></figure>

<p>其中<code>async</code>要求函数必须返回<code>Task</code>或<code>Task&lt;T&gt;</code>，这里的<code>Task</code>可以理解为一种Future。用<code>async</code>修饰函数表明这是个可异步执行的函数，而用<code>await</code>会等待Future结束，返回Future的值，将异步又转成了同步。</p>
<p>上面js的例子用<code>await</code>来实现就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">getData = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">param, callback</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    $.<span class="title function_">get</span>(<span class="string">&#x27;http://example.com/get/&#x27;</span>+param,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">responseText</span>)&#123;</span><br><span class="line">      <span class="title function_">resolve</span>(responseText);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">await</span> <span class="title function_">getData</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> data1 = <span class="keyword">await</span> <span class="title function_">getData</span>(data);</span><br><span class="line"><span class="keyword">var</span> data2 = <span class="keyword">await</span> <span class="title function_">getData</span>(data1);</span><br><span class="line"><span class="keyword">var</span> data3 = <span class="keyword">await</span> <span class="title function_">getData</span>(data2);</span><br><span class="line"><span class="keyword">var</span> data4 = <span class="keyword">await</span> <span class="title function_">getData</span>(data3);</span><br></pre></td></tr></table></figure>

<p>这种写法要比Promise链更接近同步，也更易懂，但其底层依然是Promise。这种写法很接近于协程：用Promise来实现yield和resume，它就是一种协程。</p>
<h2 id="不同语言中的Future和Promise"><a href="#不同语言中的Future和Promise" class="headerlink" title="不同语言中的Future和Promise"></a>不同语言中的Future和Promise</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>C++11中增加了<code>std::future</code>和<code>std::promise</code>，基本是按照Future只读、Promise只写来设计的。它的缺点是：</p>
<ol>
<li>其实现绑定了<code>std::thread</code>，很难扩展到其它执行器上。</li>
<li>Promise不支持链式回调。</li>
</ol>
<h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h3><p>C#的<code>Task</code>就类似于Future，它的<code>async</code>和<code>await</code>也很方便。</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>Java之前就有<code>Future</code>，类似于C++11的<code>std::promise</code>，没有链式回调能力。Java8中增加了<code>CompletableFuture</code>，可以认为是一个完全的Promise了。</p>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>ES6开始，JavaScript增加了Promise、async、await等特性，极大改善了JS代码中维护回调难的问题。</p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Python3.5之后增加了对<code>async</code>和<code>await</code>的支持。</p>
<h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><p>Scala中的<code>Future</code>与<code>Promise</code>完全符合上面的介绍，它的一个特点是一个<code>Future</code>可以增加多个回调，但不保证这些回调的执行顺序。</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Futures_and_promises">Futures and promises</a></li>
<li><a target="_blank" rel="noopener" href="http://dist-prog-book.com/chapter/2/futures.html">Futures and Promises</a></li>
<li><a target="_blank" rel="noopener" href="http://ifeve.com/promise-future-callback/">并发编程 Promise, Future 和 Callback</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.coding.net/blog/how-do-promises-work">理解 Promise 的工作原理</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.scala-lang.org/overviews/core/futures.html">Scala: FUTURES AND PROMISES</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8">Understand promises before you start using async&#x2F;await</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Await">Await</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/index">Asynchronous programming with async and await (C#)</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>


        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fu Zhe"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Fu Zhe</p>
  <div class="site-description" itemprop="description">High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">134</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">81</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fu Zhe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v6.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
