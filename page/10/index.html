<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://fuzhe1989.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="High-Flyer AIPingCAPGoogleAlibaba CloudHarbin Institute of Technology">
<meta property="og:type" content="website">
<meta property="og:title" content="Fu Zhe&#39;s Blog">
<meta property="og:url" content="http://fuzhe1989.github.io/page/10/index.html">
<meta property="og:site_name" content="Fu Zhe&#39;s Blog">
<meta property="og:description" content="High-Flyer AIPingCAPGoogleAlibaba CloudHarbin Institute of Technology">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fu Zhe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://fuzhe1989.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Fu Zhe's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4HC396822H"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-4HC396822H');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?df45b34764dad306c840c8f1da5faf14";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Fu Zhe's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fu Zhe's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/17/redis-on-the-respberry-pi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/17/redis-on-the-respberry-pi/" class="post-title-link" itemprop="url">[翻译] Redis on the Raspberry Pi: adventures in unaligned lands</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-17 15:05:18" itemprop="dateCreated datePublished" datetime="2018-03-17T15:05:18+08:00">2018-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="http://antirez.com/news/111">原文地址</a></p>
<p>在售出1000万台设备，实际上是诸如传感器和显示器这样无数不同的应用和辅助设备后，可以说树莓派不仅仅是取得了成功，它还成为了一种程序员最喜爱的嵌入式实验平台。像是Pi zero这样的产品也在成为创造硬件产品的平台，且不会引入设计、构建、为车载设备写软件等方面的风险和开销。</p>
<p>同样地，我也认同Redis是一个程序员乐于去冒险、实验、构建新事物的平台。而且，能用于嵌入式&#x2F;物联网应用的设备，通常会有暂时或长期存储数据的需求，像是从传感器接收到的数据，需要在这台设备上运算的数据，或是要发往远程服务器的数据。Redis正在加入一种Stream数据类型，非常适合流式数据和时间序列存储，撰写本文时（2017年初）这个特性快要完成了，后续工作会在接下来几周内开始。Redis现存的数据结构，以及新增的Stream类型，以及它较小的内存使用，以及它即使在小型硬件（低功耗）上也能提供相当不错的性能，都让Redis看起来非常适合应用在树莓派，进而是其它小型ARM设备上。中间缺失的部分也很明显：在树莓派上把Redis跑起来。</p>
<p>树莓派的一个很酷的特点就是，它的开发环境不像过去的嵌入式系统那样，它上面跑的就是正常的Linux，还包括各种Debian系的工具。简单地说在树莓派上适配Redis不算很困难。Linux程序移植到树莓派上最常见的问题就是性能或内存占用不匹配，但在Redis上这不是问题，因为它本身就被设计为：空实例只占用1MB内存，且查询请求会走内存，因此它足够快，也不会给闪存太高的压力，而且在需要持久化时，它只会用AOF（Append Only File）。但树莓派上用的是ARM处理器，意味着我们要小心处理未对齐的内存访问。</p>
<p>本文会展示我为了让Redis能愉快地跑在树莓派上都做了什么，我会试着给出一个如何应对那些不能透明地处理非对齐内存访问的平台上（不像x86）的概述。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/03/17/redis-on-the-respberry-pi/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/15/cpp-object-model-pod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/15/cpp-object-model-pod/" class="post-title-link" itemprop="url">C++对象模型（三）POD</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-15 18:37:59" itemprop="dateCreated datePublished" datetime="2018-03-15T18:37:59+08:00">2018-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>注：本节不讨论<code>union</code>。</p>
<h1 id="Scalar-Type"><a href="#Scalar-Type" class="headerlink" title="Scalar Type"></a>Scalar Type</h1><p>第一个概念，Scalar Type，即标量类型。</p>
<p>所谓标量，就是一个数字，而标量类型，就是可以表示为一个数字的类型。</p>
<p>C++的标量类型为：</p>
<ul>
<li>各种整数&#x2F;浮点类型，如<code>int8_t</code>、<code>uint32_t</code>、<code>char</code>、<code>float</code>等，可满足<code>std::is_arithmetic&lt;T&gt;</code>为true。</li>
<li>枚举类型，可满足<code>std::is_enum&lt;T&gt;</code>为true。</li>
<li>各种指针类型，包括<code>std::nullptr_t</code>，可满足<code>std::is_pointer&lt;T&gt;</code>或<code>std::is_member_pointer&lt;T&gt;</code>为true。</li>
</ul>
<p>以上类型都属于标量类型，都可满足<code>std::is_scalar&lt;T&gt;::value</code>为true。</p>
<h1 id="Aggregate-Type"><a href="#Aggregate-Type" class="headerlink" title="Aggregate Type"></a>Aggregate Type</h1><p>第二个概念，Aggregate Type，即聚合类型。</p>
<p>所谓聚合类型，就是可以使用<code>= &#123;v1, v2, v3&#125;</code>这样语法（注意不是C++11的<code>std::initializer_list</code>特性）进行初始化或赋值的类型，对应C的数组和struct。</p>
<p>C++的聚合类型为：</p>
<ul>
<li>所有数组类型。</li>
<li>满足以下条件的类（包括<code>class</code>、<code>struct</code>）：<ul>
<li>所有非静态成员变量的访问权限都是<code>public</code>。</li>
<li>没有用户自定义的构造函数（但允许使用<code>= default</code>来显式使用编译器合成的构造函数，或使用<code>= delete</code>来显式禁止某种构造函数）。</li>
<li>没有基类（C++17后允许有<code>public</code>的非虚基类）。</li>
<li>没有虚函数。</li>
<li>成员变量没有默认初始化式（不在构造函数里那种）（C++11新增，但似乎C++14又去掉了此限制）。</li>
</ul>
</li>
</ul>
<p>根据上面的定义，聚合类型还有下面的几个特点：</p>
<ul>
<li>不要求其所有非静态成员变量均为聚合类型。</li>
<li>对静态成员没有任何限制。</li>
<li>只对构造函数有限制，对析构函数、赋值函数等无限制。</li>
<li>非聚合类型的数组也是聚合类型。</li>
</ul>
<p>当我们写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type a[m] = &#123;b0, b1, ..., bn-1&#125;;</span><br></pre></td></tr></table></figure>

<p>时：</p>
<ul>
<li>若m &#x3D;&#x3D; n，则会发生b0到a[0]、b1到a[1]等等n次复制初始化。</li>
<li>若m &lt; n，则报错。</li>
<li>若m &gt; n，则a[0]-a[n-1]发生复制初始化，而a[n]-a[m-1]则发生默认初始化。</li>
<li>若m为空，则a的长度会被设定为n，同样发生n次复制初始化。</li>
</ul>
<p>对于下面的聚合类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    TypeA a;</span><br><span class="line">    TypeB b;</span><br><span class="line">    TypeC c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S s = &#123;a<span class="number">&#x27;</span>, b<span class="number">&#x27;</span>, c<span class="number">&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>时：</p>
<ul>
<li>若<code>&#123;&#125;</code>内元素数量与<code>S</code>中非静态成员变量数量相等，会按a’-&gt;a、b’-&gt;b、c’-&gt;c的方式进行复制初始化。</li>
<li>若<code>&#123;&#125;</code>内元素数量更多，则报错。</li>
<li>若<code>S</code>中非静态成员变量数量更多，则后面的成员发生默认初始化。</li>
</ul>
<p>在初始化时：</p>
<ul>
<li>若发生复制初始化，则会调用相应类型的复制构造函数或赋值函数。</li>
<li>若列表中某项为表达式，则复制&#x2F;赋值时允许发生隐式转换（C++11开始要求不能是narrow转换）。</li>
<li>若列表中某项本身也是个<code>&#123;&#125;</code>列表，则要求对应的数组元素&#x2F;非静态成员变量也是聚合类型，尝试递归聚合赋值。</li>
<li>标量类型的默认初始化会将其初始化为0、0.0、false等。</li>
<li>引用类型的默认初始化会报错。</li>
</ul>
<p>在对聚合类型（非数组）做列表赋值时，我们还可以指定成员的名字，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a = &#123;.x = <span class="number">1</span>, .z = <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>它有以下特点：</p>
<ul>
<li>列表中名字顺序必须符合成员顺序，即<code>&#123;.z = 2, .x = 1&#125;</code>是不行的。（注意，<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/c/language/struct_initialization">C允许乱序，还允许其它多种初始化方式</a>，但C++不允许）</li>
<li>列表中元素数量可以少于成员数量，未在列表中出现的成员发生默认初始化，即上例中<code>a.y</code>为0。</li>
</ul>
<h1 id="Trivial-Type"><a href="#Trivial-Type" class="headerlink" title="Trivial Type"></a>Trivial Type</h1><p>第三个概念，Trivial Type，即平凡类型。</p>
<p>所谓平凡类型，可以认为是有bitwise语义的类型，即可以直接按字节复制的类型。C中的所有类型都是Trivial Type。</p>
<p>Trivial Type有两个标准：</p>
<ul>
<li>能trivial静态构造，即要有一个trivial的默认构造函数。</li>
<li>能trivial拷贝，即满足Trivial Copyable标准。</li>
</ul>
<p>Trivial Copyable类型即是满足<code>std::is_trivially_copyable&lt;T&gt;::value</code>为true的类型，它要求：</p>
<ul>
<li>所有复制构造、赋值函数要么是trivial的，要么是deleted。</li>
<li>所有移动构造、赋值函数要么是trivial的，要么是deleted。</li>
<li>至少有一个非deleted复制或移动的构造或赋值函数。</li>
<li>析构函数为trivial，且非deleted。</li>
</ul>
<p>构造函数、析构函数、复制构造&#x2F;赋值函数、移动构造&#x2F;赋值函数的trivial是指：</p>
<ul>
<li>满足bitwise语义。</li>
<li>要么是编译器隐式合成的版本。</li>
<li>要么通过<code>= default</code>显式使用编译器的合成版本。</li>
</ul>
<p>以上条件也就意味着一个Trivial Type：</p>
<ul>
<li>不能有虚函数（会导致构造函数等失去bitwise语义）。</li>
<li>不能有虚基类（同上）。</li>
<li>如果有基类，基类也要是Trivial Type。</li>
<li>不能有自定义的构造、析构、复制、移动函数。</li>
<li>不能有非Trivial Type类型的非静态成员变量。</li>
</ul>
<p>标量类型、Trivial Type的数组也是Trivial Type。</p>
<p>Trivial Type是用来区分那些可以像C一样通过<code>memset</code>、<code>memcpy</code>等函数直接构造和复制的类型，C++11中增加了<code>std::is_trivial</code>模板来判断一个类型是否是trivial的。</p>
<p>注意，Trivial Type还有以下特点：</p>
<ul>
<li>不限制成员变量的访问限制，即<code>public</code>、<code>protected</code>、<code>private</code>都可以。</li>
<li>只要求默认构造函数是trivial的，对其它构造函数没有要求。</li>
</ul>
<h1 id="Standard-Layout-Type"><a href="#Standard-Layout-Type" class="headerlink" title="Standard Layout Type"></a>Standard Layout Type</h1><p>第四个概念，Standard Layout Type，即标准布局类型。</p>
<p>标准布局的目的是定义一种与C兼容的内存布局，满足标准布局的类型即为标准布局类型，Standard Layout Type。</p>
<p>关于不同C++类型的内存布局，可以见上一篇文章<a href="/2018/03/11/cpp-object-model-struct/">C++对象模型（二）struct&#x2F;class的内存布局</a>。</p>
<p>C++的Standard Layout Type要求：</p>
<ul>
<li><p>所有非静态成员变量有着相同的访问权限。</p>
</li>
<li><p>没有虚函数或虚基类。</p>
</li>
<li><p>没有引用类型的非静态成员变量。</p>
</li>
<li><p>所有基类和非静态成员变量本身也是Standard Layout Type。</p>
</li>
<li><p>该类型与其所有基类中，最多只能有一个类型有非静态成员变量（其它类型都需要是空类型），即所有非静态成员变量都在一个类型中。</p>
</li>
<li><p>第一个非静态成员变量（包括继承自基类的成员）其类型不能与任一空基类相同（影响空基类优化）。</p>
</li>
<li><p>该类型的继承树中同一类型不能出现多次。</p>
<p>  例子：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Q</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: Q &#123;&#125;；</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span>: Q &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">U</span>: S, T &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>  <code>U</code>的继承树中<code>Q</code>出现了两次，则<code>Q</code>、<code>S</code>、<code>T</code>都是Standard Layout Type，但<code>U</code>不是。</p>
</li>
</ul>
<p>相同访问权限的原因：标准只规定了同一个section内成员的顺序，未规定不同section之间的顺序，因此若非静态成员变量分布在不同section下，无法给出一个确定的布局。</p>
<p>所有非静态成员变量都在一个类型中的原因：标准未规定基类子对象的位置，因此不同基类、或基类与子类的非静态成员变量间的顺序是未定义的。</p>
<p>没有虚函数或虚基类的原因：虚函数和虚基类会影响类的内存布局，但标准未规定其实现方式，因此有虚函数或虚基类的类型无法给出一个确定的布局。</p>
<p>第一个非静态成员变量不能与空基类类型相同的原因：标准规定同时存在的两个变量不能有相同地址，若应用空基类优化，则第一个非静态成员变量的地址与对象地址相同，也与所有空基类地址相同，若其中有相同类型，则导致该地址同时对应了多个变量。</p>
<p>C++11新增了<code>std::is_standard_layout</code>来判断一个类型是不是Standard Layout Type。</p>
<h2 id="标准布局"><a href="#标准布局" class="headerlink" title="标准布局"></a>标准布局</h2><p>C++的标准布局实际就是C中struct的布局，对于一个标准布局类的对象：</p>
<ul>
<li>其本身的地址与其所有基类子对象的地址相同，即基类子对象的地址无偏移。</li>
<li>其各个非静态成员变量的位置按声明顺序从对象地址开始由低到高排列。</li>
<li>其第一个非静态成员变量的地址与对象地址相同。</li>
<li>其各个非静态成员变量的地址均满足对齐要求。</li>
</ul>
<h1 id="POD-Type"><a href="#POD-Type" class="headerlink" title="POD Type"></a>POD Type</h1><p>最后一个概念，POD Type，即Plain Old Data Type，即可导出，可跨语言使用的类型（通常也意味着与C二进制兼容）。</p>
<p>一个POD类型为：</p>
<ul>
<li>标量类型。</li>
<li>满足以下条件的自定义类型：<ul>
<li>C++11之前：<ul>
<li>聚合类型。</li>
<li>没有非POD类型的非静态成员变量。</li>
<li>没有引用类型的非静态成员变量。</li>
<li>没有自定义的构造函数或析构函数。</li>
</ul>
</li>
<li>C++11之后：<ul>
<li>是平凡类。</li>
<li>是标准布局类。</li>
<li>没有非POD类型的非静态成员变量。</li>
</ul>
</li>
</ul>
</li>
<li>POD类型的数组。</li>
</ul>
<p>可以看到POD的标准在C++11前后发生了很大的变化。C++11里放宽了对POD的限制，且根据这些限制的目的，提出了平凡类和标准布局类这两个更清晰的概念。在C++20后POD这个概念本身都会被去掉，而是在不同场合直接使用平凡类、标准布局类等概念。</p>
<p>一个类型可以只是平凡类或只是标准布局类：</p>
<ul>
<li>如果是平凡类，则意味着它可以直接通过<code>memcpy</code>、<code>memset</code>等函数来操作。</li>
<li>如果是标准布局类，则意味着它的布局是确定的，可以与其它语言交互。</li>
</ul>
<p>可以用<code>is_pod</code>来判断一个类型是不是POD类型。</p>
<h1 id="POD的用途"><a href="#POD的用途" class="headerlink" title="POD的用途"></a>POD的用途</h1><p>平凡类的用途：</p>
<ul>
<li>平凡类的对象可以与字节流之间安全转换，即：<ul>
<li>若要将对象转为字节流，直接取其地址即可。</li>
<li>若要将字节流转为对象，直接将该地址cast为对象指针即可。</li>
<li>直接通过复制字节的方式复制对象。</li>
</ul>
</li>
<li>安全的静态初始化。<ul>
<li>C++11的<code>thread_local</code>变量可以是非平凡类型，但在某些编译器下会有比较大的性能开销。gcc扩展的<code>__thread</code>只能使用POD类型。</li>
</ul>
</li>
</ul>
<p>标准布局类的用途：</p>
<ul>
<li>跨进程、跨语言使用。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/11/cpp-object-model-struct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/11/cpp-object-model-struct/" class="post-title-link" itemprop="url">C++对象模型（二）struct/class的内存布局</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-11 15:53:13" itemprop="dateCreated datePublished" datetime="2018-03-11T15:53:13+08:00">2018-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>运行环境：x86-64。</li>
<li>编译器：gcc4.8.5。</li>
<li>编译选项：-O2。</li>
<li>语言标准：以c++98为主，兼顾c++11&#x2F;14。</li>
</ul>
<h1 id="c-中的struct与c中的struct"><a href="#c-中的struct与c中的struct" class="headerlink" title="c++中的struct与c中的struct"></a>c++中的struct与c中的struct</h1><p>第一个问题：c++中的struct与c中的struct相同吗？</p>
<p>答案是，有时相同，有时不同。</p>
<h2 id="像c一样定义struct"><a href="#像c一样定义struct" class="headerlink" title="像c一样定义struct"></a>像c一样定义struct</h2><p>如果我们简单的按照c的方式定义一个struct，如c代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    S ss = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    S s = ss;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;size:%d &amp;a-&amp;s:%d, &amp;b-&amp;s:%d &amp;c-&amp;s:%d\n&quot;</span>,</span><br><span class="line">        <span class="keyword">sizeof</span>(s),</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.a - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.b - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.c - (<span class="type">char</span>*)&amp;s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和c++代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S ss = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    S s = ss;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;size:%d &amp;a-&amp;s:%d, &amp;b-&amp;s:%d &amp;c-&amp;s:%d\n&quot;</span>,</span><br><span class="line">        <span class="built_in">sizeof</span>(s),</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.a - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.b - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.c - (<span class="type">char</span>*)&amp;s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别用gcc和g++编译上面两段代码，结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size:24 &amp;a-&amp;s:0, &amp;b-&amp;s:8 &amp;c-&amp;s:16</span><br><span class="line"></span><br><span class="line">size:24 &amp;a-&amp;s:0, &amp;b-&amp;s:8 &amp;c-&amp;s:16</span><br></pre></td></tr></table></figure>

<p>完全一样对不对？再看下汇编指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">400440:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">400444:   41 b8 10 00 00 00       mov    $0x10,%r8d</span><br><span class="line">40044a:   b9 08 00 00 00          mov    $0x8,%ecx</span><br><span class="line">40044f:   31 d2                   xor    %edx,%edx</span><br><span class="line">400451:   be 18 00 00 00          mov    $0x18,%esi</span><br><span class="line">400456:   bf f0 05 40 00          mov    $0x4005f0,%edi</span><br><span class="line">40045b:   31 c0                   xor    %eax,%eax</span><br><span class="line">40045d:   e8 ae ff ff ff          callq  400410 &lt;printf@plt&gt;</span><br><span class="line">400462:   31 c0                   xor    %eax,%eax</span><br><span class="line">400464:   48 83 c4 08             add    $0x8,%rsp</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">400504:   41 b8 10 00 00 00       mov    $0x10,%r8d</span><br><span class="line">40050a:   b9 08 00 00 00          mov    $0x8,%ecx</span><br><span class="line">40050f:   31 d2                   xor    %edx,%edx</span><br><span class="line">400511:   be 18 00 00 00          mov    $0x18,%esi</span><br><span class="line">400516:   bf b0 06 40 00          mov    $0x4006b0,%edi</span><br><span class="line">40051b:   31 c0                   xor    %eax,%eax</span><br><span class="line">40051d:   e8 ae ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">400522:   31 c0                   xor    %eax,%eax</span><br><span class="line">400524:   48 83 c4 08             add    $0x8,%rsp</span><br></pre></td></tr></table></figure>

<p>是不是也完全一样？当我们在c++里像c一样定义struct时，编译器会给我们一个与c的struct完全相同的结构。</p>
<h2 id="为struct添加静态成员"><a href="#为struct添加静态成员" class="headerlink" title="为struct添加静态成员"></a>为struct添加静态成员</h2><p>我们为<code>S</code>添加一个静态成员变量与静态成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> S::d = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>仍然运行上面的<code>main</code>函数，结果就不贴了，我们会发现与c的struct仍然相同。这说明：</p>
<ol>
<li>静态成员变量不会影响struct布局。换句话说，静态成员变量不存在于对象内部。</li>
<li>静态成员方法也不会影响struct布局，即也不存在于对象内部。</li>
</ol>
<h2 id="为struct添加非静态非虚成员函数"><a href="#为struct添加非静态非虚成员函数" class="headerlink" title="为struct添加非静态非虚成员函数"></a>为struct添加非静态非虚成员函数</h2><h3 id="为struct添加构造、析构、复制、移动函数"><a href="#为struct添加构造、析构、复制、移动函数" class="headerlink" title="为struct添加构造、析构、复制、移动函数"></a>为struct添加构造、析构、复制、移动函数</h3><p>假设我们向<code>S</code>中添加上述函数，上面的结论会有什么变化？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">S</span>(<span class="type">int8_t</span> x, <span class="type">int64_t</span> y, <span class="type">int32_t</span> z) &#123;</span><br><span class="line">        a = x;</span><br><span class="line">        b = y;</span><br><span class="line">        c = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">S</span>() &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">        b = <span class="number">0</span>;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">S</span>(<span class="type">const</span> S&amp; s) &#123;</span><br><span class="line">        a = s.a;</span><br><span class="line">        b = s.b;</span><br><span class="line">        c = s.c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">S</span>(S&amp;&amp; s) &#123;</span><br><span class="line">        a = s.a;</span><br><span class="line">        b = s.b;</span><br><span class="line">        c = s.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行结果没有任何变化，汇编指令也完全相同。这说明struct加上构造函数并没有改变它的布局，即：</p>
<ul>
<li>以上函数均不存在于对象内部。</li>
<li>以上函数均未带来额外开销。</li>
</ul>
<p>但我们不能说这些函数对struct没有任何影响，后面会讲到，当我们添加了这些函数后：</p>
<ul>
<li>这个struct不再满足POD的定义，即不再有bitwise语义。</li>
<li>如果上述函数未被定义为内联（inline）函数，则其会带来额外开销。</li>
</ul>
<h3 id="为struct添加普通非虚函数"><a href="#为struct添加普通非虚函数" class="headerlink" title="为struct添加普通非虚函数"></a>为struct添加普通非虚函数</h3><p>我们比较以下两种写法。写法一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(S* s)</span> </span>&#123;</span><br><span class="line">    s-&gt;a += <span class="number">1</span>;</span><br><span class="line">    s-&gt;b -= <span class="number">1</span>;</span><br><span class="line">    s-&gt;c *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:%d b:%ld c:%d\n&quot;</span>, s-&gt;a, s-&gt;b, s-&gt;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与写法二：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        b -= <span class="number">1</span>;</span><br><span class="line">        c *= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a:%d b:%ld c:%d\n&quot;</span>, a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应的<code>main</code>函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    s.<span class="built_in">Func</span>(); <span class="comment">// or Func(&amp;s);</span></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;size:%d &amp;a-&amp;s:%d, &amp;b-&amp;s:%d &amp;c-&amp;s:%d\n&quot;</span>,</span><br><span class="line">        <span class="built_in">sizeof</span>(s),</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.a - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.b - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.c - (<span class="type">char</span>*)&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法一的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a:2 b:1 c:6</span><br><span class="line">size:24 &amp;a-&amp;s:0, &amp;b-&amp;s:8 &amp;c-&amp;s:16</span><br><span class="line"></span><br><span class="line">  400500:   48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  400504:   48 89 e7                mov    %rsp,%rdi</span><br><span class="line">  400507:   c6 04 24 01             movb   $0x1,(%rsp)</span><br><span class="line">  40050b:   48 c7 44 24 08 02 00    movq   $0x2,0x8(%rsp)</span><br><span class="line">  400512:   00 00</span><br><span class="line">  400514:   c7 44 24 10 03 00 00    movl   $0x3,0x10(%rsp)</span><br><span class="line">  40051b:   00</span><br><span class="line">  40051c:   e8 1f 01 00 00          callq  400640 &lt;_Z4FuncP1S&gt;</span><br><span class="line">  400521:   41 b8 10 00 00 00       mov    $0x10,%r8d</span><br><span class="line">  400527:   b9 08 00 00 00          mov    $0x8,%ecx</span><br><span class="line">  40052c:   31 d2                   xor    %edx,%edx</span><br><span class="line">  40052e:   be 18 00 00 00          mov    $0x18,%esi</span><br><span class="line">  400533:   bf 18 07 40 00          mov    $0x400718,%edi</span><br><span class="line">  400538:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40053a:   e8 91 ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">  40053f:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400541:   48 83 c4 28             add    $0x28,%rsp</span><br></pre></td></tr></table></figure>

<p>写法二的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a:2 b:1 c:6</span><br><span class="line">size:24 &amp;a-&amp;s:0, &amp;b-&amp;s:8 &amp;c-&amp;s:16</span><br><span class="line"></span><br><span class="line">  400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400504:   b9 06 00 00 00          mov    $0x6,%ecx</span><br><span class="line">  400509:   ba 01 00 00 00          mov    $0x1,%edx</span><br><span class="line">  40050e:   be 02 00 00 00          mov    $0x2,%esi</span><br><span class="line">  400513:   bf c0 06 40 00          mov    $0x4006c0,%edi</span><br><span class="line">  400518:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40051a:   e8 b1 ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">  40051f:   41 b8 10 00 00 00       mov    $0x10,%r8d</span><br><span class="line">  400525:   b9 08 00 00 00          mov    $0x8,%ecx</span><br><span class="line">  40052a:   31 d2                   xor    %edx,%edx</span><br><span class="line">  40052c:   be 18 00 00 00          mov    $0x18,%esi</span><br><span class="line">  400531:   bf d8 06 40 00          mov    $0x4006d8,%edi</span><br><span class="line">  400536:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400538:   e8 93 ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">  40053d:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40053f:   48 83 c4 08             add    $0x8,%rsp</span><br></pre></td></tr></table></figure>

<p>对比两种写法的结果，我们发现：</p>
<ul>
<li>成员布局上，两者相同，即普通的非虚成员函数不存在于对象中，不会占用空间。</li>
<li>汇编指令上，第一种写法调用了<code>Func(S*)</code>，而第二种写法完全看不到<code>S::Func</code>，而是直接调用了<code>printf</code>。</li>
</ul>
<p>上面的第二条发现，实际上就是inline的效果。c++标准规定了定义在类（无论是class还是struct）定义中的函数都默认带有inline效果，因此它被编译器直接展开到调用处了。</p>
<p>如果我们给<code>Func(S*)</code>前面加上<code>inline</code>，我们会得到与写法二完全相同的汇编指令（不贴了）。因此结论就是：</p>
<ul>
<li>普通的非虚成员函数不会占用对象空间，也不会带来额外开销，与对应的非成员函数完全相同。</li>
<li><code>Func(S*)</code>等效于<code>S::Func()</code>。</li>
</ul>
<p>针对上面的第二点，实际上<code>S::Func()</code>会被编译器变成一个非成员函数，类似为<code>S_Func(S* const this)</code>，而<code>S::Func() const</code>则对应<code>S_Func(const S* const this)</code>。</p>
<h2 id="为struct添加虚成员函数"><a href="#为struct添加虚成员函数" class="headerlink" title="为struct添加虚成员函数"></a>为struct添加虚成员函数</h2><p>我们将<code>S::Func</code>改为一个虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        b -= <span class="number">1</span>;</span><br><span class="line">        c *= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a:%d b:%ld c:%d\n&quot;</span>, a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应的<code>main</code>函数不变，直接运行会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct.cpp: In function ‘int main()’:</span><br><span class="line">struct.cpp:18:19: error: in C++98 ‘s’ must be initialized by constructor, not by ‘&#123;...&#125;’</span><br><span class="line">     S s = &#123;1, 2, 3&#125;;</span><br><span class="line">                   ^</span><br><span class="line">struct.cpp:18:19: error: could not convert ‘&#123;1, 2, 3&#125;’ from ‘&lt;brace-enclosed initializer list&gt;’ to ‘S’</span><br></pre></td></tr></table></figure>

<p>似乎此时struct与c的struct已经不一样了。我们给它加上一个构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S::<span class="built_in">S</span>(<span class="type">int8_t</span> x, <span class="type">int64_t</span> y, <span class="type">int32_t</span> z) &#123;</span><br><span class="line">    a = x;</span><br><span class="line">    b = y;</span><br><span class="line">    c = z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以编译过了。先运行前面的<code>main</code>函数（构造那行要改），结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:32 &amp;a-&amp;s:8, &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>我们发现：</p>
<ul>
<li>加入虚函数后，对象变大了，说明虚函数占用了一部分对象空间。</li>
<li>对象变大了8字节（实际是虚表指针），且正好在对象的最前面，其它成员变量的位置依次向下8字节。</li>
</ul>
<p>这是第一个与c的struct布局不同的场景。我们知道虚函数是为了实现运行期多态的，那么就需要有信息来帮助程序在运行期根据对象的不同而选择不同的行为，这种信息就会带来运行期的额外开销。</p>
<p>但调用虚函数真的就会有运行期开销吗？我们分别看一下直接通过对象来调用虚函数，与通过指针或引用调用虚函数的区别。</p>
<p>我们添加三个Test函数，并在main函数中调用它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">(S s)</span> </span>&#123;</span><br><span class="line">    s.<span class="built_in">Func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test2</span><span class="params">(S* s)</span> </span>&#123;</span><br><span class="line">    s-&gt;<span class="built_in">Func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test3</span><span class="params">(S&amp; s)</span> </span>&#123;</span><br><span class="line">    s.<span class="built_in">Func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的汇编指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">0000000000400710 &lt;_Z5Test11S&gt;:</span><br><span class="line">  400710:   0f b6 47 08             movzbl 0x8(%rdi),%eax</span><br><span class="line">  400714:   8d 70 01                lea    0x1(%rax),%esi</span><br><span class="line">  400717:   48 8b 47 10             mov    0x10(%rdi),%rax</span><br><span class="line">  40071b:   40 88 77 08             mov    %sil,0x8(%rdi)</span><br><span class="line">  40071f:   40 0f be f6             movsbl %sil,%esi</span><br><span class="line">  400723:   48 8d 50 ff             lea    -0x1(%rax),%rdx</span><br><span class="line">  400727:   8b 47 18                mov    0x18(%rdi),%eax</span><br><span class="line">  40072a:   48 89 57 10             mov    %rdx,0x10(%rdi)</span><br><span class="line">  40072e:   8d 0c 00                lea    (%rax,%rax,1),%ecx</span><br><span class="line">  400731:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400733:   89 4f 18                mov    %ecx,0x18(%rdi)</span><br><span class="line">  400736:   bf 20 08 40 00          mov    $0x400820,%edi</span><br><span class="line">  40073b:   e9 20 fe ff ff          jmpq   400560 &lt;printf@plt&gt;</span><br><span class="line"></span><br><span class="line">0000000000400740 &lt;_Z5Test2P1S&gt;:</span><br><span class="line">  400740:   48 8b 07                mov    (%rdi),%rax</span><br><span class="line">  400743:   48 8b 00                mov    (%rax),%rax</span><br><span class="line">  400746:   ff e0                   jmpq   *%rax</span><br><span class="line">  400748:   0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)</span><br><span class="line">  40074f:   00</span><br><span class="line"></span><br><span class="line">0000000000400750 &lt;_Z5Test3R1S&gt;:</span><br><span class="line">  400750:   48 8b 07                mov    (%rdi),%rax</span><br><span class="line">  400753:   48 8b 00                mov    (%rax),%rax</span><br><span class="line">  400756:   ff e0                   jmpq   *%rax</span><br><span class="line">  400758:   0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)</span><br><span class="line">  40075f:   00</span><br></pre></td></tr></table></figure>

<p>我们发现：</p>
<ul>
<li><code>Test1</code>中<code>Func</code>被展开了，看不到直接的<code>Func</code>调用，这点与调用一个非虚函数的行为相同。</li>
<li><code>Test2</code>中通过间接跳转（jmpq）调用了<code>Func</code>，方法是先取出<code>s</code>（%rdi）的前8字节到%rax，再从%rax取出前8字节放到%rax，这就是<code>Func</code>的地址，之后就是一次间接跳转。</li>
<li><code>Test3</code>与<code>Test2</code>完全相同。</li>
</ul>
<p>结论：</p>
<ul>
<li>通过一个对象调用虚函数时，编译器没有采用运行期多态，而是直接像调用一个非虚函数一样，没有运行期开销。</li>
<li>通过指针调用虚函数时，有运行期开销，即需要一次间接跳转，此时虚函数无法展开。</li>
<li>引用与指针此处无区别，引用就是一种语法糖。</li>
</ul>
<h2 id="为struct添加一个非虚继承的基类"><a href="#为struct添加一个非虚继承的基类" class="headerlink" title="为struct添加一个非虚继承的基类"></a>为struct添加一个非虚继承的基类</h2><h3 id="为struct添加一个无虚函数的非虚继承基类"><a href="#为struct添加一个无虚函数的非虚继承基类" class="headerlink" title="为struct添加一个无虚函数的非虚继承基类"></a>为struct添加一个无虚函数的非虚继承基类</h3><p>我们修改一下<code>S</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行前面的<code>main</code>函数，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:24 &amp;a-&amp;s:4, &amp;b-&amp;s:8 &amp;c-&amp;s:16</span><br></pre></td></tr></table></figure>

<p>此时<code>S</code>的布局可以认为是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> ba;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    Base base;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>两者的区别在于，前者是基类的所有成员都可以被当作子类的成员，而后者是基类子对象就是子类的第一个成员。</p>
<p>到底是哪种呢？当基类为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> ba;</span><br><span class="line">    <span class="type">int8_t</span> bb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时，如果按前者，<code>Base::bb</code>和<code>S::a</code>之间应该没有padding，即此时<code>S</code>的大小仍然是24；如果按后者，<code>Base</code>的alignment为8，此时<code>Base::bb</code>后面会有padding，<code>S</code>的大小应该是32。我们试一下，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:32 &amp;a-&amp;s:8, &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>说明：基类子对象可以被当作子类对象的第一个成员，且保持自己的alignment和padding。</p>
<h3 id="为struct添加第二个非虚基类"><a href="#为struct添加第二个非虚基类" class="headerlink" title="为struct添加第二个非虚基类"></a>为struct添加第二个非虚基类</h3><p>我们再加一个基类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> ba;</span><br><span class="line">    <span class="type">int8_t</span> bb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> ca;</span><br><span class="line">    <span class="type">int8_t</span> cb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> Base, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据上节的结论，我们可以认为<code>Base2</code>也是<code>S</code>的一个成员，且应排列在<code>Base</code>后面，<code>S</code>的大小应该是40。实验结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:40 &amp;a-&amp;s:16, &amp;b-&amp;s:24 &amp;c-&amp;s:32</span><br></pre></td></tr></table></figure>

<p>证实了我们的猜测。</p>
<h3 id="为struct添加空的基类"><a href="#为struct添加空的基类" class="headerlink" title="为struct添加空的基类"></a>为struct添加空的基类</h3><p>所谓空类型，指：</p>
<ul>
<li>没有任何非静态成员变量。</li>
<li>没有任何虚函数。</li>
<li>没有任何虚基类。</li>
<li>其上没有基类，或只有空基类。</li>
</ul>
<p>当我们给<code>S</code>添加一个空类型的基类时，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int64_t</span> b; <span class="comment">// 注意该场景中没有成员a</span></span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据之前的结论，<code>S</code>应该相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    Base base;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们知道，c++中任何类型的size都至少是1，这是为了避免不同变量对应相同的内存地址。那么<code>base</code>的size就是1，<code>S</code>的size就应该是24。实际上呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:16 &amp;b-&amp;s:0 &amp;c-&amp;s:8</span><br></pre></td></tr></table></figure>

<p>居然是16！这就是c++的空基类优化（Empty Base Optimization，EBO），当基类子对象为空时，其不必在子类对象中占据空间，且与子类对象共享相同的地址。这里是一个c的oop无法模拟的点。</p>
<h2 id="为struct添加有虚函数的非虚继承基类"><a href="#为struct添加有虚函数的非虚继承基类" class="headerlink" title="为struct添加有虚函数的非虚继承基类"></a>为struct添加有虚函数的非虚继承基类</h2><h3 id="基类无成员变量"><a href="#基类无成员变量" class="headerlink" title="基类无成员变量"></a>基类无成员变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;Base:%d S:%d &amp;base-&amp;s:%d &amp;a-&amp;s:%d &amp;b-&amp;s:%d &amp;c-&amp;s:%d\n&quot;</span>,</span><br><span class="line">        <span class="built_in">sizeof</span>(Base),</span><br><span class="line">        <span class="built_in">sizeof</span>(S),</span><br><span class="line">        (<span class="type">char</span>*)<span class="built_in">static_cast</span>&lt;Base*&gt;(&amp;s) - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.a - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.b - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.c - (<span class="type">char</span>*)&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:8 S:32 &amp;base-&amp;s:0 &amp;a-&amp;s:8 &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>有虚函数的类型，其对象中需要有1个虚表指针来存放运行期信息，不再是空类型，作为基类也没办法应用EBO。</li>
<li>子类对象中不会有2个虚表指针（基类子对象1个，子类对象1个），而是与基类共用1个虚表指针。</li>
</ul>
<h3 id="基类有成员变量"><a href="#基类有成员变量" class="headerlink" title="基类有成员变量"></a>基类有成员变量</h3><p>假设我们给基类添加一个成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="type">int8_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据前文规则，<code>Base</code>大小为16，其alignment为8，<code>S</code>的大小就会是40，且<code>Base::bb</code>与<code>S::a</code>之间有padding。但运行结果却是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:16 S:32 &amp;base-&amp;s:0 &amp;a-&amp;s:9 &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>与我们的猜测不符，<code>Base::bb</code>与<code>S::a</code>之间没有padding。</p>
<p>后面我们会说到c++有一种标准布局（Standard Layout），这种布局需要与c的struct布局兼容（外加空基类优化）。而当<code>Base</code>或<code>S</code>中加入虚函数后，它们就不再符合标准布局了，编译器就可以应用更紧凑的布局了。</p>
<p>为什么标准布局需要与c的struct布局兼容？因为POD（Plain Old Data）类型首先需要是标准布局类型，而POD类型本身就是为了与c兼容而提出的概念。</p>
<h2 id="为struct添加虚继承基类"><a href="#为struct添加虚继承基类" class="headerlink" title="为struct添加虚继承基类"></a>为struct添加虚继承基类</h2><p>注：大多数c++项目都禁止使用虚继承，因此下面的几个场景我们只给输出和大概的结论，不进行更多的探索和解释了。</p>
<h3 id="基类为空类型"><a href="#基类为空类型" class="headerlink" title="基类为空类型"></a>基类为空类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:1 S:32 &amp;base-&amp;s:0 &amp;a-&amp;s:8 &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>虚基类会在子类中占用额外空间（1个指针），位置在子类最前面，此时无法应用EBO。</li>
</ul>
<h3 id="基类为非空无虚函数类型"><a href="#基类为非空无虚函数类型" class="headerlink" title="基类为非空无虚函数类型"></a>基类为非空无虚函数类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:1 S:32 &amp;base-&amp;s:28 &amp;a-&amp;s:8 &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>子类对象最前面仍然是1个指针。</li>
<li>此时基类子对象位于子类最后。</li>
</ul>
<h3 id="基类为非空有虚函数类型"><a href="#基类为非空有虚函数类型" class="headerlink" title="基类为非空有虚函数类型"></a>基类为非空有虚函数类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="type">int8_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:16 S:48 &amp;base-&amp;s:32 &amp;a-&amp;s:8 &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>此时子类对象的前8字节不再是虚表指针，而是指向虚基类子对象的指针。</li>
<li>基类子对象的前8字节是虚表指针，且其整体位于子类最后一个成员变量的后面。</li>
</ul>
<h3 id="无虚函数的菱形继承"><a href="#无虚函数的菱形继承" class="headerlink" title="无虚函数的菱形继承"></a>无虚函数的菱形继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int32_t</span> ca;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int32_t</span> da;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> C, <span class="keyword">public</span> D &#123;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:1 C:16 D:16 S:48 &amp;Base-&amp;S:44 &amp;C-&amp;S:0 &amp;D-&amp;S:16 &amp;b-&amp;s:32 &amp;c-&amp;s:40</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>此时<code>C</code>的子对象与<code>S</code>对象共享一个虚基类指针，而<code>D</code>则自己使用一个虚基类指针。</li>
<li><code>C</code>与<code>D</code>依次位于<code>S</code>的前端，而<code>Base</code>依然在最后端。</li>
<li>调用来自虚基类的虚函数时，相比非虚基类的虚函数，要多一次间接跳转：先通过虚基类指针找到虚表指针，再通过虚表指针找到对应函数地址。</li>
</ul>
<h3 id="有虚函数的菱形继承"><a href="#有虚函数的菱形继承" class="headerlink" title="有虚函数的菱形继承"></a>有虚函数的菱形继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="type">int8_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int32_t</span> ca;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int32_t</span> da;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> C, <span class="keyword">public</span> D &#123;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:16 C:32 D:32 S:64 &amp;Base-&amp;S:48 &amp;C-&amp;S:0 &amp;D-&amp;S:16 &amp;b-&amp;s:32 &amp;c-&amp;s:40</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li><code>C</code>和<code>D</code>依然位于<code>S</code>的前端，而<code>Base</code>位于后端。</li>
<li><code>C</code>与<code>S</code>共享一个虚基类指针，<code>D</code>自己使用一个虚基类指针。</li>
<li><code>C</code>与<code>D</code>与<code>S</code>与<code>Base</code>共享一个虚表指针。</li>
</ul>
<h1 id="struct与class"><a href="#struct与class" class="headerlink" title="struct与class"></a>struct与class</h1><p>第二个问题，c++中的struct和class有什么区别？</p>
<p>答案是，除了默认访问权限不同（struct默认为public，而class默认为private）外，其它完全相同。</p>
<p>上面的例子中，我们把每个struct都换成class，仍然能得到相同的结论。决定对象模型的不是用哪个关键字修饰它，而是它本身的性质，是否有基类，是否有虚函数，是否有虚基类。</p>
<h2 id="然而struct不能用于修饰模板参数类型"><a href="#然而struct不能用于修饰模板参数类型" class="headerlink" title="然而struct不能用于修饰模板参数类型"></a>然而struct不能用于修饰模板参数类型</h2><p>但struct却不能用于下面这个场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">struct</span> <span class="title class_">X</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">sizeof</span>(X));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们编译时，报错信息为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct.cpp:19:18: error: ‘struct X’ is not a valid type for a template non-type parameter</span><br><span class="line"> template &lt;struct X&gt;</span><br><span class="line">                  ^</span><br></pre></td></tr></table></figure>

<p>而当我们把struct改成class或typename后，就可以编译成功了。</p>
<h1 id="struct的零额外开销"><a href="#struct的零额外开销" class="headerlink" title="struct的零额外开销"></a>struct的零额外开销</h1><p>众所周知，c++的一个核心理念就是保证某个功能对不使用它的用户零额外开销。我们从几方面看一下struct是如何实现零额外开销的。</p>
<h2 id="使用栈上的struct成员"><a href="#使用栈上的struct成员" class="headerlink" title="使用栈上的struct成员"></a>使用栈上的struct成员</h2><p>下面两段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">Func</span><span class="params">(<span class="type">int8_t</span> x, <span class="type">int64_t</span> y, <span class="type">int32_t</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">    a = x;</span><br><span class="line">    b = y;</span><br><span class="line">    c = z;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">Func</span><span class="params">(<span class="type">int8_t</span> x, <span class="type">int64_t</span> y, <span class="type">int32_t</span> z)</span> </span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    s.a = x;</span><br><span class="line">    s.b = y;</span><br><span class="line">    s.c = z;</span><br><span class="line">    <span class="keyword">return</span> s.a + s.b + s.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们对应的汇编指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000004005b0 &lt;_Z4Funcali&gt;:</span><br><span class="line">  4005b0:   48 0f be ff             movsbq %dil,%rdi</span><br><span class="line">  4005b4:   48 63 d2                movslq %edx,%rdx</span><br><span class="line">  4005b7:   48 01 fe                add    %rdi,%rsi</span><br><span class="line">  4005ba:   48 8d 04 16             lea    (%rsi,%rdx,1),%rax</span><br><span class="line">  4005be:   c3                      retq</span><br><span class="line">  4005bf:   90                      nop</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000004005b0 &lt;_Z4Funcali&gt;:</span><br><span class="line">  4005b0:   48 0f be ff             movsbq %dil,%rdi</span><br><span class="line">  4005b4:   48 63 d2                movslq %edx,%rdx</span><br><span class="line">  4005b7:   48 01 fe                add    %rdi,%rsi</span><br><span class="line">  4005ba:   48 8d 04 16             lea    (%rsi,%rdx,1),%rax</span><br><span class="line">  4005be:   c3                      retq</span><br><span class="line">  4005bf:   90                      nop</span><br></pre></td></tr></table></figure>

<p>完全相同，说明使用栈上的struct成员，与使用栈上变量完全相同，零额外开销。</p>
<h2 id="传递小struct"><a href="#传递小struct" class="headerlink" title="传递小struct"></a>传递小struct</h2><p>下面两段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">int32_t</span> x, <span class="type">int32_t</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x:%d y:%d\n&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int32_t</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> x;</span><br><span class="line">    <span class="type">int32_t</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(S s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x:%d y:%d\n&quot;</span>, s.x, s.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    s.x = <span class="number">1</span>;</span><br><span class="line">    s.y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Func</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的汇编指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000400500 &lt;main&gt;:</span><br><span class="line">  400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400504:   ba 02 00 00 00          mov    $0x2,%edx</span><br><span class="line">  400509:   be 01 00 00 00          mov    $0x1,%esi</span><br><span class="line">  40050e:   bf b0 06 40 00          mov    $0x4006b0,%edi</span><br><span class="line">  400513:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400515:   e8 b6 ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">  40051a:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40051c:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  400520:   c3                      retq</span><br><span class="line">  400521:   0f 1f 00                nopl   (%rax)</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000400500 &lt;main&gt;:</span><br><span class="line">  400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400504:   ba 02 00 00 00          mov    $0x2,%edx</span><br><span class="line">  400509:   be 01 00 00 00          mov    $0x1,%esi</span><br><span class="line">  40050e:   bf c0 06 40 00          mov    $0x4006c0,%edi</span><br><span class="line">  400513:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400515:   e8 b6 ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">  40051a:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40051c:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  400520:   c3                      retq</span><br><span class="line">  400521:   0f 1f 00                nopl   (%rax)</span><br></pre></td></tr></table></figure>

<p>注意此时两个<code>Func</code>函数都被inline掉了，因此我们可以直接对应<code>main</code>的汇编代码。可以看到它们完全相同，也符合上节的结论。</p>
<p>当我们把inline关掉后，先看一下<code>main</code>（看参数是如何传递的）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000000000400500 &lt;main&gt;:</span><br><span class="line">  400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400504:   be 02 00 00 00          mov    $0x2,%esi</span><br><span class="line">  400509:   bf 01 00 00 00          mov    $0x1,%edi</span><br><span class="line">  40050e:   e8 fd 00 00 00          callq  400610 &lt;_Z4Funcii&gt;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000000000400500 &lt;main&gt;:</span><br><span class="line">  400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400504:   48 bf 01 00 00 00 02    movabs $0x200000001,%rdi</span><br><span class="line">  40050b:   00 00 00</span><br><span class="line">  40050e:   e8 fd 00 00 00          callq  400610 &lt;_Z4Func1S&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到直接传递一个struct反倒少了一条指令！原因是此时<code>S</code>为8个字节，刚好可以放入一个寄存器中，因此可以一条指令传递过去。而如果分成两个<code>int32_t</code>，则编译器必须用两个寄存器传递，多了一条指令。</p>
<p>再对比一下<code>Func</code>的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0000000000400610 &lt;_Z4Funcii&gt;:</span><br><span class="line">  400610:   89 f2                   mov    %esi,%edx</span><br><span class="line">  400612:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400614:   89 fe                   mov    %edi,%esi</span><br><span class="line">  400616:   bf b0 06 40 00          mov    $0x4006b0,%edi</span><br><span class="line">  40061b:   e9 b0 fe ff ff          jmpq   4004d0 &lt;printf@plt&gt;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0000000000400610 &lt;_Z4FuncS&gt;:</span><br><span class="line">  400610:   48 89 fa                mov    %rdi,%rdx</span><br><span class="line">  400613:   89 fe                   mov    %edi,%esi</span><br><span class="line">  400615:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400617:   48 c1 fa 20             sar    $0x20,%rdx</span><br><span class="line">  40061b:   bf c0 06 40 00          mov    $0x4006c0,%edi</span><br><span class="line">  400620:   e9 ab fe ff ff          jmpq   4004d0 &lt;printf@plt&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到传递<code>S</code>的版本多了一条<code>sar $0x20,%rdx</code>，这是因为我们用一个寄存器传递了两个值，但在调用<code>printf</code>时还是要把它们分开，因此这里需要先把低4字节放到另一个寄存器里，再把%rdx的内容右移32位，从而得到高4字节的值。</p>
<p>把<code>main</code>和<code>Func</code>加起来，两个版本的汇编指令数量仍然完全相同，区别在于前者传递时多一次赋值，后者运算时多一次右移，可以认为开销相同。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/07/cpp-object-model-alignment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/07/cpp-object-model-alignment/" class="post-title-link" itemprop="url">C++对象模型（一）Alignment</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-07 20:31:30" itemprop="dateCreated datePublished" datetime="2018-03-07T20:31:30+08:00">2018-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="word"><a href="#word" class="headerlink" title="word"></a>word</h1><p>第一个概念，word（字）。</p>
<p>word是cpu领域的一个重要概念，它被定义为cpu使用数据的一个自然单位（natural unit），cpu的很多数据长度都与其相关，比如：</p>
<ul>
<li>通常cpu的大多数寄存器长度为一个word。</li>
<li>通常cpu最大寻址空间为一个word（即指针大小通常是一个word）。</li>
<li>总线宽度通常为一个word，即cpu单次读写内存的量通常最大为一个word。</li>
<li>很多cpu每条指令的长度也为一个word。</li>
</ul>
<p>32位&#x2F;64位cpu中的32位和64位就是指它的字长（word-length或word-size）为32位或64位。</p>
<p>这里不详细介绍不同cpu的word的具体含义。我们说一下word对内存读写的影响：</p>
<ul>
<li>早期的cpu通常只能沿着一个word的边界读写数据，如果一次读&#x2F;写操作的目标地址不是字长的整数倍，cpu会报错。</li>
<li>现代的X86 cpu可以在任意地址读写数据，但如果目标地址不是字长的整数倍，底层会将这次操作按word分界分成多个读写操作，对性能有明显影响。</li>
<li>X86-64 cpu可以在任意地址读写数据，且不会有明显的性能影响。</li>
</ul>
<p><img src="http://7xipsa.com1.z0.glb.clouddn.com/alignment.png" alt="alignment"></p>
<p>上图的第一个例子，我们按alignment存放了1个int（4字节数据），cpu只需要一次内存操作就可以完成存取。而第二个例子中，cpu需要两次内存操作来完成int的存取。</p>
<p>现代的cpu通常有多个字长概念（word、1&#x2F;2word、1&#x2F;4word等），针对不同的数据长度，可以有不同的字长。X86和X86-64对长度为1&#x2F;2&#x2F;4&#x2F;8字节的数据，其字长也为1&#x2F;2&#x2F;4&#x2F;8字节。</p>
<h1 id="alignment和padding"><a href="#alignment和padding" class="headerlink" title="alignment和padding"></a>alignment和padding</h1><p>第二个概念，alignment。</p>
<p>考虑到数据不按word边界存放可能引起的问题，编译器在排列变量时，会尽量将其按对应的字长来排列。这种行为就被称为对齐（alignment），而因为alignment导致的数据间产生未使用的空洞，则被称为填充（padding）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int16_t</span> i16;</span><br><span class="line">    <span class="type">int32_t</span> i32;</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c:%ld i16:%ld i32:%ld i64:%ld\n&quot;</span>, &amp;c, &amp;i16, &amp;i32, &amp;i64);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我的环境下（X86-64，gcc4.8.5），输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:140730763468703 i16:140730763468700 i32:140730763468696 i64:140730763468688</span><br></pre></td></tr></table></figure>

<p>可以看到<code>i16</code>与<code>c</code>之间有2字节的padding，<code>i32</code>与<code>i16</code>之间有2字节的padding，<code>i64</code>与<code>i32</code>之间有4字节的padding，实际上是这么排列的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">char</span> padding0[<span class="number">2</span>];</span><br><span class="line"><span class="type">int16_t</span> i16;</span><br><span class="line"><span class="type">char</span> padding1[<span class="number">2</span>];</span><br><span class="line"><span class="type">int32_t</span> i32;</span><br><span class="line"><span class="type">char</span> padding2[<span class="number">4</span>];</span><br><span class="line"><span class="type">int64_t</span> i64;</span><br></pre></td></tr></table></figure>

<h1 id="struct的alignment"><a href="#struct的alignment" class="headerlink" title="struct的alignment"></a>struct的alignment</h1><p>struct的alignment规则很简单：</p>
<ul>
<li>空struct的size与alignment均为1。</li>
<li>非空的struct，其alignment为各成员的alignment的最大值。其最后一个成员后面若有需要，也要padding。</li>
</ul>
<p>注意第2条规则，会导致struct占用的空间比我们预期的更多，例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c0;</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它的自然大小为10B（1+8+1），但考虑到alignment的影响，真实大小却是24B（8+8+8）！</p>
<p>因此<code>S</code>的真实布局为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c0;</span><br><span class="line">    <span class="type">char</span> padding0[<span class="number">7</span>]；</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">char</span> padding1[<span class="number">7</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而当<code>S</code>作为其它struct的成员时，它的size和alignment分别是24和8，会影响到上层struct的alignment。</p>
<p>适当的重新排列<code>S</code>的成员，可以显著减小它的size：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c0;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时它的真实布局为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c0;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">char</span> padding[<span class="number">6</span>];</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>S</code>的size减小到了16B。</p>
<h1 id="与alignment有关的编译器扩展"><a href="#与alignment有关的编译器扩展" class="headerlink" title="与alignment有关的编译器扩展"></a>与alignment有关的编译器扩展</h1><p>这里只介绍gcc的相关扩展。</p>
<p>gcc允许我们用<code>__attribute__</code>来修饰变量，其中用于改变alignment的有以下几种。</p>
<p>注意：修改alignment可能会影响ABI兼容性和可移植性，通常不推荐。</p>
<h2 id="aligned"><a href="#aligned" class="headerlink" title="aligned"></a>aligned</h2><p>语法1：<code>__attribute__ ((aligned (size_in_byte)))</code>，显式指定alignment。注意：指定比默认更小的alignment是无效的，会被编译器忽略。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x __attribute__ ((aligned (<span class="number">16</span>))) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x[<span class="number">2</span>] __attribute__ ((aligned (<span class="number">8</span>)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">R</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; __attribute__ ((aligned (<span class="number">8</span>)));</span><br></pre></td></tr></table></figure>

<p>语法2：<code>__attribute__ ((aligned))</code>，让编译器选择可能的最大alignment，对64位环境而言通常是8。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">R</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; __attribute__ ((aligned));</span><br></pre></td></tr></table></figure>

<h2 id="packed"><a href="#packed" class="headerlink" title="packed"></a>packed</h2><p>语法：<code>__attribute__ ((packed))</code>，表示该变量或struct选择可能的最小alignment，对64位环境而言通常是1。</p>
<p>下面这个struct，加上<code>packed</code>后其大小变为10，与其自然大小相等：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c0;</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p>编译时如果加上<code>-fpack-struct</code>，则默认所有变量和struct都会按<code>packed</code>处理。</p>
<p>如果加上<code>-Wpadded</code>，则编译器增加padding的地方会有warning。注意只包含struct场景。</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a target="_blank" rel="noopener" href="https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-paper.pdf">Alignment in C</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Word_(computer_architecture)">Wiki - Word</a></li>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html">Specifying Attributes of Variables</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/05/high-concurrency-work/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/05/high-concurrency-work/" class="post-title-link" itemprop="url">高并发工作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-05 13:56:37" itemprop="dateCreated datePublished" datetime="2018-03-05T13:56:37+08:00">2018-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大体来讲，我们每个人头上都不会只有一项工作，很可能在某阶段，头上会有N项工作。我们当然希望这些工作能按部就班的、一项一项的顺序完成。但现实是残酷的，总有些工作会depend其它人，而不得不暂停下来；也总有些工作每天都有人催，需要尽快完成。所以，结论就是每个人都需要高并发工作，也需要知道怎么实现高并发工作。</p>
<p>有种观点是，编程中的所有概念都是人类活动的延续，反映了人类自己的思维方式与组织架构。这句话反过来说也不无道理，即人类的思维方式与组织架构，往往可以从编程中找到对应的概念。</p>
<p>某种程度上，实现高并发工作的方法与实现高并发编程是类似的。本文就参照高并发编程的一些要素，来分析一下如何达到高并发工作。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/03/05/high-concurrency-work/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/01/30/future-promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/30/future-promise/" class="post-title-link" itemprop="url">Future与Promise</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-30 11:55:30" itemprop="dateCreated datePublished" datetime="2018-01-30T11:55:30+08:00">2018-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Future和Promise</p>
<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p>有没有某个时刻，你觉得你的程序可以分成多个部分，其中一些部分不需要等待其它部分运行结束？比如当程序发出一个http请求后，在它返回之前，程序似乎还可以做点别的事情；比如当程序在等待一个请求的response的序列化完成时，似乎它可以做下个请求的参数检查了。这时候，你就需要了解异步编程了。</p>
<p>当程序分成多部分，这些部分之间的消息通信就成了一件很重要的事情。通常我们将消息通信分成同步和异步两种，其中同步就是消息的发送方要等待消息返回才能继续处理其它事情，而异步就是消息的发送方不需要等待消息返回就可以处理其它事情。很显然异步允许我们同时做更多事情，往往也能获得更高的性能。尤其对于JavaScript这种通常是单线程环境的语言，更需要将长延时的阻塞操作异步化来保证其它操作的顺利进行。</p>
<p>异步编程的核心问题是如何处理通信：要么有办法知道通信有没有完成，要么能保证在通信完成后执行一段特定的逻辑。前者就是通知机制，比如信号量、条件变量等；后者就是callback，即回调。</p>
<h2 id="回调噩梦"><a href="#回调噩梦" class="headerlink" title="回调噩梦"></a>回调噩梦</h2><p>当一项任务需要分成多个异步阶段完成时，就需要在每个阶段的回调函数中加入下阶段回调的代码，最终产生下面这样金字塔形状的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">getData = <span class="keyword">function</span>(<span class="params">param, callback</span>)&#123;</span><br><span class="line">  $.<span class="title function_">get</span>(<span class="string">&#x27;http://example.com/get/&#x27;</span>+param,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">responseText</span>)&#123;</span><br><span class="line">      <span class="title function_">callback</span>(responseText);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getData</span>(<span class="number">0</span>, <span class="keyword">function</span>(<span class="params">a</span>)&#123;</span><br><span class="line">  <span class="title function_">getData</span>(a, <span class="keyword">function</span>(<span class="params">b</span>)&#123;</span><br><span class="line">    <span class="title function_">getData</span>(b, <span class="keyword">function</span>(<span class="params">c</span>)&#123;</span><br><span class="line">      <span class="title function_">getData</span>(c, <span class="keyword">function</span>(<span class="params">d</span>)&#123;</span><br><span class="line">        <span class="title function_">getData</span>(d, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以想象当回调层次继续增加时，代码有多恐怖。这就是回调噩梦。</p>
<h1 id="Future和Promise"><a href="#Future和Promise" class="headerlink" title="Future和Promise"></a>Future和Promise</h1><p>Future指一个<strong>只读</strong>的值的容器，这个值可能立即可用，也可能在未来某个时间可用。而Promise则是一个只能写入一次的对象。每个Promise关联一个Future，对Promise的写入会令Future的值可用。我们只讨论Promise和Future一对一的场景，在这个场景中Future就是值，而Promise是产生值的方法。</p>
<p>Future和Promise来源于函数式语言，其目的是分离一个值和产生值的方法，从而简化异步代码的处理。</p>
<h2 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h2><p>Future与Promise配合起来可以实现一种可靠的通知机制，即我们可以异步执行一个方法，通过返回的Future来知道异步方法何时结束、是否成功、返回值是什么。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SyncOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">    <span class="built_in">RunAsync</span>(std::<span class="built_in">bind</span>(AsyncFunc, promise));</span><br><span class="line">    Future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">GetFuture</span>();</span><br><span class="line">    <span class="type">int</span> result = future.<span class="built_in">Get</span>(); <span class="comment">// wait until future is done</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收方</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncFunc</span><span class="params">(Promise&lt;<span class="type">int</span>&gt; promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    promise.<span class="built_in">Done</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式回调"><a href="#链式回调" class="headerlink" title="链式回调"></a>链式回调</h2><p>Promise的一个重要特性就是它支持<code>then</code>，可以将金字塔式的回调组织为链式，极大地降低了理解和维护的难度：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getData = <span class="keyword">function</span>(<span class="params">param, callback</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    $.<span class="title function_">get</span>(<span class="string">&#x27;http://example.com/get/&#x27;</span>+param,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">responseText</span>)&#123;</span><br><span class="line">      <span class="title function_">resolve</span>(responseText);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getData</span>(<span class="number">0</span>).<span class="title function_">then</span>(getData)</span><br><span class="line">  .<span class="title function_">then</span>(getData)</span><br><span class="line">  .<span class="title function_">then</span>(getData)</span><br><span class="line">  .<span class="title function_">then</span>(getData);</span><br></pre></td></tr></table></figure>

<h2 id="Async和Await"><a href="#Async和Await" class="headerlink" title="Async和Await"></a>Async和Await</h2><p>C#在5.0之后支持了<code>async</code>和<code>await</code>关键字，允许写出这样的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">AccessTheWebAsync</span>()</span>  </span><br><span class="line">&#123;   </span><br><span class="line">    HttpClient client = <span class="keyword">new</span> HttpClient();  </span><br><span class="line">    Task&lt;<span class="built_in">string</span>&gt; getStringTask = client.GetStringAsync(<span class="string">&quot;http://msdn.microsoft.com&quot;</span>);  </span><br><span class="line">    DoIndependentWork();  </span><br><span class="line">    <span class="built_in">string</span> urlContents = <span class="keyword">await</span> getStringTask;  </span><br><span class="line">    <span class="keyword">return</span> urlContents.Length;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> urlContents = <span class="keyword">await</span> client.GetStringAsync();</span><br></pre></td></tr></table></figure>

<p>其中<code>async</code>要求函数必须返回<code>Task</code>或<code>Task&lt;T&gt;</code>，这里的<code>Task</code>可以理解为一种Future。用<code>async</code>修饰函数表明这是个可异步执行的函数，而用<code>await</code>会等待Future结束，返回Future的值，将异步又转成了同步。</p>
<p>上面js的例子用<code>await</code>来实现就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">getData = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">param, callback</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    $.<span class="title function_">get</span>(<span class="string">&#x27;http://example.com/get/&#x27;</span>+param,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">responseText</span>)&#123;</span><br><span class="line">      <span class="title function_">resolve</span>(responseText);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">await</span> <span class="title function_">getData</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> data1 = <span class="keyword">await</span> <span class="title function_">getData</span>(data);</span><br><span class="line"><span class="keyword">var</span> data2 = <span class="keyword">await</span> <span class="title function_">getData</span>(data1);</span><br><span class="line"><span class="keyword">var</span> data3 = <span class="keyword">await</span> <span class="title function_">getData</span>(data2);</span><br><span class="line"><span class="keyword">var</span> data4 = <span class="keyword">await</span> <span class="title function_">getData</span>(data3);</span><br></pre></td></tr></table></figure>

<p>这种写法要比Promise链更接近同步，也更易懂，但其底层依然是Promise。这种写法很接近于协程：用Promise来实现yield和resume，它就是一种协程。</p>
<h2 id="不同语言中的Future和Promise"><a href="#不同语言中的Future和Promise" class="headerlink" title="不同语言中的Future和Promise"></a>不同语言中的Future和Promise</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>C++11中增加了<code>std::future</code>和<code>std::promise</code>，基本是按照Future只读、Promise只写来设计的。它的缺点是：</p>
<ol>
<li>其实现绑定了<code>std::thread</code>，很难扩展到其它执行器上。</li>
<li>Promise不支持链式回调。</li>
</ol>
<h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h3><p>C#的<code>Task</code>就类似于Future，它的<code>async</code>和<code>await</code>也很方便。</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>Java之前就有<code>Future</code>，类似于C++11的<code>std::promise</code>，没有链式回调能力。Java8中增加了<code>CompletableFuture</code>，可以认为是一个完全的Promise了。</p>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>ES6开始，JavaScript增加了Promise、async、await等特性，极大改善了JS代码中维护回调难的问题。</p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Python3.5之后增加了对<code>async</code>和<code>await</code>的支持。</p>
<h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><p>Scala中的<code>Future</code>与<code>Promise</code>完全符合上面的介绍，它的一个特点是一个<code>Future</code>可以增加多个回调，但不保证这些回调的执行顺序。</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Futures_and_promises">Futures and promises</a></li>
<li><a target="_blank" rel="noopener" href="http://dist-prog-book.com/chapter/2/futures.html">Futures and Promises</a></li>
<li><a target="_blank" rel="noopener" href="http://ifeve.com/promise-future-callback/">并发编程 Promise, Future 和 Callback</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.coding.net/blog/how-do-promises-work">理解 Promise 的工作原理</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.scala-lang.org/overviews/core/futures.html">Scala: FUTURES AND PROMISES</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8">Understand promises before you start using async&#x2F;await</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Await">Await</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/index">Asynchronous programming with async and await (C#)</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2017/11/07/persistent-data-structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/07/persistent-data-structure/" class="post-title-link" itemprop="url">Persistent Data Structure</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-07 23:29:27" itemprop="dateCreated datePublished" datetime="2017-11-07T23:29:27+08:00">2017-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Persistent-Data-Structure"><a href="#Persistent-Data-Structure" class="headerlink" title="Persistent Data Structure"></a>Persistent Data Structure</h1><p>Persistent Data Structure，直译就是“持久性数据结构”。根据<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Persistent_data_structure">Wiki定义</a>，如果一种数据结构，能保留它每一次被修改前的版本，就可以被称为“持久性数据结构”。而与之相对的就是Ephemeral Data Structure，即“暂存性数据结构”。</p>
<p>C++中，我们熟悉的数据结构大多数都属于暂存性数据结构，比如<code>std::vector</code>，当我们修改了一个<code>std::vector</code>，与之相关的所有已存在的Iterator就失效了，不能再访问了。而如果我们修改了一个持久性数据结构，我们仍然能够访问到它修改之前的版本，比如Iterator（假如有的话）不会失效，不会读到修改后的数据等。从这个角度讲，持久性数据结构也是不可变（Immutable）的。</p>
<p>什么地方需要用到持久性数据结构？</p>
<ol>
<li>函数式编程语言。它的定义就要求了不能有可变数据和可变数据结构。</li>
<li>并发编程。</li>
</ol>
<p>（另外，使用Persistent Map&#x2F;HashMap有助于简化Prototype的实现，也算是一个用途。）</p>
<p>持久性数据结构对Lazy Evaluation也很有帮助：如果一个数据结构是可变的，我们肯定不会放心对它使用Lazy Evaluation。</p>
<h2 id="Persistent-Data-Structure与并发"><a href="#Persistent-Data-Structure与并发" class="headerlink" title="Persistent Data Structure与并发"></a>Persistent Data Structure与并发</h2><p>并发编程的核心问题是竞争，即不同线程同时访问相同数据。对此我们往往需要用到一些同步手段来保证临界区的原子性，即同时只有一个线程能读出或写入相同的共享数据。</p>
<p>最常见的同步手段就是锁，但锁也会引起一大堆的问题：</p>
<ul>
<li>死锁。</li>
<li>活锁。</li>
<li>临界区太大导致性能低下。</li>
<li>错误地在临界区外访问数据导致数据竞争。</li>
<li>控制反转。</li>
<li>…</li>
</ul>
<p>另一种同步手段基于原子操作，从而实现出一套lock-free的数据结构。它的问题在于：</p>
<ul>
<li>原子操作本质上也是锁（总线锁），因此高并发度时开销还是会很大。</li>
<li>需要非常精细的实现一个lock-free的数据结构，维护难度大，且很难证明其正确性。一些久经考验的数据结构仍然可能存在bug。</li>
</ul>
<p>而当我们在不同线程间访问相同的持久性数据结构时，我们很清楚其中不会有任何的数据竞争，因为无论其他线程如何修改这个结构，当前线程看到的结构永远是不变的。这不需要异常复杂的实现和同样复杂的测试来保证。</p>
<p>可以认为通过锁和原子操作实现的并发数据结构追求的是“没有明显的错误”，而持久性数据结构则是“明显没有错误”。</p>
<p>而从性能角度，持久性数据结构也并非一定处于劣势。实现良好的持久性数据结构，通常都可以提供一种或多种操作，其时间和空间复杂度与对应的暂存性数据结构相同。且编译器针对持久性数据结构的不变性，往往能给出更优化的目标代码。</p>
<h1 id="如何实现Persistent-Data-Structure"><a href="#如何实现Persistent-Data-Structure" class="headerlink" title="如何实现Persistent Data Structure"></a>如何实现Persistent Data Structure</h1><p>想要实现一种持久性数据结构，最简单的方法就是“Copy Anything”，即每当我们修改原结构时，实际上我们都创建了一个副本，再在副本上修改。</p>
<p>当然这种方法的缺点也是很明显的：开销太大。</p>
<p>第二种方法是修改时不创建数据的副本，而是保存每次对结构的修改操作，当需要读取的时候再创建数据的副本，再在其上应用每个操作。显然这种方法在读取时的开销非常大。一种改进方案是每K个修改操作创建一次数据副本。</p>
<p>第三种方法是路径复制（Path Copy），即对于基于Node的数据结构，当我们进行修改时，我们会复制路径上经过的Node，直到最终修改发生的Node。这里我们用“构造”代替了“修改”。</p>
<p>目前最常用的实现方法就是路径复制。</p>
<h2 id="垃圾回收与引用计数"><a href="#垃圾回收与引用计数" class="headerlink" title="垃圾回收与引用计数"></a>垃圾回收与引用计数</h2><p>持久性数据结构的一个核心思想是为当前每个持有的人保留一个版本，即对于相同的数据可能同时存在多个版本。这样我们就需要有垃圾回收机制，对于每个版本的数据，在没有人持有之后回收掉。</p>
<p>对于C++而言，通常引用计数就足够了。因为持久化数据结构有一个特点：它的引用链一定是无回路的，只有新对象引用老对象，不可能有老对象引用新对象，因此单纯的引用计数就可以完全回收掉所有垃圾数据。</p>
<p>同时，这个特点对Java类的分代GC也是很有好处的。</p>
<p>有位老同志指出：对于非特定的基于引用计数的数据结构，不能使用<code>std::shared_ptr</code>，原因是它的析构是链式递归进行的，C++的编译器不一定能去掉所有的尾递归，可能会打爆栈。一种解法是从Root节点开始，收集后面所有的节点，然后循环析构。</p>
<p>为什么<code>std::map</code>可以递归析构？因为平衡树的析构链长度为lgn，假设系统的栈深度上限为100，需要<code>std::map</code>中有2^100个元素以上才会栈溢出，此时内存早就爆掉了。</p>
<h1 id="Persistent-List"><a href="#Persistent-List" class="headerlink" title="Persistent List"></a>Persistent List</h1><p>Persistent List可能是最简单的持久性数据结构。它支持两种基本操作：构造、插入头节点，即：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">List</span>();</span><br><span class="line">    <span class="built_in">List</span>(T val, List tail);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里我们使用的实现方法就是路径复制：当我们插入或删除或修改List的第N个节点时，我们需要复制前N-1个节点。</p>
<p>因此，插入或删除头节点都是O(1)的开销，而任意位置插入或删除节点则是O(n)的开销。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>以下是List的一个最简单实现，包括了支持的几个O(1)操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">        <span class="built_in">Item</span>(<span class="type">const</span> T&amp; v, <span class="type">const</span> Item* tail) : <span class="built_in">mValue</span>(v), <span class="built_in">mNext</span>(tail) &#123;&#125;</span><br><span class="line">        T mValue;</span><br><span class="line">        <span class="type">const</span> Item* mNext;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">List</span><span class="params">(<span class="type">const</span> Item* item)</span>: mHead(item) &#123;</span>&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">List</span>(): <span class="built_in">mHead</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">List</span>(<span class="type">const</span> T&amp; val, List tail): <span class="built_in">mHead</span>(<span class="keyword">new</span> <span class="built_in">Item</span>(val, tail.mHead)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mHead == <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">Front</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(mHead);</span><br><span class="line">        <span class="keyword">return</span> *mHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List <span class="title">PushFront</span><span class="params">(<span class="type">const</span> T&amp; val)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">List</span>(val, mHead);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List <span class="title">PopFront</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">List</span>(mHead-&gt;mNext);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> Item* mHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到这个实现中还没有任何引用计数有关的代码。我们有两种方式来实现引用计数：</p>
<ol>
<li>使用<code>std::shared_ptr</code>，这样只需要把每个使用<code>const Item*</code>的地方都换成<code>std::shared_ptr&lt;const Item&gt;</code>即可。</li>
<li>自己实现一种侵入式的引用计数基类<code>Reference</code>，并令<code>Item</code>继承自它。</li>
</ol>
<h2 id="其它列表操作"><a href="#其它列表操作" class="headerlink" title="其它列表操作"></a>其它列表操作</h2><p>当我们拥有了一个持久性的List后，我们就可以在其上实现一套函数式的操作：</p>
<ul>
<li>fmap</li>
<li>filter</li>
<li>foldl&#x2F;foldr</li>
<li>forEach</li>
</ul>
<p>实现<a target="_blank" rel="noopener" href="https://github.com/BartoszMilewski/Okasaki/blob/master/SimpleList/ListGC.h">戳这里</a>。</p>
<h1 id="Persistent-Map"><a href="#Persistent-Map" class="headerlink" title="Persistent Map"></a>Persistent Map</h1><p>Persistent Map的实现也是基于路径复制的。算法导论上有这么一道习题，清晰的体现了它的实现思路：</p>
<p><img src="/images/2020-11/persistent-data-structure-01.png" alt="Persistent Map"></p>
<p>当我们插入或删除一个节点时，路径上的每个节点都需要被复制一次，因此这样的操作的开销是O(lgn)的。</p>
<p>插入操作是很简单的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">Insert</span><span class="params">(Node* root, <span class="type">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;mValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(root-&gt;mValue, <span class="built_in">Insert</span>(root-&gt;mLeft, val), root-&gt;mRight);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;mValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(root-&gt;mValue, root-&gt;mLeft, <span class="built_in">Insert</span>(root-&gt;mRight, val));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除操作有些麻烦，需要处理删除的节点有子节点的情况。原则就是：用构造代替所有的修改。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">Delete</span><span class="params">(Node* root, <span class="type">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;mValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(root-&gt;mValue, <span class="built_in">Delete</span>(root-&gt;mLeft, val), root-&gt;mRight);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;mValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(root-&gt;mValue, root-&gt;mLeft, <span class="built_in">Delete</span>(root-&gt;mRight, val));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;mLeft) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;mRight;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;mRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;mLeft;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node* leftMost;</span><br><span class="line">            <span class="built_in">tie</span>(leftMost, root-&gt;mRight) = <span class="built_in">RemoveLeftMost</span>(root-&gt;mRight);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(leftMost-&gt;mValue, root-&gt;mLeft, root-&gt;mRight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：以上代码均未考虑垃圾回收。</p>
<p>对于红黑树而言，每次它平衡时，同样要复制涉及到的节点。每次平衡最多涉及3个节点，因此平衡的开销是O(1)。</p>
<p>实现<a target="_blank" rel="noopener" href="https://github.com/BartoszMilewski/Okasaki/blob/master/RBTree/RBTree.h">戳这里</a>。不过这个实现没有删除功能。</p>
<h1 id="Persistent-Vector"><a href="#Persistent-Vector" class="headerlink" title="Persistent Vector"></a>Persistent Vector</h1><p>Persistent Vector的基本思想与Persistent Map非常接近：你把Persistent Vector想象成以下标为Key的Map即可：</p>
<p><img src="/images/2020-11/persistent-data-structure-02.png" alt="Basic Persistent Vector"></p>
<p>图中就是一个这样的Map，它有如下特点：</p>
<ol>
<li>分为内部节点和叶节点两类，其中数据都在叶节点上。</li>
<li>所有叶节点的高度相同。</li>
<li>每个内部节点有两个子节点。</li>
<li>每层节点中，只有最后一个节点有可能是半满的，其它节点都是满的。</li>
</ol>
<p>当然这样的实现效率是很低的，每次Update、PushBack的时间复杂度是O(lgn)。因此实践上我们会使用类似于Trie树的结构，即每个节点能容纳多于两个子节点，通常为32个，这样一个6层的Map就可以容纳最多1073741824个元素，每次Update、PushBack最多需要复制6个节点，可以认为变成了一次O(1)操作。</p>
<p>查找：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">Get</span><span class="params">(Node* root, <span class="type">int32_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!root-&gt;<span class="built_in">IsLeaf</span>()) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int32_t</span> mask = root-&gt;<span class="built_in">Mask</span>();</span><br><span class="line">        root = root-&gt;<span class="built_in">Get</span>(index / mask);</span><br><span class="line">        index %= mask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">const</span> T*)root-&gt;<span class="built_in">Get</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="保留Tail节点来提高PushBack性能"><a href="#保留Tail节点来提高PushBack性能" class="headerlink" title="保留Tail节点来提高PushBack性能"></a>保留Tail节点来提高PushBack性能</h2><p>想想一个Persistent Vector执行PushBack的时候都发生了什么？从Root开始，一直复制到Tail叶节点。原因是当我们复制了一个子节点，我们就需要修改它的父节点，根据“修改即构造”原则，就需要重新构造一个父节点，从而一直到Root都要构造一遍。</p>
<p>那么，假如Persistent Vector直接持有Tail节点呢？这样当它未满时，PushBack只要复制两个节点：Tail节点和Vector本身。当Tail节点已满时，我们才需要真正做一次PushBack。对于32个子节点的Persistent Vector来说，有31&#x2F;32的PushBack是真正的O(1)操作，其它1&#x2F;32的PushBack才需要O(lgn)。</p>
<p><img src="/images/2020-11/persistent-data-structure-03.png" alt="Tail"></p>
<p>新的查找也很简单。为了配合查找，我们要记录下Tail节点的offset：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> lookup_index &lt; tail_offset:</span><br><span class="line">  <span class="comment"># tree_lookup = old lookup technique</span></span><br><span class="line">  <span class="keyword">return</span> tree_lookup(lookup_index)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="keyword">return</span> tail[lookup_index - tail_offset]</span><br></pre></td></tr></table></figure>

<h2 id="Transient"><a href="#Transient" class="headerlink" title="Transient"></a>Transient</h2><p>当我们要对Persistent Vector进行一系列修改时，每次Update&#x2F;PushBack&#x2F;PopBack都要复制lgn节点，即使有了Tail节点优化，也只能对PushBack和PopBack有一定的效果。问题在于，我们即使每个操作都复制了一个新节点，下次操作这个节点时还是要再复制，因为我们要保证不破坏其它人的使用。那么什么时候可以直接重用这个节点，不用复制呢？</p>
<ol>
<li>只能被当前Vector访问到的节点。</li>
<li>当前Vector在这次操作后不会被其它人使用。</li>
</ol>
<p>对于条件1，很好解决：我们每次修改Vector时都申请一个UUID，并放到这次修改创建的节点中，这样通过UUID就能判断节点是不是当前Vector创建出来的。</p>
<p>对于条件2，我们没有办法阻止用户在所有修改完成之前使用这个Vector。因此我们使用一个新类型Transient来进行批量修改。好处：显式的让用户知道，我们要做一些不一样的事情啦，在它结束之前不要访问这个Vector。</p>
<p>在批量修改结束之后，还需要一个操作来把Transient变为Persistent，这步操作会把每个节点中的ID置为NULL，保证合法的Vector的节点没有ID，从而避免一个Transient被误用。</p>
<h1 id="Persistent-HashMap"><a href="#Persistent-HashMap" class="headerlink" title="Persistent HashMap"></a>Persistent HashMap</h1><p>当我们有了一个Persistent Vector的实现之后，实现一个Persistent HashMap也就不困难了。</p>
<p>一个HashMap是什么？如果我们使用分桶链表来实现HashMap，它就是一个Vector，其中每个元素是一个List。那么我们可以用Persistent Vector + Persistent List来实现Persistent HashMap。如果我们使用开放散列法来实现HashMap，它就是单纯的一个Vector，只要用Persistent Vector来实现就可以了。</p>
<h1 id="Persistent-Data-Structure的一个使用场景"><a href="#Persistent-Data-Structure的一个使用场景" class="headerlink" title="Persistent Data Structure的一个使用场景"></a>Persistent Data Structure的一个使用场景</h1><p>想象我们有一个UserMap，保存每个UserID和对应的NickName。有两种操作：</p>
<ul>
<li>NewUser：增加一对新的UserID和NickName。</li>
<li>Update：修改已有UserID对应的NickName。</li>
</ul>
<p>现在我们用一个Persistent HashMap作为UserMap。有若干个前台线程可以访问和修改UserMap。</p>
<p>最简单的做法：</p>
<ol>
<li>前台线程获得当前UserMap，称为M0。</li>
<li>前台线程修改UserMap，得到M1。</li>
<li>前台线程将M0替换为M1，原有的M0析构。</li>
</ol>
<p>只有一个前台线程时，这种用法是没什么问题的。但当我们有多个前台线程时，就会有问题：</p>
<ol>
<li>线程T1获得M0。</li>
<li>线程T2获得M0。</li>
<li>线程T1修改M0，得到M1。</li>
<li>线程T2修改M0，得到M2。</li>
<li>线程T1将M0替换为M1。</li>
<li>线程T2将M1替换为M2。</li>
</ol>
<p>结果就是丢了一次数据！实际上这就是一个很经典的RMW操作，先Read，再本地Modify，再Write写回。对于RMW操作，必不可少的操作就是CompareAndExchange，也就是在Write时比较一下原对象有没有在你的Read之后被修改过。如果有的话，需要重试整个RMW操作。</p>
<p>在我们这个场景中，我们需要做的就是每个线程在替换UserMap时确认一下UserMap的最后修改时间是否与自己手上持有的M0的修改时间相同，如果相同才能完成替换，否则就整个操作重来。这种先确认数据是否冲突再写入的操作，就是一种很典型的Transaction。因此我们可以使用STM（Software Transactional Memory）来更规范的使用UserMap：</p>
<ol>
<li>线程创建Transaction t。</li>
<li>线程通过t获得M0。</li>
<li>线程通过t修改M0，得到M1。</li>
<li>线程通过t替换UserMap为M1。</li>
</ol>
<p>这个过程中，如果有数据冲突，根据STM的实现不同，可能在不同的地方失败，只有当没有数据冲突时，整个操作才能顺利走下去。</p>
<p>可以看到，当我们使用Persistent Data Structure时，数据冲突的概率决定了它的使用是否高效。上面的例子中，对于全局唯一的UserMap，如果有大量的修改操作同时进行，那么其中只会有非常少量的操作能成功，其它操作都会因为数据冲突而失败。那么我们在使用时，就要考虑能否减少UserMap的粒度，从而降低冲突概率，提高性能。比如，我们将UserMap分成4096个桶，每个桶是一个Persistent HashMap，那么冲突概率就会小很多，整体性能就上去了。</p>
<p>当然，在分桶后，如果有涉及多个UserID的操作，我们就需要一次性原子的替换多个UserMap。这不是一件容易的事情，幸好，STM就是干这个的。这也说明Persistent Data Structure和STM确实是好朋友。</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a target="_blank" rel="noopener" href="http://hypirion.com/musings/understanding-persistent-vector-pt-1">Understanding Clojure’s Persistent Vectors, pt. 1</a></li>
<li><a target="_blank" rel="noopener" href="http://hypirion.com/musings/understanding-persistent-vector-pt-2">Understanding Clojure’s Persistent Vectors, pt. 2</a></li>
<li><a target="_blank" rel="noopener" href="http://hypirion.com/musings/understanding-persistent-vector-pt-3">Understanding Clojure’s Persistent Vectors, pt. 3</a></li>
<li><a target="_blank" rel="noopener" href="http://hypirion.com/musings/understanding-clojure-transients">Understanding Clojure’s Transients</a></li>
<li><a target="_blank" rel="noopener" href="http://hypirion.com/musings/persistent-vector-performance-summarised">Persistent Vector Performance Summarised</a></li>
<li><a target="_blank" rel="noopener" href="https://bartoszmilewski.com/2013/11/13/functional-data-structures-in-c-lists/">Functional Data Structures in C++: Lists</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice">Understanding Clojure’s PersistentHashMap</a></li>
<li><a target="_blank" rel="noopener" href="https://gotocon.com/dl/goto-amsterdam-2012/slides/KarlKrukow_IntroductionToConcurrencyandDataStructuresInClojure.pdf">Intro to Clojure data structures</a></li>
<li><a target="_blank" rel="noopener" href="https://kunigami.blog/2017/03/18/amortization-and-persistence-via-lazy-evaluation/">Amortization and Persistence via Lazy Evaluation</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/rsms/immutable-cpp">GitHub: Immutable Array via C++</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1536953/recommend-a-fast-scalable-persistent-map-java">Recommend a fast &amp; scalable persistent Map - Java</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2017/10/29/cpp-type-erasure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/29/cpp-type-erasure/" class="post-title-link" itemprop="url">C++: Type Erasure</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-29 17:26:20" itemprop="dateCreated datePublished" datetime="2017-10-29T17:26:20+08:00">2017-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Type Erasure，直译就是“类型擦除”。什么时候需要擦除类型？当我们想令一些代码具备多态性质时，我们往往没办法保留对象本身的类型，而需要用一种通用的类型去使用它们，这个时候，就需要擦除对象原有的类型。</p>
<h1 id="Type-Erasure的几种形式"><a href="#Type-Erasure的几种形式" class="headerlink" title="Type Erasure的几种形式"></a>Type Erasure的几种形式</h1><h2 id="void"><a href="#void" class="headerlink" title="void*"></a><code>void*</code></h2><p>在C语言中，很多通用算法函数都会使用<code>void*</code>作为参数类型，比如<code>qsort</code>，它的原型是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span> <span class="params">(<span class="type">void</span>* base, <span class="type">size_t</span> num, <span class="type">size_t</span> size, <span class="type">int</span> (*compare)(<span class="type">const</span> <span class="type">void</span>*,<span class="type">const</span> <span class="type">void</span>*))</span>;</span><br></pre></td></tr></table></figure>

<p>为了使<code>qsort</code>有处理多种类型的能力，它只能把参数类型设为<code>void*</code>，这样我们可以用同一个<code>qsort</code>函数，处理各种各样的类型。代价就是对象原有的类型被擦除了，我们只能看到<code>void*</code>。</p>
<p>这种方法的缺点是，它不能保证类型安全。当我们擦除了一个对象的类型后，总会在某个时刻需要把它再找回来的。在<code>qsort</code>中，我们总是需要能拿到对象的正确类型的，才能进行正确的排序。而这个工作是通过<code>compare</code>完成的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">int_compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">const</span> <span class="type">int</span>*)a - *(<span class="type">const</span> <span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">str_compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)a, (<span class="type">const</span> <span class="type">char</span>*)b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们传递了错误的<code>compare</code>，谁能知道这件事？编译器不知道，因为你把类型擦除掉了。你自己也不知道，因为代码就是你写的。测试程序可能知道，也可能不知道，因为这个时候程序的行为是未定义的。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在面向对象语言中，继承是最常见的Type Erasure。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Increase</span><span class="params">(<span class="type">int</span> v)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Decrease</span><span class="params">(<span class="type">int</span> v)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Value</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(Counter c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldValue</span> <span class="operator">=</span> c.Value();</span><br><span class="line">        <span class="keyword">while</span> (c.Value() != <span class="number">0</span>) &#123;</span><br><span class="line">            c.Decrease(<span class="number">1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        Assert.assertEqual(count, oldValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在<code>Test.down</code>中，我们只知道<code>c</code>的类型是<code>Counter</code>，但不知道它是哪个实现类型，这里它的类型就被擦除了。</p>
<p>继承当然是比<code>void*</code>要好的，因为我们操作对象时调用的是对象具体的实现API，换句话说，我们只擦除了调用处对象的类型，实际上它并没有丢掉自己的类型，也保证了类型安全性。</p>
<p>继承的问题在于，它的侵入性，即它要求每个实现类型都继承自某个基类。在很多情况下，这是很难做到的，或者是很别扭的。</p>
<p>比如说<code>RedApple</code>，一个红色的苹果，当我们想使用“红色”这个泛型概念时，它需要实现<code>Red</code>这个接口；而当我们想使用“苹果”这个概念时，它又需要实现<code>Apple</code>这个接口。某天当我们想使用“类球形”这个概念时，它又要实现<code>RoundLike</code>接口吗？</p>
<p>当接口一个又一个的出现时，有人会说，干脆我们到处传递<code>Object</code>吧，用的时候再down_cast成具体的类型。于是我们又回到了<code>void*</code>的时代。</p>
<p>尤其是，有些类型我们是没有办法改的，比如三方库中定义的类型，比如内置类型。这些情况下，继承就无能为力了。</p>
<h2 id="Duck-Typing和Template"><a href="#Duck-Typing和Template" class="headerlink" title="Duck Typing和Template"></a>Duck Typing和Template</h2><p>如果一个东西，走路像鸭子，叫声也像鸭子，那么它就是鸭子。换句话说，如果一个东西，满足我们对鸭子的所有要求，那么它就是鸭子。如果一个<code>T</code>，满足我们对<code>X</code>的所有要求，那么它就是<code>X</code>。这就是duck typing，即鸭子类型。</p>
<p>Python中大量应用了duck typing：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RedApple</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">color</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">round_like</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">map_by_color</span>(<span class="params">items</span>):</span><br><span class="line">    ret = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        ret[item.color()].append(item)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">color_map = map_by_color([..., RedApple(), ...])</span><br></pre></td></tr></table></figure>

<p>在<code>map_by_color</code>中，我们对<code>items</code>有两项要求：</p>
<ol>
<li>可遍历。</li>
<li>其中每个元素都有<code>color</code>方法。</li>
</ol>
<p>但不要求<code>items</code>或其中每个<code>item</code>继承自哪个特定的接口。</p>
<p>这也是Type Erasure，但明显比继承来得更自由。当然自由都是有代价的，duck typing的代价就是它的运行时性能损失。Python中每个对象都会保留自己的类型信息，在调用时进行动态绑定。Go的<code>interface</code>有着类似的用法，也有着类似的优缺点。</p>
<p>C++的模板也是一种duck typing：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CountByColor</span><span class="params">(<span class="type">const</span> C&amp; container, Color color)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item: container) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.<span class="built_in">Color</span>() == color) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面有个模板参数<code>C</code>，我们对它的要求是：</p>
<ol>
<li>可遍历，具体来说是支持<code>begin(container)</code>和<code>end(container)</code>两种API。</li>
<li>遍历出来的每个元素有<code>T Color() const</code>方法，且<code>T</code>与<code>Color</code>类型有合适的<code>operator==</code>函数存在。</li>
</ol>
<p>所有满足这个条件的<code>C</code>都可以作为<code>CountByColor</code>的参数类型。</p>
<p>当然C++的模板与Python的duck typing还是有很大区别的，因为它并没有真的擦除掉元素类型：<code>C</code>是<code>CountByColor</code>原型的一部分。这样我们其实一直都保留着元素的具体类型信息，好处：</p>
<ol>
<li>完整的类型安全性，没有任何环节丢掉了类型信息。</li>
<li>因此不需要动态绑定，所有环节都是静态的，没有运行时性能损失。</li>
</ol>
<p>但也有坏处：</p>
<ol>
<li>模板类型会作为模板函数或模板类的原型的一部分，即<code>vector&lt;int&gt;</code>和<code>vector&lt;double&gt;</code>是两个类型，没办法用一个类型来表示，也就没办法实现出上面Python例子中的<code>map_by_color</code>函数。</li>
<li>每次用不同的参数类型来实例化模板时，都会新生成一份代码，导致编译出来的二进制文件很大。</li>
</ol>
<h2 id="C-中结合继承与Template的Type-Erasure"><a href="#C-中结合继承与Template的Type-Erasure" class="headerlink" title="C++中结合继承与Template的Type Erasure"></a>C++中结合继承与Template的Type Erasure</h2><p>在C++中我们可以结合继承与Template，实现出一种Type Erasure，它既有duck typing的优点，又可以将不同类型用同一种类型表示。</p>
<p>假设我们现在要重新设计上面的<code>Counter</code>接口，首先我们定义一个内部的基类，<code>Counter</code>的每个方法都对应它的一个虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CounterBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~CounterBase &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Increase</span><span class="params">(<span class="type">int</span> v)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Decrease</span><span class="params">(<span class="type">int</span> v)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Count</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们使用模板实现一个通用的子类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CounterImpl</span>: <span class="keyword">public</span> CounterBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CounterImpl</span><span class="params">(T t)</span>: mImpl(std::move(t)) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Increase</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mImpl.<span class="built_in">Increase</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Decrease</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mImpl.<span class="built_in">Decrease</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mImpl.<span class="built_in">Count</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T mImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后我们还要定义一个<code>Counter</code>类型，但它不需要有任何的虚函数，也不需要作为任何类型的基类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">Counter</span>(T t): <span class="built_in">mPtr</span>(<span class="keyword">new</span> <span class="built_in">CounterImpl</span>(std::forward&lt;T&gt;(t))) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Increase</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        mPtr-&gt;<span class="built_in">Increase</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Decrease</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        mPtr-&gt;<span class="built_in">Decrease</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mPtr-&gt;<span class="built_in">Count</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;CounterBase&gt; mPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以使用<code>Counter</code>来表示所有满足条件的类型了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Counter <span class="title">c1</span><span class="params">(ClassA&#123;&#125;)</span></span>;</span><br><span class="line"><span class="function">Counter <span class="title">c2</span><span class="params">(ClassB&#123;<span class="number">5</span>&#125;)</span></span>;</span><br><span class="line">Counter c3 = ClassC&#123;<span class="number">3</span>, <span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>对于没有<code>Increase</code>、<code>Decrease</code>、<code>Count</code>接口的类型，比如内置类型<code>int</code>，我们还可以特化模板来满足要求：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CounterImpl</span>&lt;<span class="type">int</span>&gt;: <span class="keyword">public</span> CounterBase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CounterImpl</span><span class="params">(<span class="type">int</span> v)</span>: mValue(v) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Increase</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mValue += v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Decrease</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mValue -= v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mValue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Counter c = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>是不是很赞？</p>
<h1 id="C-中Type-Erasure的例子"><a href="#C-中Type-Erasure的例子" class="headerlink" title="C++中Type Erasure的例子"></a>C++中Type Erasure的例子</h1><h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p>我们知道<code>std::shared_ptr</code>的Deleter不是<code>std::shared_ptr</code>类型的一部分（参见<a href="/2017/05/19/cpp-different-role-of-deleter-in-unique-ptr-and-shared-ptr/">为什么unique_ptr的Deleter是模板类型参数，而shared_ptr的Deleter不是</a>），这给使用者带来了很多好处（相比<code>std::unique_ptr</code>）：</p>
<ul>
<li>对于<code>std::shared_ptr&lt;T&gt;</code>，使用者不需要知道<code>T</code>的完整类型（当然创建者需要）。</li>
<li>两个<code>std::shared_ptr&lt;T&gt;</code>对象类型相同，可以相互赋值，即使它们的Deleter类型不同。</li>
<li>销毁<code>T</code>使用的Deleter永远是来自创建<code>std::shared_ptr</code>的编译单元，跨DLL和so使用时不会有销毁问题。</li>
</ul>
<p>它的秘诀就是Type Erasure。参考clang的实现，<code>std::shared_ptr</code>只有两个成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Tp* __ptr__;</span><br><span class="line">    __shared_weak_count* __cntrl__;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>__shared_weak_count</code>的定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">__shared_weak_count</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到不包含Deleter的类型。实际上构造的类型是它的子类<code>__shared_ptr_pointer</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Dp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__shared_ptr_pointer</span>: <span class="keyword">public</span> __shared_weak_count;</span><br></pre></td></tr></table></figure>

<p>具体的实现略。可以看到这里就使用了我们上面提到的继承与Template结合的方法。</p>
<h2 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h2><p><code>std::function</code>中使用了一个基类<code>__base</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> ..._ArgTypes&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__base</span>&lt;_Rp(_ArgTypes...)&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> _Rp <span class="title">operator</span><span class="params">()</span><span class="params">(_ArgTypes&amp;&amp; ...)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样地，具体的子类通过模板来保留类型信息，而通过基类来实现统一的存储与调用。</p>
<h2 id="boost-any"><a href="#boost-any" class="headerlink" title="boost::any"></a>boost::any</h2><p><code>boost::any</code>是非常典型的应用了Type Erasure方法的类型。它允许你用一种类型来保存任何类型的对象，且通过<code>type_info</code>方法返回具体的对象类型。这样我们可以使用一个<code>boost::any</code>的容器保存任意类型的对象。它的实现很短，只有313行，很值得看一下。</p>
<h2 id="std-any"><a href="#std-any" class="headerlink" title="std::any"></a>std::any</h2><p><code>std::any</code>是C++17引入的新类型，与<code>boost::any</code>的接口几乎完全相同，区别在于，它使用了SBO(Small Buffer Optimization)方法，可以把小对象直接构造在类型内部，性能更好。</p>
<h2 id="基于Type-Erasure实现Unified-Call-Syntax"><a href="#基于Type-Erasure实现Unified-Call-Syntax" class="headerlink" title="基于Type Erasure实现Unified Call Syntax"></a>基于Type Erasure实现Unified Call Syntax</h2><p>假设我们想实现一个接口类型<code>Fooable</code>，它有一个方法<code>foo</code>，使得<code>Fooable::foo</code>和<code>foo(Fooable)</code>都可以用来表示<code>T::foo</code>和<code>foo(T)</code>两种调用方式，即：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NonMember</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> NonMember&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">Fooable member_erased &#123;Member&#123;&#125;&#125;;</span><br><span class="line"><span class="built_in">foo</span>(member_erased);</span><br><span class="line">member_erased.<span class="built_in">foo</span>();</span><br><span class="line"></span><br><span class="line">Fooable non_member_erased &#123;non_member&#123;&#125;&#125;;</span><br><span class="line"><span class="built_in">foo</span>(non_member_erased);</span><br><span class="line">non_member_erased.<span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure>

<p>第一步我们先定义基类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二步定义模板子类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">bool</span> HasMemberFoo = has_member_foo&lt;T&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> StorageImpl: Storage &#123;</span><br><span class="line">   T <span class="type">m_t</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">StorageImpl</span> (T t): <span class="type">m_t</span> &#123;std::<span class="built_in">move</span>(t)&#125; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="type">m_t</span>.<span class="built_in">foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>has_member_foo</code>是用来判断<code>T::foo</code>是否存在的辅助类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> has_member_foo: std::false_type&#123;&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_member_foo</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">foo</span>())&gt;&gt; : std::true_type&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>当<code>T::foo()</code>是个合法的表达式时，<code>has_member_foo&lt;T&gt;::value</code>就是<code>true</code>，否则就是<code>false</code>。</p>
<p>然后我们为<code>false</code>准备一个特化版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StorageImpl</span>&lt;T, <span class="literal">false</span>&gt; : Storage &#123;</span><br><span class="line">    T <span class="type">m_t</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">StorageImpl</span> (T t) : <span class="type">m_t</span> &#123;std::<span class="built_in">move</span>(t)&#125; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">foo</span>(<span class="type">m_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后实现<code>Fooable</code>类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fooable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">Fooable</span> (T t) </span><br><span class="line">        : m_storage &#123;std::make_unique&lt;StorageImpl&lt;T&gt;&gt;(std::<span class="built_in">move</span>(t))&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; m_storage-&gt;<span class="built_in">call</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Storage&gt; m_storage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(Fooable&amp; f)</span> </span>&#123; f-&gt;<span class="built_in">foo</span>(); &#125;</span><br></pre></td></tr></table></figure>

<h1 id="什么时候使用Type-Erasure"><a href="#什么时候使用Type-Erasure" class="headerlink" title="什么时候使用Type Erasure"></a>什么时候使用Type Erasure</h1><p>简单来说，如果你有下面两个需求，你可能是需要Type Erasure的：</p>
<ul>
<li>你需要用同一种方式处理不同的类型。</li>
<li>你需要用同一种类型或容器保存不同类型的对象。</li>
</ul>
<p>然而在很多情况下，你可能只需要用<code>std::shared_ptr</code>或<code>std::function</code>就能达到这个目的，这个时候就不需要自己实现Type Erasure了。</p>
<h1 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h1><ul>
<li><a target="_blank" rel="noopener" href="http://www.cplusplus.com/articles/oz18T05o/">C++ type erasure</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Erasure">More C++ Idioms&#x2F;Type Erasure</a></li>
<li><a target="_blank" rel="noopener" href="http://davekilian.com/cpp-type-erasure.html">C++ ‘Type Erasure’ Explained</a></li>
<li><a target="_blank" rel="noopener" href="http://aherrmann.github.io/programming/2014/10/19/type-erasure-with-merged-concepts/">Type Erasure with Merged Concepts</a></li>
<li><a target="_blank" rel="noopener" href="http://nullprogram.com/blog/2014/04/01/">Duck Typing vs. Type Erasure</a></li>
<li><a target="_blank" rel="noopener" href="https://akrzemi1.wordpress.com/2013/11/18/type-erasure-part-i/">Type erasure — Part I</a></li>
<li><a target="_blank" rel="noopener" href="https://akrzemi1.wordpress.com/2013/12/06/type-erasure-part-ii/">Type erasure — Part II</a></li>
<li><a target="_blank" rel="noopener" href="https://akrzemi1.wordpress.com/2013/12/11/type-erasure-part-iii/">Type erasure — Part III</a></li>
<li><a target="_blank" rel="noopener" href="https://akrzemi1.wordpress.com/2014/01/13/type-erasure-part-iv/">Type erasure — Part IV</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5450159/type-erasure-techniques">Type erasure techniques</a></li>
<li><a target="_blank" rel="noopener" href="https://a4z.bitbucket.io/blog/2017/01/11/exterm_typererasure-using-std::function.html">Extreme type erasure via std::function</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2017/10/26/effective-modern-cpp-chapter8-iterm41-42/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/26/effective-modern-cpp-chapter8-iterm41-42/" class="post-title-link" itemprop="url">Effective Modern C++ 笔记 Chapter8: 杂项 (Item 41-42)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-26 23:24:18" itemprop="dateCreated datePublished" datetime="2017-10-26T23:24:18+08:00">2017-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本章介绍一种通用技术（传值调用）和一种通用特性（原地构造），它们都受到多种因素的影响，作者能给的建议只是“考虑用一下”，实践上要根据具体情况来定。</p>
<h2 id="Item41：对于可复制的、移动非常廉价、总是复制的参数，考虑调用时传值"><a href="#Item41：对于可复制的、移动非常廉价、总是复制的参数，考虑调用时传值" class="headerlink" title="Item41：对于可复制的、移动非常廉价、总是复制的参数，考虑调用时传值"></a>Item41：对于可复制的、移动非常廉价、总是复制的参数，考虑调用时传值</h2><p>有些函数参数就是要被复制的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span> </span>&#123;</span><br><span class="line">        names.<span class="built_in">push_back</span>(newName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::string&gt; names;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的两个函数一个处理左值，一个处理右值，但实际上它们的逻辑都是一样的，但我们写了两个函数，两个实现。</p>
<p>假如你想用普适引用来代替上面两个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        names.<span class="built_in">push_back</span>(std::forward&lt;T&gt;(newName));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码省掉了一份，但又导致了其它问题。作为模板函数，<code>addName</code>需要放到头文件里。而且它不一定只有两个实例化版本（左值和右值），所有可以用于构造<code>std::string</code>的类型都可能会实例化一个版本（参见Item25）。同时，还有一些参数类型没办法使用普适引用（参见Item30）。如果调用方传递错类型，编译错误信息会非常恐怖（参见Item27）。</p>
<p>一种方法可以让我们只写一个函数，且没有普适引用的各种问题：参数直接传值，不使用引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addname</span><span class="params">(std::string newName)</span> </span>&#123;</span><br><span class="line">        names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个版本中，我们知道：</p>
<ol>
<li><code>newName</code>与实参没有关系，因此如何修改<code>newName</code>都不会影响到实参。</li>
<li>这是<code>newName</code>最后一次被使用，因此移动它不会影响到后面程序的运行。</li>
</ol>
<p>我们只需要写一个函数，因此：</p>
<ol>
<li>避免了代码重复，包括源代码和目标代码。</li>
<li>没用普适引用，因此不会污染头文件，不会导致奇怪的运行失败或编译错误。</li>
</ol>
<p>但它的开销如何？</p>
<p>当实参是左值时，实参到形参<code>newName</code>会有一次复制。但当实参是右值时，<code>newName</code>的构造会使用移动构造函数，因此它的构造开销是一次移动。后面构造<code>names</code>中的元素时，无论实参是左值还是右值，都是一次移动。</p>
<p>因此上面的方法中，当实参是左值时，开销是一次复制+一次移动；当实参是右值时，开销是两次移动。对比原来的重载版本，当实参是左值时，开销是一次复制；当实参是右值时，开销是一次移动。因此传值方法会比重载方法多一次移动的开销。</p>
<p>对于普适引用版本，情况有点复杂。当<code>T</code>是可以用于构造<code>std::string</code>时，普适引用在实参到形参中不会有对象构造，而是直接使用实参去构造<code>names</code>中的元素。本节我们不考虑这种情况，只假设实参是<code>std::string</code>，那么普适引用版本的开销与重载版本相同。</p>
<p>回头看一下标题，“对于可复制的、移动非常廉价、总是复制的参数，考虑调用时传值”：</p>
<ol>
<li><p>你只能是考虑要不要用传值方法。它确实有很多优点，但它也确实比其它版本多一次移动的开销。一些场景下（后面会讨论），这次开销不可忽视。</p>
</li>
<li><p>只能对可复制的参数使用传值方法。对于只能移动的类型，我们只能移动构造形参，就不存在需要写两个重载版本的问题，也就不需要使用传值方法了：直接传右值引用多简单。</p>
</li>
<li><p>传值方法只适用于“移动非常廉价”的类型。</p>
</li>
<li><p>只有当参数的复制不可避免时，才需要考虑传值方法。假如有某个分支下我们不需要复制参数，那么重载版本就不需要复制参数，而传值版本在调用那一刻已经复制完了，没办法省掉。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string newName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((newName.<span class="built_in">length</span>() &gt;= minLen) &amp;&amp; (newName.<span class="built_in">length</span>() &lt;= maxLen)) &#123;</span><br><span class="line">            names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>即使上面三个条件都满足，也有场景不适用于传值方法。我们说复制时，不光是复制构造，还有复制赋值。考虑到这点，开销分析就更复杂了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Password</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Password</span><span class="params">(std::string pwd)</span></span></span><br><span class="line"><span class="function">        : text(std::move(pwd)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeTo</span><span class="params">(std::string newPwd)</span> </span>&#123;</span><br><span class="line">        text = std::<span class="built_in">move</span>(newPwd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>构造<code>Password</code>显然是可以用传值方法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">initPwd</span><span class="params">(<span class="string">&quot;Supercalifragilisticexpialidocious&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Password <span class="title">p</span><span class="params">(initPwd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>但在调用<code>changeTo</code>时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string newPassword = <span class="string">&quot;Beware the Jabberwock&quot;</span>;</span><br><span class="line">p.<span class="built_in">changeTo</span>(newPassword);</span><br></pre></td></tr></table></figure>

<p><code>newPassword</code>是左值，因此<code>newPwd</code>要进行复制构造，这里会分配内存。之后<code>newPwd</code>移动赋值给<code>text</code>时，<code>text</code>会释放自己原有的内存块，转而使用<code>newPwd</code>持有的内存块。因此<code>changeTo</code>有两次内存操作，一次分配，一次释放。</p>
<p>但我们这个例子中，旧密码比新密码长，因此如果我们使用重载方法，就不会有内存分配或释放（直接复制到旧密码的内存块上）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Password::ChangeTo</span><span class="params">(<span class="type">const</span> std::string&amp; newPwd)</span> </span>&#123;</span><br><span class="line">    text = newPwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此在这个例子中，传值版本比重载版本的开销多了两次内存操作，很可能比字符串的移动开销大一个数量级。</p>
<p>但在旧密码比新密码短的例子中，重载版本也没办法避免掉两次内存操作，这时传值方法的优势又回来了。</p>
<p>以上分析只针对实参为左值的情况，当实参为右值时，移动总是更好的。</p>
<p>由此可以看出，当有赋值时，可能影响结论的因素太多了，比如<code>Password</code>这个例子中<code>std::string</code>是否使用了SSO优化也会影响我们的结论。</p>
<p>实践中通常采用“有罪推定”原则，即优先使用重载方法或普适引用方法，直到传值方法显示出它的优势。对于那些对性能有极致要求的软件，传值方法就不太合适了。首先，多出的一次移动的开销可能很重要；其次，很难确定到底多了几次移动。假设我们构造链路上有N层，有可能每层的构造都使用了传值方法，看起来简单的一次构造实际上多了N次移动的开销。而且我们还很难发现这件事。</p>
<p>传值方法的另一个问题，是当有继承的时候，传值可能引发“切片问题”。当形参是基类而实参是派生类型时，实参到形参的构造会丢掉派生类型多出的部分，最终只得到一个基类对象。而传引用就不会有这个问题。这也是C++98中传值不被接受的一个原因。</p>
<h2 id="Item42-考虑用原地构造替代插入"><a href="#Item42-考虑用原地构造替代插入" class="headerlink" title="Item42: 考虑用原地构造替代插入"></a>Item42: 考虑用原地构造替代插入</h2><p>假设我们有一个容器，元素类型是<code>std::string</code>。当我们向这个容器插入一个新元素时，新元素的类型是什么？直觉告诉我们，新元素的类型就是<code>std::string</code>。</p>
<p>但直觉不总是对的。看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vs;</span><br><span class="line">vs.<span class="built_in">push_back</span>(<span class="string">&quot;xyzzy&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里，我们插入的新元素类型不是<code>std::string</code>，而是<code>char[6]</code>或<code>char*</code>。<code>std::vector</code>有两个版本的<code>push_back</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">void</span> <span class="built_in">push_back</span>(<span class="type">const</span> T&amp; x);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; x)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当编译器发现实参类型与形参类型不匹配时，它会生成一些代码，构造一个临时的<code>std::string</code>对象，效果类似于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(<span class="string">&quot;xyzzy&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>整个过程为：</p>
<ol>
<li>构造临时对象。</li>
<li><code>std::vector</code>分配空间给新元素。</li>
<li>将临时对象复制到新的空间上。</li>
<li>析构临时对象。</li>
</ol>
<p>于是这里偷偷的多了一次对象的构造和析构。另外还有一次临时对象的复制。当我们很关心性能时，这些额外开销是不可忽视的。</p>
<p>C++11新增的<code>emplace_back</code>方法就可以避免这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="string">&quot;xyzzy&quot;</span>);</span><br><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="number">50</span>, <span class="string">&#x27;x&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>它会先分配空间，再在新空间上使用传入参数直接构造出<code>std::string</code>。每个支持<code>push_back</code>的容器也都支持<code>emplace_back</code>，支持<code>push_front</code>的容器也都支持<code>emplace_front</code>，支持<code>insert</code>的容器也都支持<code>emplace</code>。</p>
<p>一般来说insert和emplace的效果是完全相同的，同时<code>emplace</code>还省掉了临时对象的构造和析构，那么还有什么情况下我们不用emplace呢？</p>
<p>目前的C++标准库实现中，既有emplace比insert快的场景，也有emplace比insert慢的场景。这些场景很难列举，取决于传入的参数类型、使用的容器、新元素所处的位置、元素的构造函数的异常安全性，以及对于map和set类容器，要插入的元素是否已经存在等因素。因此在决定使用insert还是emplace前，先测一下性能。</p>
<p>当然也有些启发式的方法来判断emplace适用于哪些场景。以下条件如果为真，emplace就很可能比insert性能更好：</p>
<ul>
<li><p>新元素在容器内直接构造，而不是先构造再赋值。</p>
<p>  在前面的例子中，我们要在<code>vs</code>的尾部新增一个元素，显然这里之前不存在对象，我们只能构造一个对象。emplace此时就比较有优势。但下面这个例子中：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vs;</span><br><span class="line">...</span><br><span class="line">vs.<span class="built_in">emplace</span>(vs.<span class="built_in">begin</span>(), <span class="string">&quot;xyzzy&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  我们要在<code>vs</code>的头部新增一个对象。大多数实现会先用<code>&quot;&quot;xyzzy&quot;</code>构造出一个临时的<code>std::string</code>，再移动赋值给目标对象。这样emplace相比insert的优势就没有了。</p>
<p>  当然，这取决于我们用的实现。但此时启发式方法还是有用的。理论上基于节点的容器都会构造新元素，而大多数STL容器都是基于节点的。只有几个容器不基于节点：<code>std::vector</code>、<code>std::deque</code>、<code>std::string</code>（<code>std::array</code>基于节点，但它没有emplace和insert类的方法）。当你明确知道新元素会被构造出来时，就可以毫不犹豫的使用emplace。这三个容器的<code>emplace_back</code>都是推荐用的，对于<code>std::deque</code>来说，<code>emplace_front</code>也推荐使用。</p>
</li>
<li><p>实参类型与容器的元素类型不同。（解释略）</p>
</li>
<li><p>容器不会因重复元素而拒绝插入。这里说的是对于<code>std::set</code>或<code>std::map</code>这样的容器，在插入时需要比较，那么就需要把实参先构造为一个临时对象。这样emplace的优势就没有了。</p>
</li>
</ul>
<p>下面两次调用就满足上面的条件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="string">&quot;xyzzy&quot;</span>);</span><br><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="number">50</span>, <span class="string">&#x27;x&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在决定使用emplace后，有两个问题值得考虑。第一个是资源管理的问题。假设你有一个容器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;std::shared_ptr&lt;Widget&gt;&gt; ptrs;</span><br></pre></td></tr></table></figure>

<p><code>Widget</code>需要的自定义销毁函数是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">killWidget</span><span class="params">(Widget* pWidget)</span></span>;</span><br></pre></td></tr></table></figure>

<p>根据Item21，这种情况下我们没办法用<code>std::make_shared</code>了。insert版本是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrs.<span class="built_in">push_back</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget, killWidget));</span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrs.<span class="built_in">push_back</span>(&#123;<span class="keyword">new</span> Widget, killWidget&#125;);</span><br></pre></td></tr></table></figure>

<p>无论哪种情况，都要构造出一个临时对象。这不就是emplace能避免的吗？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrs.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> Widget, killWidget);</span><br></pre></td></tr></table></figure>

<p>但注意，临时对象带来的好处远比它的构造和析构成本要大得多。考虑一种情况：</p>
<ol>
<li>我们构造了一个临时对象<code>temp</code>，持有<code>new Widget</code>的结果。</li>
<li>容器扩张时抛了个异常。</li>
<li>异常传播到外层，<code>temp</code>被销毁，<code>Widget*</code>被释放。</li>
</ol>
<p>而emplace版本则是：</p>
<ol>
<li><code>new Widget</code>的结果，一个裸指针，传进了<code>emplace_back</code>函数内。</li>
<li>容器扩张时抛了个异常。</li>
<li>没有智能指针持有前面的裸指针，内存泄漏。</li>
</ol>
<p>类似的问题也会出现在每个RAII类中。将裸指针（或其它未受保护的资源）通过完美转发的方式传递进emplace函数后，在RAII对象构造之前，有个窗口期。正确的方式是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, killWidget)</span></span>; </span><br><span class="line">ptrs.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(spw));</span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, killWidget)</span></span>;</span><br><span class="line">ptrs.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(spw));</span><br></pre></td></tr></table></figure>

<p>无论哪种方式都要先构造对象，此时emplace和insert就没什么区别了。</p>
<p>第二个问题是emplace与<code>explicit</code>构造函数的相互作用。想象你有一个正则表达式的容器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::regex&gt; regexes;</span><br></pre></td></tr></table></figure>

<p>有一天你写了这么一行代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regexes.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<p>然后编译器居然不报错！<code>nullptr</code>怎么可能是正则表达式呢？</p>
<p><code>std::regex r = nullptr</code>是没办法编译通过的。而<code>regexes.push_back(nullptr)</code>也是非法的。</p>
<p>问题在于<code>std::regex</code>有一个接受<code>const char*</code>的析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">upperCaseWord</span><span class="params">(<span class="string">&quot;[A-Z]+&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>但它是<code>explicit</code>的，因此下面这么用会报错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::regex r = <span class="literal">nullptr</span>;</span><br><span class="line">regexes.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<p>但显式调用构造函数是可以的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">r</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>不幸的是emplace函数中就是这么构造对象的，能编译，但运行结果未定义。</p>
<p>下面两种很类似的构造方式，但结果不同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::regex r1 = <span class="literal">nullptr</span>;          <span class="comment">// Error</span></span><br><span class="line"><span class="function">std::regex <span class="title">r2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;           <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>第一种是复制初始化，第二种是直接初始化。复制初始化不允许使用<code>explicit</code>构造函数，而直接初始化则可以。emplace函数中执行的是对象的直接初始化，而insert函数中则是复制初始化。</p>
<p>因此当你使用emplace的时候，注意看一下你传递的类型对不对，因为它会在你没注意到的时候绕开<code>explicit</code>的限制，然后制造一个大新闻。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="/2017/05/14/effective-modern-cpp-chapter1-iterm1-4/">Chapter1 类型推断 (Item 1-4)</a></li>
<li><a href="/2017/05/22/effective-modern-cpp-chapter2-iterm5-6/">Chapter2 auto (Item 5-6)</a></li>
<li><a href="/2017/05/22/effective-modern-cpp-chapter3-iterm7-10/">Chapter3 现代C++（Item 7-10)</a></li>
<li><a href="/2017/05/22/effective-modern-cpp-chapter3-iterm11-14/">Chapter3 现代C++（Item 11-14)</a></li>
<li><a href="/2017/07/09/effective-modern-cpp-chapter3-iterm15-17/">Chapter3 现代C++（Item 15-17)</a></li>
<li><a href="/2017/07/27/effective-modern-cpp-chapter4-iterm18-22/">Chapter4 智能指针 (Item 18-22)</a></li>
<li><a href="/2017/08/08/effective-modern-cpp-chapter5-iterm23-26/">Chapter5 右值引用、移动语义、完美转发（Item 23-26)</a></li>
<li><a href="/2017/08/22/effective-modern-cpp-chapter5-iterm27-30/">Chapter5 右值引用、移动语义、完美转发（Item 27-30)</a></li>
<li><a href="/2017/09/06/effective-modern-cpp-chapter6-iterm31-34/">Chapter6: Lamba表达式 (Item 31-34)</a></li>
<li><a href="/2017/09/24/effective-modern-cpp-chapter7-iterm35-37/">Chapter7: 并发API (Item 35-37)</a></li>
<li><a href="/2017/10/09/effective-modern-cpp-chapter7-iterm38-40/">Chapter7: 并发API (Item 38-40)</a></li>
<li><a href="/2017/10/26/effective-modern-cpp-chapter8-iterm41-42/">Chapter8: 杂项 (Item 41-42)</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2017/10/09/effective-modern-cpp-chapter7-iterm38-40/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/09/effective-modern-cpp-chapter7-iterm38-40/" class="post-title-link" itemprop="url">Effective Modern C++ 笔记 Chapter 7: 并发API (Item38-40)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-09 22:50:11" itemprop="dateCreated datePublished" datetime="2017-10-09T22:50:11+08:00">2017-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Item38-知道线程句柄析构时的各种行为"><a href="#Item38-知道线程句柄析构时的各种行为" class="headerlink" title="Item38: 知道线程句柄析构时的各种行为"></a>Item38: 知道线程句柄析构时的各种行为</h2><p>上节介绍了可join的<code>std::thread</code>对应一个可运行的底层线程，而未推迟的future也可能对应一个OS线程。这里把它们都称为OS线程的句柄。</p>
<p>很有趣的是，<code>std::thread</code>和future在析构的行为上非常不同。析构一个可join的<code>std::thread</code>会导致程序终止，而析构一个future有时像是做了隐式的<code>join</code>，有时像是做了隐式的<code>detach</code>，有时两者都不是。总之它不会导致程序终止。</p>
<p>我们首先从这样一个发现开始：future就是执行者将结果返回给调用者的一个管道。执行者（通常是异步执行）将计算结果写到管道中（例如<code>std::promise</code>对象），调用者再通过future拿到结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">----------                                          ----------</span><br><span class="line">| Caller | &lt;--- future ------------ std::promise ---| Callee |</span><br><span class="line">----------                                          ----------</span><br></pre></td></tr></table></figure>

<p>但结果保存在哪了？执行者可能在调用者调用<code>get</code>之前就结束了，所以结果一定不会在执行者对应的<code>std::promise</code>对象中，它会在执行者结束时析构掉。</p>
<p>结果也不可能在future对象中，因为<code>std::future</code>有可能用来创建<code>std::shared_future</code>，然后被复制很多遍。如果结果在future中，那么结果也会被复制很多遍。我们知道有些结果类型是不能复制的，因此不可能在future对象中。</p>
<p>那么答案就是结果保存在<code>std::promise</code>和future之外，且需要是可共享状态。C++标准中没有规定结果的类型，编译器可以自行实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">----------                ------------------                    ----------</span><br><span class="line">| Caller | &lt;--- future ---| Result(Shared) |--- std::promise ---| Callee |</span><br><span class="line">----------                ------------------                    ----------</span><br></pre></td></tr></table></figure>

<p>与future关联的这个共享状态就决定了future的析构行为，尤其：</p>
<ul>
<li>对于通过<code>std::async</code>启动的未推迟的task，最后一个与之关联的future在析构时会阻塞，直到这个task完成。本质上，这个析构就是对task所在的线程调用了一次join。</li>
<li>其它future的析构都只是简单的析构这个对象。这些析构就是对底层线程调用了detach。对于被推迟的task，当它关联的最后一个future析构后，这个task就永远不会被执行了。</li>
</ul>
<p>简单来说就是有一种正常行为和一个例外。正常行为就是future的析构只析构future对象，它既不会join也不会detach。而当以下条件都满足时，应用例外规则：</p>
<ul>
<li>future关联着由<code>std::async</code>创建的共享状态。</li>
<li>task的启动策略是<code>std::launch::async</code>，包括调用<code>std::async</code>时显式指定该策略，也包括调用者使用了默认策略，而系统选择了该策略。</li>
<li>它是最后一个关联共享状态的future。</li>
</ul>
<p>以上条件都满足时，future的析构会对底层线程调用join。</p>
<p>为什么对于由<code>std::async</code>启动的未推迟的task会有这个例外？就我（Scott Meyers）所知，C++标准委员会想避免隐式detach引起的问题（见Item37），但又不想像对待可join的<code>std::thread</code>那样使用“程序终止”这么激进的策略，所以最终他们妥协了，决定隐式使用join。这个决定并不是毫无争议，一直有声音想在C++14中将这个行为废弃掉，但最终它还是保留了下来。</p>
<p>future的API上没办法知道它是不是关联一个共享状态，因此没办法知道随便一个future的析构会不会阻塞。这导致了一些有趣的潜在状况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futs; <span class="comment">// 析构时可能阻塞</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;                       <span class="comment">// 析构时可能阻塞</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_future&lt;<span class="type">double</span>&gt; fut;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，如果你知道某个future肯定不满足例外条件，你就能确定它的析构不会阻塞。例如，当我们使用<code>std::packaged_task</code>时，它返回的future就不与<code>std::async</code>创建的共享状态相关联，因此我们可以确定这样的future的析构是不会阻塞的。</p>
<blockquote>
<p><code>std::packaged_task</code>与<code>std::function</code>类似，都是对某个callable的对象的包装。区别在于<code>std::packaged_task</code>会返回一个future。我们可以用<code>std::packaged_task</code>创建一个<code>std::thread</code>来运行callable对象，结果通过future得到。</p>
</blockquote>
<p>当然<code>std::packaged_task</code>也可以通过<code>std::async</code>来运行，但这样就没有理由用<code>std::packaged_task</code>了，直接用<code>std::async</code>更方便。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">pt</span><span class="params">(calcValue)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> fut = pt.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(pt))</span></span>;</span><br><span class="line">    ...                                        <span class="comment">// see below</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“…”中对<code>t</code>可能的三种操作：</p>
<ul>
<li>没有对<code>t</code>作任何操作。这样结束时<code>t</code>还是可join的，导致程序终止。</li>
<li>对<code>t</code>调用了join。这样<code>fut</code>析构时就不需要阻塞了。</li>
<li>对<code>t</code>调用了detach。这样<code>fut</code>析构时也不需要调用detach了。</li>
</ul>
<p>结论就是，对于由<code>std::packaged_task</code>得到的future，你不需要怎么关心它的析构行为。</p>
<h2 id="Item39-考虑用一个void-future来进行只运行一次的事件通信"><a href="#Item39-考虑用一个void-future来进行只运行一次的事件通信" class="headerlink" title="Item39: 考虑用一个void future来进行只运行一次的事件通信"></a>Item39: 考虑用一个void future来进行只运行一次的事件通信</h2><p>当需要进行事件通信时，一种显然的方式就是通过条件变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex m;</span><br></pre></td></tr></table></figure>

<p>通知方的代码很简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cv.<span class="built_in">notify_one</span>();</span><br></pre></td></tr></table></figure>

<p>接收方的代码就有点复杂了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上面的代码并不正确。首先，这种方法的味道（code smell）不好，就表示可能藏bug。这里的第一个问题在于，是否有必要使用<code>std::mutex</code>。<code>std::mutex</code>是用来保护共享状态的，但很有可能通知方和接收方并没有共享什么东西，那么这个<code>std::mutex</code>就只是为了条件变量才构造的，逻辑上并不需要它。</p>
<p>即使用到了<code>std::mutex</code>，仍然有两个问题：</p>
<ul>
<li>条件变量不能保存通知状态，因此如果通知方在接收方开始<code>wait</code>前就调用了<code>notify_one</code>，接收方就会hang在那。</li>
<li>条件变量的<code>wait</code>有可能在条件并不满足（未通知）时结束（假醒），因此需要有办法知道我们等待的条件是否真的满足了。接收方自己当然没办法知道这个事情（否则它就不需要条件变量了）。</li>
</ul>
<p>以上两个问题的一种解法是使用一个共享状态，而不是条件变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atmoic&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="comment">// 通知方</span></span><br><span class="line">...</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 接收方</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法的好处是不需要mutex，能保存通知状态，不需要处理假醒。但它的问题在于接收方在阻塞时需要不停的查询状态，CPU开销很大。</p>
<p>可以把共享状态与条件变量结合起来使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flag</span><span class="params">(<span class="literal">false</span>)</span></span>;                   <span class="comment">// not std::atomic</span></span><br><span class="line"><span class="comment">// 通知方</span></span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g</span><span class="params">(m)</span></span>;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">cv.<span class="built_in">notify_one</span>();</span><br><span class="line"><span class="comment">// 接收方</span></span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lk, [] &#123; <span class="keyword">return</span> flag; &#125;); <span class="comment">// use lambda to avoid spurious wakeups</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这种方法避免了我们讲到的几个问题，但它的设计不好：很多共享变量；两套机制来做同一件事；逻辑暴露在外，容易写错。简单来说就是这种方法不够干净。</p>
<p>一种更干净的方法是接收方等待一个future，而通知方通过给这个future赋值来进行通知。Item38提到了<code>std::promise</code>代表了一个通信通道的发送端，而future则代表了接收端。这样的通道可以用于任何需要通信的场合。</p>
<p>方案很简单，通知方要持有一个<code>std::promise</code>对象，而接收方持有对应的future。通知方通过调用<code>std::promise</code>的<code>set_value</code>来写入一条消息，接收方通过future的<code>wait</code>来等待消息。</p>
<p>无论是<code>std::promise</code>、<code>std::future</code>还是<code>std::shared_future</code>都是模板类型，需要一个类型参数，也就是消息的类型。但我们只关心通知本身，不需要消息有类型，最合适的就是<code>void</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">void</span>&gt; p;</span><br><span class="line"><span class="comment">// 通知方</span></span><br><span class="line">...</span><br><span class="line">p.<span class="built_in">set_value</span>();</span><br><span class="line"><span class="comment">// 接收方</span></span><br><span class="line">...</span><br><span class="line">p.<span class="built_in">get_future</span>().<span class="built_in">wait</span>();</span><br></pre></td></tr></table></figure>

<p>没有mutex，没有条件变量，没有共享状态，没有假醒，是不是很完美？不完全是。Item38提到<code>std::promise</code>背后实际上有一个共享状态，就意味着它的构造包含着一次内存分配和释放的开销。</p>
<p>而且，<code>std::promise</code>只能<strong>赋值一次</strong>。重复对<code>std::promise</code>的赋值是没有意义的，接收方感知不到。因此这条通信通道只能使用一次，这是与前述方案最大的区别。条件变量和共享状态总是可以重复利用的。</p>
<p>“只有一次”的通信有时候也是很有用的。举个例子，有时候我们想创建一个被暂停的线程，需要等待一个事件后才开始工作，就可以用<code>std::promise</code>来实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">void</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">react</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        p.get_future().wait();</span></span></span><br><span class="line"><span class="params"><span class="function">        react();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    p.<span class="built_in">set_value</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们创建了一个暂停的线程，它会等待<code>p</code>被赋值后才执行<code>react</code>。需要一个暂停线程的地方很多，比如我们想避免线程创建的成本，比如想在线程真正工作前设置一下优先级什么的（<code>std::thread</code>没有这种接口，但我们可以通过<code>native_handle</code>获得OS线程的句柄来做这样的事情）。</p>
<p>Item37中提到用<code>ThreadRAII</code>类来代替直接的<code>std::thread</code>会更好，我们改写一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">void</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">react</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ThreadRAII <span class="title">tr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        std::thread([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            p.get_future().wait();</span></span></span><br><span class="line"><span class="params"><span class="function">            react();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;),</span></span></span><br><span class="line"><span class="params"><span class="function">        ThreadRAII::DtorAction::join</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    ...                              <span class="comment">// 注意这里</span></span><br><span class="line">    p.<span class="built_in">set_value</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码有个问题：第一个“…”处如果抛了异常，<code>p</code>还没有赋值，因此<code>tr</code>还在阻塞中，因此它是可join的，因此<code>tr</code>析构会导致程序终止。</p>
<p>这个问题有很多解法，这里就不赘述了。最后说一下如何把上面的通信过程由一对一改成一对多，即一个通知方唤醒多个接收方：把<code>std::future</code>换成<code>std::shared_future</code>即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">void</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">react</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sf = p.<span class="built_in">get_future</span>().<span class="built_in">share</span>();   <span class="comment">// std::shard_future</span></span><br><span class="line">    std::vector&lt;std::thread&gt; vt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadForRun; ++i) &#123;</span><br><span class="line">        vt.<span class="built_in">emplace_back</span>(</span><br><span class="line">            std::<span class="built_in">thread</span>([sf] &#123;          <span class="comment">// 必须值捕获</span></span><br><span class="line">                sf.<span class="built_in">wait</span>();</span><br><span class="line">                <span class="built_in">react</span>();</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ...                              </span><br><span class="line">    p.<span class="built_in">set_value</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t: vt) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意各个线程持有的<code>std::shared_future</code>必须是值，不能是引用。</p>
<h2 id="Item40-使用std-atomic应对并发，而用volatile访问特殊内存"><a href="#Item40-使用std-atomic应对并发，而用volatile访问特殊内存" class="headerlink" title="Item40: 使用std::atomic应对并发，而用volatile访问特殊内存"></a>Item40: 使用<code>std::atomic</code>应对并发，而用<code>volatile</code>访问特殊内存</h2><p>本节内容不重复了，大家都比较熟悉。简单列一下结论：</p>
<ol>
<li><code>std::atomic</code>是真正的原子操作，用于并发，但不能用于访问特殊内存（如硬件资源）。</li>
<li><code>volatile</code>在某些语言中可以用于并发，但在C++中不能用于并发，它不保证原子的读写，也不保证指令的先后顺序。它的用途是访问上面说的特殊内存。</li>
<li>可以结合起来，用于需要并发访问的特殊内存：<code>volatile std::atomic&lt;int&gt; vai</code>。</li>
<li>访问<code>std::atomic</code>要比访问普通变量慢得多，它的内存屏障也会限制编译器的指令重排等优化，因此不要滥用<code>std::atomic</code>。</li>
</ol>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="/2017/05/14/effective-modern-cpp-chapter1-iterm1-4/">Chapter1 类型推断 (Item 1-4)</a></li>
<li><a href="/2017/05/22/effective-modern-cpp-chapter2-iterm5-6/">Chapter2 auto (Item 5-6)</a></li>
<li><a href="/2017/05/22/effective-modern-cpp-chapter3-iterm7-10/">Chapter3 现代C++（Item 7-10)</a></li>
<li><a href="/2017/05/22/effective-modern-cpp-chapter3-iterm11-14/">Chapter3 现代C++（Item 11-14)</a></li>
<li><a href="/2017/07/09/effective-modern-cpp-chapter3-iterm15-17/">Chapter3 现代C++（Item 15-17)</a></li>
<li><a href="/2017/07/27/effective-modern-cpp-chapter4-iterm18-22/">Chapter4 智能指针 (Item 18-22)</a></li>
<li><a href="/2017/08/08/effective-modern-cpp-chapter5-iterm23-26/">Chapter5 右值引用、移动语义、完美转发（Item 23-26)</a></li>
<li><a href="/2017/08/22/effective-modern-cpp-chapter5-iterm27-30/">Chapter5 右值引用、移动语义、完美转发（Item 27-30)</a></li>
<li><a href="/2017/09/06/effective-modern-cpp-chapter6-iterm31-34/">Chapter6: Lamba表达式 (Item 31-34)</a></li>
<li><a href="/2017/09/24/effective-modern-cpp-chapter7-iterm35-37/">Chapter7: 并发API (Item 35-37)</a></li>
<li><a href="/2017/10/09/effective-modern-cpp-chapter7-iterm38-40/">Chapter7: 并发API (Item 38-40)</a></li>
<li><a href="/2017/10/26/effective-modern-cpp-chapter8-iterm41-42/">Chapter8: 杂项 (Item 41-42)</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>


        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fu Zhe"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Fu Zhe</p>
  <div class="site-description" itemprop="description">High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">120</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">81</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fu Zhe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v6.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
