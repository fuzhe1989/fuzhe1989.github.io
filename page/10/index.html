<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://fuzhe1989.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="High-Flyer AIPingCAPGoogleAlibaba CloudHarbin Institute of Technology">
<meta property="og:type" content="website">
<meta property="og:title" content="Fu Zhe&#39;s Blog">
<meta property="og:url" content="http://fuzhe1989.github.io/page/10/index.html">
<meta property="og:site_name" content="Fu Zhe&#39;s Blog">
<meta property="og:description" content="High-Flyer AIPingCAPGoogleAlibaba CloudHarbin Institute of Technology">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fu Zhe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://fuzhe1989.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Fu Zhe's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4HC396822H"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-4HC396822H');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?df45b34764dad306c840c8f1da5faf14";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Fu Zhe's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fu Zhe's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/23/cpp-object-model-ctor-dtor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/23/cpp-object-model-ctor-dtor/" class="post-title-link" itemprop="url">C++对象模型（五）构造与析构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-23 00:23:16" itemprop="dateCreated datePublished" datetime="2018-03-23T00:23:16+08:00">2018-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>C++里类有4种特殊的成员函数：</p>
<ul>
<li>构造函数。</li>
<li>析构函数。</li>
<li>复制函数，包括复制构造函数和复制赋值函数。</li>
<li>移动函数，包括移动构造函数和移动赋值函数。</li>
</ul>
<p>这些函数的特点是：有些时候，编译器会帮你生成这些函数；有些时候，编译器又会拒绝生成这些函数；还有些时候，编译器还会往你自己写的特殊函数中添加操作。鉴于这些特殊函数的重要性，我们有必要好好了解一下它们背后的故事。</p>
<p>本文介绍的是前两类，构造函数和析构函数。</p>
<p>注1：本文环境为Ubuntu 16.04，gcc5.4.0，使用c++14标准。<br>注2：本文大量内容来自<a target="_blank" rel="noopener" href="https://book.douban.com/subject/10427315/">《深入探索C++对象模型》</a>。</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="什么类没有构造函数"><a href="#什么类没有构造函数" class="headerlink" title="什么类没有构造函数"></a>什么类没有构造函数</h2><p>我们知道构造函数是一种非常重要的函数，也是C++诞生的一个主要原因。那么，第一个问题，每个类都有构造函数吗？</p>
<p>对于下面这个平凡类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Trivial</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> x;</span><br><span class="line">    <span class="type">int64_t</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Trivial t;</span><br><span class="line">    t.x = <span class="number">1</span>;</span><br><span class="line">    t.y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main</code>函数对应的汇编指令为（未开任何优化）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000000004006b6 &lt;main&gt;:</span><br><span class="line">  4006b6:   55                      push   %rbp</span><br><span class="line">  4006b7:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  4006ba:   48 c7 45 f0 01 00 00    movq   $0x1,-0x10(%rbp)</span><br><span class="line">  4006c1:   00</span><br><span class="line">  4006c2:   48 c7 45 f8 02 00 00    movq   $0x2,-0x8(%rbp)</span><br><span class="line">  4006c9:   00</span><br><span class="line">  4006ca:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  4006cf:   5d                      pop    %rbp</span><br><span class="line">  4006d0:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>没有<code>Trivial</code>的构造函数的影子。整个binary中也找不到<code>Trivial</code>的构造函数。</p>
<p>事实上，平凡类就是没有构造函数的，或者说编译器会为它生成一个<strong>trivial</strong>的构造函数。而一个trivial的构造函数就类似于C中struct的初始化：什么都不做。因此编译器实际上不会为平凡类生成构造函数。而平凡类不允许有自定义的构造函数，结论就是平凡类就不可能有构造函数。</p>
<p>然而有一种情况下，编译器还真会给平凡类生成一个构造函数，那就是显式声明一个<code>= default</code>的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Trivial</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> x;</span><br><span class="line">    <span class="type">int64_t</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trivial</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000000004009e8 &lt;_ZN7TrivialC1Ev&gt;:</span><br><span class="line">  4009e8:   55                      push   %rbp</span><br><span class="line">  4009e9:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  4009ec:   48 89 7d f8             mov    %rdi,-0x8(%rbp)</span><br><span class="line">  4009f0:   90                      nop</span><br><span class="line">  4009f1:   5d                      pop    %rbp</span><br><span class="line">  4009f2:   c3                      retq</span><br><span class="line">  4009f3:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">  4009fa:   00 00 00</span><br><span class="line">  4009fd:   0f 1f 00                nopl   (%rax)</span><br></pre></td></tr></table></figure>

<p>虽然这个函数里明显什么事情都没做，但它确实存在了。</p>
<p>当然，加上“-O2”你会发现，它又没了。</p>
<p>实际上，所有没有自定义构造函数的，满足bitwise语义的类，都可能没有构造函数。这个范围会比平凡类大一些。</p>
<h2 id="编译器生成默认构造函数的条件"><a href="#编译器生成默认构造函数的条件" class="headerlink" title="编译器生成默认构造函数的条件"></a>编译器生成默认构造函数的条件</h2><p>第二个问题，编译器什么时候会为一个类生成一个默认构造函数？</p>
<p>编译器只会在<strong>必要</strong>的时候为一个类生成默认构造函数。所谓必要，指：</p>
<ul>
<li>这个类没有自定义的构造函数或声明默认构造函数为<code>= default</code>，且</li>
<li>没有用<code>= delete</code>删除默认构造函数，且</li>
<li>代码中调用到了这个类的默认构造函数。</li>
</ul>
<p>第一个条件很好理解，C++的编译器是充分相信程序员的，如果一个程序员写了随便一个构造函数，编译器会尊重Ta，不再为其生成默认构造函数。</p>
<p>第二个条件是指，编译器不会在看到这个类的定义时就为其生成一个默认构造函数，而是会推迟这个生成时机，直到有代码真的调用了才生成。</p>
<p>然而，即使满足上面的条件，如果类中默认构造函数没有声明为<code>= default</code>，且编译器判断这个类可以bitwise构造，编译器仍然不会真的生成一个默认构造函数。</p>
<h2 id="bitwise与memberwise"><a href="#bitwise与memberwise" class="headerlink" title="bitwise与memberwise"></a>bitwise与memberwise</h2><p>当我们说到构造函数时，一个不得不提的概念是bitwise与memberwise。实际上这两个概念更多的是用来描述拷贝，但在构造上也有着类似的效果。</p>
<p>一个类型，如果满足：</p>
<ul>
<li>是标量类型，或</li>
<li>是自定义类型，且满足：<ul>
<li>没有虚函数。</li>
<li>没有虚基类。</li>
<li>没有不符合bitwise语义的非静态成员变量。</li>
<li>没有不符合bitwise语义的基类。</li>
<li>没有自定义的构造函数。</li>
</ul>
</li>
</ul>
<p>那它就满足bitwise构造的条件，即它在构造时没有任何特殊的操作（除了给它分配内存外），它的默认构造函数就是trivial的，实际上编译器不会真的生成这个函数。</p>
<p>而反过来，不满足这个条件的类，它就需要依次初始化每个成员，即是memberwise。</p>
<p>trivial的构造函数要比自定义的构造函数低很多（什么都不做），但它伤害到了正确性，即类的成员是没有一个可预期的初始值的的。从这个角度讲，即使是满足上面条件的类，我们也不应放任编译器选择trivial的默认构造函数，而应该自己定义一个正确初始化每个成员值的默认构造函数。当然，如果你要定义一个POD类型的话，除外。</p>
<h2 id="构造函数的内容"><a href="#构造函数的内容" class="headerlink" title="构造函数的内容"></a>构造函数的内容</h2><p>一个构造函数有哪些内容？比如，对于一个有着两个基类A和B的有虚函数的类型C，它的构造函数需要完成以下工作：</p>
<ul>
<li>初始化基类A。</li>
<li>初始化基类B。</li>
<li>确保虚表指针指向正确的位置。</li>
<li>初始化每个成员。</li>
<li>依次调用构造函数体中的语句。</li>
</ul>
<p>很显然，C要先完成A和B的构造，才能保证C自己的构造过程开始时，它已经“is a”A和B的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> x;</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        x = <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">F</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> y;</span><br><span class="line">    <span class="built_in">B</span>() &#123;</span><br><span class="line">        y = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>: <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line">    <span class="type">int32_t</span> z;</span><br><span class="line">    <span class="built_in">C</span>(): <span class="built_in">z</span>(<span class="number">3</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个例子中，在<code>A::A</code>中我们调用了一个虚函数<code>F</code>，假如整个过程发生在C的构造中，它调用的是哪个<code>F</code>？<code>A::F</code>还是<code>C::F</code>？</p>
<p>我们知道，在C去构造它的A的子对象时，它自己的成员都还没有初始化，那么此时去调用<code>C::F</code>显然是不合理的。因此我们有一个结论：构造函数中虚函数没有动态绑定，只有静态绑定。</p>
<p>《深入探索C++对象模型》中提到，当时的编译器在初始化基类子对象时，是通过将虚表指针指向基类的虚表，来实现一种伪的静态绑定。这么做的理由是不区别对待构造函数与其它函数。但这显然会伤害到效率。因此现代的编译器都会区别对待构造函数，真的静态绑定其中每个成员变量的调用。</p>
<p>通常我们会显式的把基类的构造写到派生类的初始化列表中。但即使不这么做，编译器也会将基类子对象的构造插到派生类的每个构造函数的开头，当然这要求基类有一个默认构造函数，或编译器能为其生成一个默认构造函数。</p>
<p>OK，在成功地构造完基类子对象后，C开始忙自己的构造了。</p>
<p>首先，如果C有虚表，那么要把虚表设置到正确地位置上。</p>
<p>之后开始按<strong>声明</strong>顺序依次构造C的每个非静态成员变量。</p>
<p>这里的“声明”要加粗，是因为如果忽略这一点，我们很可能会得到一个编译器的警告。</p>
<p>在这个阶段，每个非静态成员变量的初始值可能会来自三个地方：</p>
<ul>
<li>初始化列表中的表达式。</li>
<li>成员初始化式（C++11新增）中的表达式。</li>
<li>该成员的默认构造函数（如果非trivial）。</li>
</ul>
<p>其优先级依次下降。其中最后一项不涉及顺序，而前两项都可能会涉及到不同成员变量间的构造顺序。</p>
<p>对于下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y = z + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="built_in">S</span>(): <span class="built_in">z</span>(<span class="number">0</span>), <span class="built_in">x</span>(y + <span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们构造出一个<code>S</code>的对象时，会发现它的<code>x</code>和<code>y</code>两个成员的值是未初始化的！这就是因为，<code>x</code>依赖了它后面声明的<code>y</code>，而<code>y</code>依赖了它后面声明的<code>z</code>，导致当它们进行初始化时，依赖的值都还没有初始化，自然会得到一个错误的值。</p>
<p>OK，初始化列表结束后，此时c已经是一个合法的，所有成员和函数都可用的C对象了。接下来要执行的就是构造函数体本身了。</p>
<p>这里有一个值得注意的点。执行到构造函数体前，类的所有成员变量都已经初始化过了，如果我们在构造函数体中再对其进行赋值，大概率浪费了前面的初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="built_in">S</span>(<span class="type">const</span> std::string&amp; s) &#123;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，在整个构造过程中，<code>name</code>执行了一次默认构造函数，和一次赋值。而如果将这次赋值放到初始化列表中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="built_in">S</span>(<span class="type">const</span> std::string&amp; s): <span class="built_in">name</span>(s) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>name</code>就只执行了一次复制构造函数。对于很多类型来说，后者的好处还是很明显的。</p>
<h2 id="单参数构造函数要声明为explicit"><a href="#单参数构造函数要声明为explicit" class="headerlink" title="单参数构造函数要声明为explicit"></a>单参数构造函数要声明为<code>explicit</code></h2><p>某种说法认为C++不是强类型语言，因为它允许类型间的隐式转换。C++中的隐式转换有一部分是因为要兼容C而背的包袱，导致整型的重载无比混乱。而另一部分隐式转换就是C++自己设计的问题了。</p>
<p>在某些场景下，C++的隐式转换是很有用的，但在很可能多得多的场景下，如果滥用隐式转换，就会带来潜在的问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    std::vector&lt;std::string&gt; v;</span><br><span class="line">    <span class="built_in">S</span>(<span class="type">int</span> x): <span class="built_in">v</span>(x, <span class="string">&quot;aaa&quot;</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> S&amp; s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v.size:&quot;</span> &lt;&lt; s.v.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Func</span>(<span class="number">100</span>); <span class="comment">// oops!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>Func</code>实际只接受<code>const S&amp;</code>类型的参数，但我们搞错了，传进去了100。我们预期的结果当然是编译器报错，找不到<code>Func(int)</code>，但实际呢？程序编译通过，成功运行，结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.size:100</span><br></pre></td></tr></table></figure>

<p>发生了什么？隐式转换。编译器看到<code>Func(100)</code>时，它首先会去找<code>Func</code>，只找到了<code>Func(const S&amp;)</code>，没找到<code>Func(int)</code>。于是编译器会找有没有哪种隐式转换，允许将一个<code>int</code>转换为<code>S</code>，还真有，<code>S</code>正好有个构造函数是<code>S(int)</code>！于是编译器这里就执行了<code>S</code>的构造函数，构造出一个有着100个元素的对象。</p>
<p>怎么避免上面的场景发生？我们就要想办法禁止<code>int</code>到<code>S</code>的隐式转换，而<code>explicit</code>就是这个作用。当它被用来修饰一个单参数的构造函数时，就会阻止编译器产生一种隐式转换的关系：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    std::vector&lt;std::string&gt; v;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">S</span><span class="params">(<span class="type">int</span> x)</span>: v(x, <span class="string">&quot;aaa&quot;</span>) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然而当我们真的想将<code>int</code>转换为<code>S</code>时，该怎么办？两种方法：</p>
<ul>
<li>显式构造：<code>Func(S(100))</code>。</li>
<li>static_cast：<code>Func(static_cast&lt;S&gt;(100))</code>。</li>
</ul>
<h2 id="全局变量的初始化不要依赖其它编译单元的全局变量"><a href="#全局变量的初始化不要依赖其它编译单元的全局变量" class="headerlink" title="全局变量的初始化不要依赖其它编译单元的全局变量"></a>全局变量的初始化不要依赖其它编译单元的全局变量</h2><p>这句话有两个前提：</p>
<ul>
<li>全局变量的初始化发生在<code>main</code>函数之前，串行进行。</li>
<li>不同的实现文件（.cpp或.cc）属于不同的编译单元，而不同编译单元的全局变量的初始化顺序在链接时由链接器决定。</li>
</ul>
<p>这就导致了一个类似于上面构造函数初始化列表的顺序问题，且它没有一个确定的顺序。</p>
<p>因此，如果一个全局变量在初始化时依赖了另一个编译单元的全局变量，很可能你会发现前者初始化时后者还没有初始化。</p>
<p>这里的全局变量也包括类的静态成员变量。</p>
<p>那么，如果真有这种全局变量的初始值依赖于其它变量，该怎么做呢：</p>
<ul>
<li><p>相同编译单元的全局变量的初始化顺序是确定的，可依赖的。</p>
</li>
<li><p>如果必须跨编译单元依赖，那么把被依赖的变量放到一个函数里作为static变量。标准规定了函数中的static变量其初始化是在第一次调用时（运行到此行时），这是确定的，可依赖的：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="function">TypeA <span class="title">gX</span><span class="params">(SomeFunc())</span></span>;</span><br><span class="line"><span class="comment">// b.h</span></span><br><span class="line"><span class="function"><span class="type">const</span> TypeB&amp; <span class="title">SomeFunc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="function"><span class="type">const</span> TypeB&amp; <span class="title">SomeFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> TypeB b;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  别担心这里构造static变量没加锁，C++11后标准中规定了这种构造是线程安全的。</p>
</li>
</ul>
<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><h2 id="编译器生成析构函数的条件"><a href="#编译器生成析构函数的条件" class="headerlink" title="编译器生成析构函数的条件"></a>编译器生成析构函数的条件</h2><p>与默认构造函数类似，编译器为一个类生成析构函数的条件为：</p>
<ul>
<li>这个类没有自定义的析构函数或声明析构函数为<code>= default</code>，且</li>
<li>没有用<code>= delete</code>删除析构函数，且</li>
<li>代码中调用到了这个类的析构函数。</li>
</ul>
<p>同样地，如果一个类符合bitwise析构的标准，编译器为它生成的析构函数就是trivial的，就是可以忽略的，此时这个类就没有析构函数了。</p>
<h2 id="析构函数的内容"><a href="#析构函数的内容" class="headerlink" title="析构函数的内容"></a>析构函数的内容</h2><p>析构函数实际就是构造函数的逆过程。参考前面的类C，它的析构函数有以下内容：</p>
<ul>
<li>依次调用析构函数体中的语句。</li>
<li>按<strong>声明</strong>逆序调用每个成员变量的析构函数。</li>
<li>按<strong>声明</strong>逆序调用每个基类子对象的析构函数。</li>
</ul>
<p>同样地，析构函数中也会遇到虚函数的绑定问题。与构造函数类型，所有出现在析构函数中的虚函数，都是静态绑定，因为在析构基类子对象时，派生类自己的成员已经都析构掉了，此时再调用派生类改写的方法大概率会出问题。</p>
<h2 id="有虚函数的类也需要一个虚析构函数的定义"><a href="#有虚函数的类也需要一个虚析构函数的定义" class="headerlink" title="有虚函数的类也需要一个虚析构函数的定义"></a>有虚函数的类也需要一个虚析构函数的定义</h2><p>这里有两个值得注意的点。</p>
<p>第一个，一个类有虚函数，但析构函数不是虚函数，会有大问题的。我们为一个类增加虚函数时，一定是准备实现运行期多态的（否则声明虚函数干什么）。而我们知道运行期多态是要靠基类的指针和引用来触发的。对于下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> p;  <span class="comment">// oops!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~Base</span><br></pre></td></tr></table></figure>

<p>没有调用真正类型的析构函数，是个大问题！尤其是，<code>Derived::name</code>也没有被析构，出现了内存泄漏！</p>
<p>因此，第一个结论：有虚函数的类，一定要有虚的析构函数。</p>
<p>第二个值得注意的点，纯虚基类，析构函数也要有定义，不能是纯虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的问题在于，它的所有派生类在析构时都会调用到<code>Base</code>的析构函数，然而发现这个函数没有定义！编译会因此失败。</p>
<p>因此，第二个结论：不能有纯虚的析构函数，也不能禁止生成析构函数（通过声明为<code>= delete</code>或声明为private却不给定义），一定要给析构函数一个定义（或等待编译器为你生成一个）。</p>
<h2 id="变量的析构时间"><a href="#变量的析构时间" class="headerlink" title="变量的析构时间"></a>变量的析构时间</h2><p>标准规定了一个local变量的析构时间是在它出scope时，这个规则很简单，但有些特殊场景还是要单独说一下：</p>
<ul>
<li><p>全局变量、静态变量的构造时间是在<code>main</code>函数以前，而析构时间则是在<code>main</code>函数以后。同样地，不同编译单元间全局&#x2F;静态变量的析构函数也是不确定的。</p>
</li>
<li><p>临时变量的析构时间为代码中其所在的最外层表达式执行完成后，即：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* s = <span class="built_in">getStringObject</span>().<span class="built_in">c_str</span>();</span><br><span class="line"><span class="comment">// temp obj destructs here and s becomes danling!</span></span><br></pre></td></tr></table></figure>

<p>  这里<code>getStringObject()</code>会返回一个临时的<code>std::string</code>对象，这个对象的生命期会直到完成<code>s</code>的赋值后，下一行调用开始前。</p>
</li>
<li><p>但被赋值给const引用的临时变量，其生命期会与这个const引用保持一致，直到这个引用出scope才析构：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> std::string&amp; s = <span class="built_in">getStringObject</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="comment">// temp obj destructs here</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果<code>goto</code>跳回到函数前面，则这段代码中定义的变量都会被析构：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RETRY:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">goto</span> RETRY; <span class="comment">// name and v will be destructed.</span></span><br></pre></td></tr></table></figure></li>
<li><p>存在短路逻辑的表达式中，编译器需要插入一些代码才能确定临时对象的析构时间：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((s + t) || (u + v)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里面<code>s + t</code>会产生临时对象，但<code>u + v</code>只能说<strong>可能</strong>产生临时对象，因为如果表达式被短路，根本走不到后半截，就不会产生这个临时对象，那么这个临时对象也就不需要被析构。编译期怎么会知道这个表达式会不会被短路呢？因此编译器需要插入一些代码来产生不同分支。这也稍稍增加了些运行期的开销。</p>
</li>
</ul>
<p>当一个函数有着很多出口时，想决定一个local变量的scope就变困难了，编译器需要在每个可能<code>return</code>的地方都加上一些用于析构已经存在的变量，这也会增大binary的体积。</p>
<h2 id="不要手动调用local变量的析构函数"><a href="#不要手动调用local变量的析构函数" class="headerlink" title="不要手动调用local变量的析构函数"></a>不要手动调用local变量的析构函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    b.<span class="built_in">f</span>();</span><br><span class="line">    b.~<span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">new</span>(&amp;b) Derived;</span><br><span class="line">    b.<span class="built_in">f</span>();            <span class="comment">// which f?</span></span><br><span class="line">&#125; <span class="comment">// which dtor?</span></span><br></pre></td></tr></table></figure>

<p>上面是一个很tricky的例子，我们手动调用了<code>b</code>的析构函数，又在其原地构造了一个派生类对象。此时再调用<code>f</code>，调用的会是哪个版本？出scope时，调用的是谁的析构函数？</p>
<p>实际这都是未定义的问题，编译器很可能不会按我们的想法去实现。因此结论就是不要这么用。</p>
<h1 id="异常场景"><a href="#异常场景" class="headerlink" title="异常场景"></a>异常场景</h1><p>当有了异常之后，构造函数和析构函数就更复杂了：</p>
<ul>
<li>构造函数抛了异常后，已经构造完的基类子对象和成员变量要析构，但未构造的成员不要析构，因此编译器需要插入大量代码。</li>
<li>构造函数如果在进入函数体之前抛异常，此时对象本身还不完整（有成员未构造完），那么就不能执行析构函数。</li>
<li>异常会导致函数栈unwind，期间每个还存活的对象都要析构，同样需要插入大量代码。</li>
<li>异常还可能会被catch住，此时unwind停止，不再析构存活对象，又要做一些判断。</li>
<li>当异常未被catch住时，如果unwind导致的析构抛了异常，同时存在两个异常会导致程序crash。</li>
</ul>
<p>因此异常是一种比较昂贵的特性，想实现好异常安全也不那么容易，比如STL容器为了保证修改时的异常安全，做了非常多的事情。</p>
<p>但辩证的看，异常本身还是一种很有用的特性，至少我是支持使用异常的，只要知道上面这些开销，尽量避免错误的使用就好了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/18/cpp-object-model-inheritance-and-polymorphism/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/18/cpp-object-model-inheritance-and-polymorphism/" class="post-title-link" itemprop="url">C++对象模型（四）继承与多态</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-18 23:21:14" itemprop="dateCreated datePublished" datetime="2018-03-18T23:21:14+08:00">2018-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当C++刚刚问世时，它的两大卖点是：</p>
<ul>
<li>与C兼容。</li>
<li>面向对象。</li>
</ul>
<p>而说到面向对象时，就绕不开多态。说到多态，就绕不开继承。</p>
<p>所谓多态，即同样的代码，不同的行为。根据这种行为差异的发生时机，我们把多态分成了编译时多态和运行时多态。继承能实现的就是运行时多态。</p>
<p>本文想讨论的是C++为继承和运行时多态准备了什么样的对象模型</p>
<ul>
<li>注1：本文中的“多态”特指“运行时多态”。</li>
<li>注2：本文不讨论虚继承及其背后的对象模型。</li>
<li>注3：本文主要内容来自<a target="_blank" rel="noopener" href="https://book.douban.com/subject/10427315/">《深入探索C++对象模型》</a>。</li>
</ul>
<h1 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h1><h2 id="简单对象模型"><a href="#简单对象模型" class="headerlink" title="简单对象模型"></a>简单对象模型</h2><p>第一种模型十分简单，每个对象就是一个表格，其中每个slot按成员的声明顺序指向对应的成员，包括成员函数与成员变量。</p>
<p>即对于下面的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="built_in">Base</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">int64_t</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">G</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="type">int32_t</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">H</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它的一个对象为：</p>
<p><img src="http://7xipsa.com1.z0.glb.clouddn.com/cpp_object_model_one_member_one_slot.png" alt="one slot per member"></p>
<p>这个模型是为了尽量降低C++编译器的设计复杂度，这样我们不需要知道每个成员的大小，只要知道成员的数量，就能计算出对象本身需要占的空间了。每个成员都有着固定的偏移量，因此如果要实现多态，只要改变这个slot对应的函数地址即可。实际我们可以看到，这个模型下每个函数都可以是虚函数，即派生类可以改写基类的任何函数。</p>
<p>它的缺点也很明显：不与C的struct兼容；访问成员需要至少一次间接寻址，开销大。</p>
<p>没有哪个编译器真的采用了这个模型，但它的思想，即每个成员对应一个slot，被吸收到了“指向成员的指针”中。</p>
<h2 id="双表格对象模型"><a href="#双表格对象模型" class="headerlink" title="双表格对象模型"></a>双表格对象模型</h2><p>第二种模型使用了两个表格，一个对应成员函数，一个对应成员变量，而对象内则只有指向这两个表格的指针。</p>
<p>对于上面的<code>Base</code>类，新的对象模型为：</p>
<p><img src="http://7xipsa.com1.z0.glb.clouddn.com/cpp_object_model_double_table.png" alt="double_table"></p>
<p>这个模型的好处是令所有对象都有着相同的大小和表现形式。它也是一种停留在理论中的模型，但“函数表格”这一思想却启发了后面的虚表模型。</p>
<h2 id="虚表对象模型"><a href="#虚表对象模型" class="headerlink" title="虚表对象模型"></a>虚表对象模型</h2><p>Stroustrup在设计C++时的一个理念就是，让用户不使用的特性零开销。C++的class就体现了这一点。</p>
<p>从演化路径来看，从C的struct到C++的class，大致过程为：</p>
<p>纯数据的结构体 -&gt; 数据+操作的抽象数据类型 -&gt; 能表现多态的类型。</p>
<p>参考之前的文章，我们可以看到：</p>
<ul>
<li>纯数据的结构体，对应C++中的标准布局类，其相比C的struct没有任何额外开销。</li>
<li>抽象数据类型（ADT），对应C++中的无虚函数的class，其成员变量均有着固定的偏移，与纯结构体相比无额外开销；其成员函数不占用对象本身体积，且调用一个成员函数与调用一个全局函数相比也无额外开销。</li>
</ul>
<p>现在到了最后一种，当class需要能支持多态，我们该如何设计，来保证上面这两种使用方式不受影响？</p>
<p>Stroustrup选择了一种折衷的方案，即：</p>
<ul>
<li>每个有虚函数的类型对应一个表格，称为虚表，其中每个slot对应一个虚函数的实际地址。另外虚表的第0个slot指向了这个类型的<code>type_info</code>，用于RTTI。</li>
<li>有虚函数的对象内会增加一个指向虚表的指针，这样在运行时可以通过虚表跳转来实现多态。</li>
</ul>
<p>对于上面的<code>Base</code>类，虚表对象模型为：</p>
<p><img src="http://7xipsa.com1.z0.glb.clouddn.com/cpp_object_model_vtpr.png" alt="vtpr"></p>
<p>当我们不向class中增加虚函数时，编译器不会生成虚表，也不会向对象内增加一个虚表指针，一切都和原来一样。当我们加入虚函数，编译器才会为了这种运行时特性而做上述工作。</p>
<p>之所以不把虚表直接放到对象中，是为了避免对象体积太大，因此我们宁愿多一次虚表指针的跳转。</p>
<p>这个模型下每个成员变量就在对象中，因此在定义类时我们要能看到每个成员变量的布局，知道它的大小，因此无论哪个成员变量发生了变化，我们都要重新编译、链接。这是为了运行效率而付出的代价。</p>
<p>标准中并没有规定编译器一定要这么实现，但目前几乎所有编译器都采用了这种虚表模型，且几乎都选择了把虚表指针放到对象头部（而CFront则放到尾部）。</p>
<h3 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h3><p>以下内容参考GCC的实现，部分脑补，总之理论上是个可以工作的模型。</p>
<p>每个有虚函数的类都对应着一个单独的虚表，而这个类的所有对象中只有指向它的指针。</p>
<p>非派生类型的虚表长度为N+2，其中N为虚函数的个数，按虚函数声明顺序对应，另外的2则分别为第0个位置的<code>type_info*</code>，和最后一个位置的<code>NULL</code>。</p>
<p>派生类型的虚表长度为S0+S1+…+N+1，其中S0、S1等分别为其第0个基类、第1个基类等的虚表长度，N为该派生类型自己增加的虚函数数量，1是最后一个位置的<code>NULL</code>（如果N不为0的话）。按上一条，S0、S1的长度是N0+2、N1+2，已经包含了<code>type_info*</code>和<code>NULL</code>，因此派生类的虚表中有K个<code>type_info*</code>，且都指向派生类自己的<code>type_info</code>，这里K是其基类数量。</p>
<p>因此派生类的虚表取不同的偏移，就可以得到与其某个基类完全兼容的虚表，但其中每个slot指向的函数则可能是派生类自己的实现。</p>
<h2 id="单继承下的对象模型"><a href="#单继承下的对象模型" class="headerlink" title="单继承下的对象模型"></a>单继承下的对象模型</h2><p>从前文中我们知道派生类对象中会有一个基类的子对象，而标准规定了这个基类子对象要“有其完整原样性”，即与一个独立的基类对象有着完全相同的性质。</p>
<p>编译器要首先保证这一点，再去安排派生类对象自己的成员。标准未规定基类子对象在派生类对象中该处于什么位置，但几乎所有编译器都将基类子对象放到了派生类对象的头部。</p>
<h3 id="无虚函数"><a href="#无虚函数" class="headerlink" title="无虚函数"></a>无虚函数</h3><p>当基类与派生类均无虚函数时，也就意味着派生类对象中不需要有虚表。此时的派生类对象的内存布局见<a href="/2018/03/11/cpp-object-model-struct/#%E4%B8%BAstruct%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%97%A0%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%9D%9E%E8%99%9A%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%B1%BB">为struct添加一个无虚函数的非虚继承基类</a>。</p>
<p>这种继承有一个很不一样的地方：它没有产生多态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> Base&amp; b)</span> </span>&#123;</span><br><span class="line">    b.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，当我们在<code>Func</code>中调用<code>b.Print()</code>时，编译器知道<code>Base::Print</code>不是虚函数，也就意味着它不可能被任何派生类改写，因此编译器会直接将其绑定到<code>Base::Print</code>上，即<code>Func</code>的运行时行为在编译时已经确定了。</p>
<h3 id="基类有虚函数"><a href="#基类有虚函数" class="headerlink" title="基类有虚函数"></a>基类有虚函数</h3><p>当基类有虚函数时，意味着派生类也有虚函数，即派生类对象与其中的基类子对象都需要有一个虚表指针，且要指向正确的虚表。</p>
<p>前面我们介绍虚表的时候提到，对派生类的虚表加上不同的偏移量，就能得到与其每个基类虚表完全兼容的虚表，其中第0个基类的偏移量就是0。因此单继承下，派生类对象中也不需要有多个虚表指针，只要头部放置一个虚表指针，就可以同时满足基类子对象与派生类对象的需求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> x;</span><br><span class="line">    <span class="type">int32_t</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int32_t</span> z;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    Base&amp; b = d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(Base):%d sizeof(Derived):%d &amp;d:%x &amp;b:%x\n&quot;</span>, <span class="built_in">sizeof</span>(Base), <span class="built_in">sizeof</span>(Derived), &amp;d, &amp;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sizeof(Base):24 sizeof(Derived):24 &amp;d:edcc4968 &amp;b:edcc4968</span><br></pre></td></tr></table></figure>

<p>此时<code>Derived</code>对象长成这样：</p>
<p><img src="http://7xipsa.com1.z0.glb.clouddn.com/cpp_object_model_single_inherit.png" alt="single"></p>
<p>可以看到：</p>
<ul>
<li>基类子对象的偏移确实是0，说明它与派生类对象共享了虚表指针。</li>
<li>基类子对象与派生类自己的成员之间没有加padding，这与标准布局差别很大，更紧凑了。实际上标准没有对非标准布局有任何明确规定，且对于有虚函数的类型，直接bitwise操作本身就是未定义行为，因此编译器就可以自由选择一种比较紧凑的布局，而不需要担心我们直接操作基类子对象时把派生类的成员变量给破坏了。</li>
</ul>
<h3 id="基类无虚函数，派生类有虚函数"><a href="#基类无虚函数，派生类有虚函数" class="headerlink" title="基类无虚函数，派生类有虚函数"></a>基类无虚函数，派生类有虚函数</h3><p>如果基类没有虚函数，那么基类子对象就不需要有虚表指针；派生类有虚函数，那么派生类对象就需要有虚表指针。因此派生类对象内还是需要一个虚表指针。</p>
<p>GCC的实现是仍然把虚表指针放到派生类对象头部，而基类子对象在其后，此时基类子对象有一个指针的偏移。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> x;</span><br><span class="line">    <span class="type">int32_t</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int32_t</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sizeof(Base):16 sizeof(Derived):32 &amp;d:e1855960 &amp;b:e1855968</span><br></pre></td></tr></table></figure>

<p>此时<code>Derived</code>对象长成这样：<br><img src="http://7xipsa.com1.z0.glb.clouddn.com/cpp_object_model_single_base_nonvirtual.png" alt="base_non_virtual"></p>
<p>可以看到：</p>
<ul>
<li>基类子对象的偏移量为8。</li>
<li>基类子对象后加了padding。此时基类是平凡类，是有可能被人直接以bitwise的方式操作，不加padding就会有危险。</li>
</ul>
<h2 id="多继承下的多对象模型"><a href="#多继承下的多对象模型" class="headerlink" title="多继承下的多对象模型"></a>多继承下的多对象模型</h2><p>当派生类有多个基类时，每个基类自身可能有虚函数，可能没有。对于有虚函数的基类，派生类对象需要为其准备一个虚表指针。对于没有虚函数的基类，则不需要有虚表指针。</p>
<p>如果第0个基类是有虚函数的，那么派生类对象就可以与其共享虚表指针。因此GCC会将其第一个有虚函数的基类子对象放到派生类对象的头部，从而节省一个虚表指针。</p>
<p>而后面的基类则因为其虚表在派生类虚表中的偏移量不为0，无法共享虚表指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> x;</span><br><span class="line">    <span class="type">int32_t</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line">    <span class="type">int32_t</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sizeof(Base1):24 sizeof(Base2):4 sizeof(Derived):32 &amp;d:e5fe3960 &amp;b1:e5fe3960 &amp;b2:e5fe3974</span><br></pre></td></tr></table></figure>

<p>即使我们把<code>public Base1, public Base2</code>换成<code>public Base2, public Base1</code>，结果也没有任何变化。</p>
<p>此时<code>Derived</code>对象长成这样：<br><img src="http://7xipsa.com1.z0.glb.clouddn.com/cpp_object_model_one_virtual_one_nonvirtual.png"></p>
<p>而当我们为<code>Base2</code>也添加一个虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> z;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">G</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line">    <span class="type">int32_t</span> r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">G</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sizeof(Base1):24 sizeof(Base2):16 sizeof(Derived):40 &amp;d:e2c5d958 &amp;b1:e2c5d958 &amp;b2:e2c5d970</span><br></pre></td></tr></table></figure>

<p>此时<code>Derived</code>对象长成这样：<br><img src="http://7xipsa.com1.z0.glb.clouddn.com/cpp_object_model_both_virtual.png"></p>
<p>可以看到：</p>
<ul>
<li>每个基类子对象都有自己的虚表指针。其中第0个基类子对象的虚表指针与派生类对象本身是共享的。</li>
<li>但两个虚表指针实际都指向派生类自己的虚表，只不过指向的位置不同。</li>
<li>除了第0个基类子对象，其它基类子对象的偏移量都不是0。</li>
</ul>
<h1 id="指向成员的指针"><a href="#指向成员的指针" class="headerlink" title="指向成员的指针"></a>指向成员的指针</h1><p>C++中有一类指针比较特殊，它们是指向类型成员的指针，比如上例中的<code>&amp;Derived::x</code>、<code>&amp;Derived::G</code>等，它们的类型分别是<code>int64_t Base1::*</code>和<code>void (Derived::*)()</code>。这些指针是不能单独使用的，必须要通过一个对应类型的对象来解引用，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">d.x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> px = &amp;Derived::x;</span><br><span class="line">d.*px = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pf = &amp;Derived::F;</span><br><span class="line"><span class="type">int</span> ret = d.*<span class="built_in">pf</span>();</span><br></pre></td></tr></table></figure>

<p>这里我们已经能感觉到它们的不一样了。</p>
<p>指向成员的指针，真的是指针吗？</p>
<p>是指针，但与普通的指针不一样：</p>
<ul>
<li>不能转换为<code>void*</code>或<code>intptr_t</code>等类型。</li>
<li>与普通指针的大小不一定相同，比如在我的环境（64位clang）下，<code>&amp;Derived::x</code>是8字节，而<code>&amp;Derived::F</code>则是16字节。</li>
<li>其值不一定表示地址。</li>
</ul>
<p>对于第三条，大致有以下规则：</p>
<ul>
<li>指向成员变量的指针，其值为该变量在对象内的偏移量，比如<code>&amp;Derived::x</code>就是8，而<code>&amp;Base1::x</code>则是0，这样我们能通过一个对象直接寻址到这个变量。</li>
<li>指向非虚成员函数的指针，其大小仍是16字节（我的环境中），但其值真的是这个函数的入口地址，而不是偏移量。</li>
<li>指向虚的成员函数的指针，其值是该函数在该类型的虚表中的偏移量。我们知道虚表的第0位不是虚函数，因此任何指向虚函数的合法指针都不可能是0，通过这一点我们也保证了，如果一个指向虚函数的成员指针为0，那么它一定是空指针。</li>
</ul>
<p>实际上指向成员函数的指针占两个普通指针的长度，其中就包含了一些辅助信息，来帮助我们在运行时无论遇到虚函数指针还是非虚函数指针，都能正确跳转。</p>
<h1 id="static-cast、dynamic-cast、reinterpret-cast"><a href="#static-cast、dynamic-cast、reinterpret-cast" class="headerlink" title="static_cast、dynamic_cast、reinterpret_cast"></a><code>static_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code></h1><p>对于基类和派生类，我们有两种cast，分别是down-cast与up-cast，即基类-&gt;派生类和派生类-&gt;基类。</p>
<h2 id="up-cast"><a href="#up-cast" class="headerlink" title="up-cast"></a>up-cast</h2><p>up-cast通常不需要我们显式调用，因为这就是多态正常的使用方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(Base&amp; b)</span> </span>&#123;</span><br><span class="line">    b.<span class="built_in">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="built_in">Func</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们把<code>Derived&amp;</code>传给<code>Func</code>，后者看到的却是一个<code>Base&amp;</code>，这里就是发生了up-cast，也是一次隐式转换。如果在某个地方，我们要显式做up-cast，就要使用<code>static_cast</code>了。</p>
<p>重点来了：当编译器做up-cast时，它会根据基类子对象在派生类对象中的偏移量，修改对应指针的值。即当代码里写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base* pb = pd;</span><br></pre></td></tr></table></figure>

<p>时，实际发生的是（假设翻译成C）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* p = pd;</span><br><span class="line">Base* pb = (Base*)(p == <span class="number">0</span>? <span class="number">0</span>: p + offset);</span><br></pre></td></tr></table></figure>

<p>因此每次up-cast都会有一次分支。而对于基类无虚函数派生类有虚函数，以及多基类场景下，我们都能看到地址发生了变化。</p>
<p>C++标准保证了即使我们使用C风格的转换（即<code>(Base*)pd</code>），编译器也会在其上进行正确的偏移。</p>
<p>而如果我们使用<code>interpret_cast</code>就得不到正确的结果了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">Base2* x = &amp;d;</span><br><span class="line">Base2* y = <span class="built_in">reinterpret_cast</span>&lt;Base2*&gt;(&amp;d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x:%p y:%p\n&quot;</span>, x, y);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x:0x7ffee7990968 y:0x7ffee7990950</span><br></pre></td></tr></table></figure>

<p>在我的环境中，这里还有个warning，提醒我换成<code>static_cast</code>。</p>
<p>因此结论是：如果要做up-cast，一定不能用<code>reinterpret_cast</code>，要用<code>static_cast</code>，最差也要用C风格的转换。</p>
<h2 id="down-cast"><a href="#down-cast" class="headerlink" title="down-cast"></a>down-cast</h2><p>而down-cast就是基类指针转派生类指针。这里正确的做法是使用<code>dynamic_cast</code>，它会做以下事情：</p>
<ul>
<li>通过基类指针找到其虚表。</li>
<li>从虚表的第0位找到<code>type_info*</code>。</li>
<li>对比<code>type_info*</code>与目标类型，如果无法转换，则返回<code>nullptr</code>。</li>
<li>根据基类子对象在派生类对象中的偏移，计算出派生类指针并返回。</li>
</ul>
<p>而有些人会使用<code>static_cast</code>或C风格的转换来做down-cast。它们的问题都在于：不会做前三步的检查，只会做最后一步。</p>
<p>这就导致了，如果转换失败，<code>dynamic_cast</code>会返回<code>nullptr</code>，而<code>static_cast</code>或C风格转换则只会返回一个看似正确地减去了偏移量，实际指向了不知道哪里的派生类指针。</p>
<p>当然，<code>reinterpret_cast</code>就更不对了：它连偏移量都不会算。</p>
<h1 id="警惕Slicing"><a href="#警惕Slicing" class="headerlink" title="警惕Slicing"></a>警惕Slicing</h1><p>在<a href="/2018/03/11/cpp-object-model-struct/#%E4%B8%BAstruct%E6%B7%BB%E5%8A%A0%E8%99%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">为struct添加虚成员函数</a>中我们提到，只有通过引用或指针调用虚函数，编译器才会走虚表，才会有多态。实际上，为了与C兼容，保证运行效率，标准规定了这一点。因此直接操作对象时，我们只能得到确定的结果，而不是预期中的运行时多态。</p>
<p>这里有一个陷阱：当我们用派生类对象去赋值或初始化一个基类对象时，派生类的信息会被抹掉，最终我们仅仅得到一个基类对象。这种现象叫Slicing。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">Base2 b2 = d;</span><br><span class="line">b2.<span class="built_in">G</span>();</span><br></pre></td></tr></table></figure>

<p>也许我们预期<code>b2.G()</code>会调用<code>Derived::G</code>，但实际此时<code>b2</code>完完全全就是<code>Base2</code>的对象，因此它只会调用<code>Base2::G</code>。</p>
<p>这么做的原因是，<code>b2</code>是一个栈上对象，给它分配的空间就只有<code>sizeof(Base2)</code>这么多，因此它只能是一个<code>Base2</code>对象，而无法是派生类的对象。</p>
<p>这也是一个函数传递要传指针或引用的理由（除了开销与启用多态外），避免Slicing。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/17/redis-on-the-respberry-pi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/17/redis-on-the-respberry-pi/" class="post-title-link" itemprop="url">[翻译] Redis on the Raspberry Pi: adventures in unaligned lands</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-17 15:05:18" itemprop="dateCreated datePublished" datetime="2018-03-17T15:05:18+08:00">2018-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="http://antirez.com/news/111">原文地址</a></p>
<p>在售出1000万台设备，实际上是诸如传感器和显示器这样无数不同的应用和辅助设备后，可以说树莓派不仅仅是取得了成功，它还成为了一种程序员最喜爱的嵌入式实验平台。像是Pi zero这样的产品也在成为创造硬件产品的平台，且不会引入设计、构建、为车载设备写软件等方面的风险和开销。</p>
<p>同样地，我也认同Redis是一个程序员乐于去冒险、实验、构建新事物的平台。而且，能用于嵌入式&#x2F;物联网应用的设备，通常会有暂时或长期存储数据的需求，像是从传感器接收到的数据，需要在这台设备上运算的数据，或是要发往远程服务器的数据。Redis正在加入一种Stream数据类型，非常适合流式数据和时间序列存储，撰写本文时（2017年初）这个特性快要完成了，后续工作会在接下来几周内开始。Redis现存的数据结构，以及新增的Stream类型，以及它较小的内存使用，以及它即使在小型硬件（低功耗）上也能提供相当不错的性能，都让Redis看起来非常适合应用在树莓派，进而是其它小型ARM设备上。中间缺失的部分也很明显：在树莓派上把Redis跑起来。</p>
<p>树莓派的一个很酷的特点就是，它的开发环境不像过去的嵌入式系统那样，它上面跑的就是正常的Linux，还包括各种Debian系的工具。简单地说在树莓派上适配Redis不算很困难。Linux程序移植到树莓派上最常见的问题就是性能或内存占用不匹配，但在Redis上这不是问题，因为它本身就被设计为：空实例只占用1MB内存，且查询请求会走内存，因此它足够快，也不会给闪存太高的压力，而且在需要持久化时，它只会用AOF（Append Only File）。但树莓派上用的是ARM处理器，意味着我们要小心处理未对齐的内存访问。</p>
<p>本文会展示我为了让Redis能愉快地跑在树莓派上都做了什么，我会试着给出一个如何应对那些不能透明地处理非对齐内存访问的平台上（不像x86）的概述。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/03/17/redis-on-the-respberry-pi/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/15/cpp-object-model-pod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/15/cpp-object-model-pod/" class="post-title-link" itemprop="url">C++对象模型（三）POD</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-15 18:37:59" itemprop="dateCreated datePublished" datetime="2018-03-15T18:37:59+08:00">2018-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>注：本节不讨论<code>union</code>。</p>
<h1 id="Scalar-Type"><a href="#Scalar-Type" class="headerlink" title="Scalar Type"></a>Scalar Type</h1><p>第一个概念，Scalar Type，即标量类型。</p>
<p>所谓标量，就是一个数字，而标量类型，就是可以表示为一个数字的类型。</p>
<p>C++的标量类型为：</p>
<ul>
<li>各种整数&#x2F;浮点类型，如<code>int8_t</code>、<code>uint32_t</code>、<code>char</code>、<code>float</code>等，可满足<code>std::is_arithmetic&lt;T&gt;</code>为true。</li>
<li>枚举类型，可满足<code>std::is_enum&lt;T&gt;</code>为true。</li>
<li>各种指针类型，包括<code>std::nullptr_t</code>，可满足<code>std::is_pointer&lt;T&gt;</code>或<code>std::is_member_pointer&lt;T&gt;</code>为true。</li>
</ul>
<p>以上类型都属于标量类型，都可满足<code>std::is_scalar&lt;T&gt;::value</code>为true。</p>
<h1 id="Aggregate-Type"><a href="#Aggregate-Type" class="headerlink" title="Aggregate Type"></a>Aggregate Type</h1><p>第二个概念，Aggregate Type，即聚合类型。</p>
<p>所谓聚合类型，就是可以使用<code>= &#123;v1, v2, v3&#125;</code>这样语法（注意不是C++11的<code>std::initializer_list</code>特性）进行初始化或赋值的类型，对应C的数组和struct。</p>
<p>C++的聚合类型为：</p>
<ul>
<li>所有数组类型。</li>
<li>满足以下条件的类（包括<code>class</code>、<code>struct</code>）：<ul>
<li>所有非静态成员变量的访问权限都是<code>public</code>。</li>
<li>没有用户自定义的构造函数（但允许使用<code>= default</code>来显式使用编译器合成的构造函数，或使用<code>= delete</code>来显式禁止某种构造函数）。</li>
<li>没有基类（C++17后允许有<code>public</code>的非虚基类）。</li>
<li>没有虚函数。</li>
<li>成员变量没有默认初始化式（不在构造函数里那种）（C++11新增，但似乎C++14又去掉了此限制）。</li>
</ul>
</li>
</ul>
<p>根据上面的定义，聚合类型还有下面的几个特点：</p>
<ul>
<li>不要求其所有非静态成员变量均为聚合类型。</li>
<li>对静态成员没有任何限制。</li>
<li>只对构造函数有限制，对析构函数、赋值函数等无限制。</li>
<li>非聚合类型的数组也是聚合类型。</li>
</ul>
<p>当我们写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type a[m] = &#123;b0, b1, ..., bn-1&#125;;</span><br></pre></td></tr></table></figure>

<p>时：</p>
<ul>
<li>若m &#x3D;&#x3D; n，则会发生b0到a[0]、b1到a[1]等等n次复制初始化。</li>
<li>若m &lt; n，则报错。</li>
<li>若m &gt; n，则a[0]-a[n-1]发生复制初始化，而a[n]-a[m-1]则发生默认初始化。</li>
<li>若m为空，则a的长度会被设定为n，同样发生n次复制初始化。</li>
</ul>
<p>对于下面的聚合类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    TypeA a;</span><br><span class="line">    TypeB b;</span><br><span class="line">    TypeC c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S s = &#123;a<span class="number">&#x27;</span>, b<span class="number">&#x27;</span>, c<span class="number">&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>时：</p>
<ul>
<li>若<code>&#123;&#125;</code>内元素数量与<code>S</code>中非静态成员变量数量相等，会按a’-&gt;a、b’-&gt;b、c’-&gt;c的方式进行复制初始化。</li>
<li>若<code>&#123;&#125;</code>内元素数量更多，则报错。</li>
<li>若<code>S</code>中非静态成员变量数量更多，则后面的成员发生默认初始化。</li>
</ul>
<p>在初始化时：</p>
<ul>
<li>若发生复制初始化，则会调用相应类型的复制构造函数或赋值函数。</li>
<li>若列表中某项为表达式，则复制&#x2F;赋值时允许发生隐式转换（C++11开始要求不能是narrow转换）。</li>
<li>若列表中某项本身也是个<code>&#123;&#125;</code>列表，则要求对应的数组元素&#x2F;非静态成员变量也是聚合类型，尝试递归聚合赋值。</li>
<li>标量类型的默认初始化会将其初始化为0、0.0、false等。</li>
<li>引用类型的默认初始化会报错。</li>
</ul>
<p>在对聚合类型（非数组）做列表赋值时，我们还可以指定成员的名字，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a = &#123;.x = <span class="number">1</span>, .z = <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>它有以下特点：</p>
<ul>
<li>列表中名字顺序必须符合成员顺序，即<code>&#123;.z = 2, .x = 1&#125;</code>是不行的。（注意，<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/c/language/struct_initialization">C允许乱序，还允许其它多种初始化方式</a>，但C++不允许）</li>
<li>列表中元素数量可以少于成员数量，未在列表中出现的成员发生默认初始化，即上例中<code>a.y</code>为0。</li>
</ul>
<h1 id="Trivial-Type"><a href="#Trivial-Type" class="headerlink" title="Trivial Type"></a>Trivial Type</h1><p>第三个概念，Trivial Type，即平凡类型。</p>
<p>所谓平凡类型，可以认为是有bitwise语义的类型，即可以直接按字节复制的类型。C中的所有类型都是Trivial Type。</p>
<p>Trivial Type有两个标准：</p>
<ul>
<li>能trivial静态构造，即要有一个trivial的默认构造函数。</li>
<li>能trivial拷贝，即满足Trivial Copyable标准。</li>
</ul>
<p>Trivial Copyable类型即是满足<code>std::is_trivially_copyable&lt;T&gt;::value</code>为true的类型，它要求：</p>
<ul>
<li>所有复制构造、赋值函数要么是trivial的，要么是deleted。</li>
<li>所有移动构造、赋值函数要么是trivial的，要么是deleted。</li>
<li>至少有一个非deleted复制或移动的构造或赋值函数。</li>
<li>析构函数为trivial，且非deleted。</li>
</ul>
<p>构造函数、析构函数、复制构造&#x2F;赋值函数、移动构造&#x2F;赋值函数的trivial是指：</p>
<ul>
<li>满足bitwise语义。</li>
<li>要么是编译器隐式合成的版本。</li>
<li>要么通过<code>= default</code>显式使用编译器的合成版本。</li>
</ul>
<p>以上条件也就意味着一个Trivial Type：</p>
<ul>
<li>不能有虚函数（会导致构造函数等失去bitwise语义）。</li>
<li>不能有虚基类（同上）。</li>
<li>如果有基类，基类也要是Trivial Type。</li>
<li>不能有自定义的构造、析构、复制、移动函数。</li>
<li>不能有非Trivial Type类型的非静态成员变量。</li>
</ul>
<p>标量类型、Trivial Type的数组也是Trivial Type。</p>
<p>Trivial Type是用来区分那些可以像C一样通过<code>memset</code>、<code>memcpy</code>等函数直接构造和复制的类型，C++11中增加了<code>std::is_trivial</code>模板来判断一个类型是否是trivial的。</p>
<p>注意，Trivial Type还有以下特点：</p>
<ul>
<li>不限制成员变量的访问限制，即<code>public</code>、<code>protected</code>、<code>private</code>都可以。</li>
<li>只要求默认构造函数是trivial的，对其它构造函数没有要求。</li>
</ul>
<h1 id="Standard-Layout-Type"><a href="#Standard-Layout-Type" class="headerlink" title="Standard Layout Type"></a>Standard Layout Type</h1><p>第四个概念，Standard Layout Type，即标准布局类型。</p>
<p>标准布局的目的是定义一种与C兼容的内存布局，满足标准布局的类型即为标准布局类型，Standard Layout Type。</p>
<p>关于不同C++类型的内存布局，可以见上一篇文章<a href="/2018/03/11/cpp-object-model-struct/">C++对象模型（二）struct&#x2F;class的内存布局</a>。</p>
<p>C++的Standard Layout Type要求：</p>
<ul>
<li><p>所有非静态成员变量有着相同的访问权限。</p>
</li>
<li><p>没有虚函数或虚基类。</p>
</li>
<li><p>没有引用类型的非静态成员变量。</p>
</li>
<li><p>所有基类和非静态成员变量本身也是Standard Layout Type。</p>
</li>
<li><p>该类型与其所有基类中，最多只能有一个类型有非静态成员变量（其它类型都需要是空类型），即所有非静态成员变量都在一个类型中。</p>
</li>
<li><p>第一个非静态成员变量（包括继承自基类的成员）其类型不能与任一空基类相同（影响空基类优化）。</p>
</li>
<li><p>该类型的继承树中同一类型不能出现多次。</p>
<p>  例子：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Q</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: Q &#123;&#125;；</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span>: Q &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">U</span>: S, T &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>  <code>U</code>的继承树中<code>Q</code>出现了两次，则<code>Q</code>、<code>S</code>、<code>T</code>都是Standard Layout Type，但<code>U</code>不是。</p>
</li>
</ul>
<p>相同访问权限的原因：标准只规定了同一个section内成员的顺序，未规定不同section之间的顺序，因此若非静态成员变量分布在不同section下，无法给出一个确定的布局。</p>
<p>所有非静态成员变量都在一个类型中的原因：标准未规定基类子对象的位置，因此不同基类、或基类与子类的非静态成员变量间的顺序是未定义的。</p>
<p>没有虚函数或虚基类的原因：虚函数和虚基类会影响类的内存布局，但标准未规定其实现方式，因此有虚函数或虚基类的类型无法给出一个确定的布局。</p>
<p>第一个非静态成员变量不能与空基类类型相同的原因：标准规定同时存在的两个变量不能有相同地址，若应用空基类优化，则第一个非静态成员变量的地址与对象地址相同，也与所有空基类地址相同，若其中有相同类型，则导致该地址同时对应了多个变量。</p>
<p>C++11新增了<code>std::is_standard_layout</code>来判断一个类型是不是Standard Layout Type。</p>
<h2 id="标准布局"><a href="#标准布局" class="headerlink" title="标准布局"></a>标准布局</h2><p>C++的标准布局实际就是C中struct的布局，对于一个标准布局类的对象：</p>
<ul>
<li>其本身的地址与其所有基类子对象的地址相同，即基类子对象的地址无偏移。</li>
<li>其各个非静态成员变量的位置按声明顺序从对象地址开始由低到高排列。</li>
<li>其第一个非静态成员变量的地址与对象地址相同。</li>
<li>其各个非静态成员变量的地址均满足对齐要求。</li>
</ul>
<h1 id="POD-Type"><a href="#POD-Type" class="headerlink" title="POD Type"></a>POD Type</h1><p>最后一个概念，POD Type，即Plain Old Data Type，即可导出，可跨语言使用的类型（通常也意味着与C二进制兼容）。</p>
<p>一个POD类型为：</p>
<ul>
<li>标量类型。</li>
<li>满足以下条件的自定义类型：<ul>
<li>C++11之前：<ul>
<li>聚合类型。</li>
<li>没有非POD类型的非静态成员变量。</li>
<li>没有引用类型的非静态成员变量。</li>
<li>没有自定义的构造函数或析构函数。</li>
</ul>
</li>
<li>C++11之后：<ul>
<li>是平凡类。</li>
<li>是标准布局类。</li>
<li>没有非POD类型的非静态成员变量。</li>
</ul>
</li>
</ul>
</li>
<li>POD类型的数组。</li>
</ul>
<p>可以看到POD的标准在C++11前后发生了很大的变化。C++11里放宽了对POD的限制，且根据这些限制的目的，提出了平凡类和标准布局类这两个更清晰的概念。在C++20后POD这个概念本身都会被去掉，而是在不同场合直接使用平凡类、标准布局类等概念。</p>
<p>一个类型可以只是平凡类或只是标准布局类：</p>
<ul>
<li>如果是平凡类，则意味着它可以直接通过<code>memcpy</code>、<code>memset</code>等函数来操作。</li>
<li>如果是标准布局类，则意味着它的布局是确定的，可以与其它语言交互。</li>
</ul>
<p>可以用<code>is_pod</code>来判断一个类型是不是POD类型。</p>
<h1 id="POD的用途"><a href="#POD的用途" class="headerlink" title="POD的用途"></a>POD的用途</h1><p>平凡类的用途：</p>
<ul>
<li>平凡类的对象可以与字节流之间安全转换，即：<ul>
<li>若要将对象转为字节流，直接取其地址即可。</li>
<li>若要将字节流转为对象，直接将该地址cast为对象指针即可。</li>
<li>直接通过复制字节的方式复制对象。</li>
</ul>
</li>
<li>安全的静态初始化。<ul>
<li>C++11的<code>thread_local</code>变量可以是非平凡类型，但在某些编译器下会有比较大的性能开销。gcc扩展的<code>__thread</code>只能使用POD类型。</li>
</ul>
</li>
</ul>
<p>标准布局类的用途：</p>
<ul>
<li>跨进程、跨语言使用。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/11/cpp-object-model-struct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/11/cpp-object-model-struct/" class="post-title-link" itemprop="url">C++对象模型（二）struct/class的内存布局</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-11 15:53:13" itemprop="dateCreated datePublished" datetime="2018-03-11T15:53:13+08:00">2018-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>运行环境：x86-64。</li>
<li>编译器：gcc4.8.5。</li>
<li>编译选项：-O2。</li>
<li>语言标准：以c++98为主，兼顾c++11&#x2F;14。</li>
</ul>
<h1 id="c-中的struct与c中的struct"><a href="#c-中的struct与c中的struct" class="headerlink" title="c++中的struct与c中的struct"></a>c++中的struct与c中的struct</h1><p>第一个问题：c++中的struct与c中的struct相同吗？</p>
<p>答案是，有时相同，有时不同。</p>
<h2 id="像c一样定义struct"><a href="#像c一样定义struct" class="headerlink" title="像c一样定义struct"></a>像c一样定义struct</h2><p>如果我们简单的按照c的方式定义一个struct，如c代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    S ss = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    S s = ss;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;size:%d &amp;a-&amp;s:%d, &amp;b-&amp;s:%d &amp;c-&amp;s:%d\n&quot;</span>,</span><br><span class="line">        <span class="keyword">sizeof</span>(s),</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.a - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.b - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.c - (<span class="type">char</span>*)&amp;s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和c++代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S ss = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    S s = ss;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;size:%d &amp;a-&amp;s:%d, &amp;b-&amp;s:%d &amp;c-&amp;s:%d\n&quot;</span>,</span><br><span class="line">        <span class="built_in">sizeof</span>(s),</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.a - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.b - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.c - (<span class="type">char</span>*)&amp;s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别用gcc和g++编译上面两段代码，结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size:24 &amp;a-&amp;s:0, &amp;b-&amp;s:8 &amp;c-&amp;s:16</span><br><span class="line"></span><br><span class="line">size:24 &amp;a-&amp;s:0, &amp;b-&amp;s:8 &amp;c-&amp;s:16</span><br></pre></td></tr></table></figure>

<p>完全一样对不对？再看下汇编指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">400440:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">400444:   41 b8 10 00 00 00       mov    $0x10,%r8d</span><br><span class="line">40044a:   b9 08 00 00 00          mov    $0x8,%ecx</span><br><span class="line">40044f:   31 d2                   xor    %edx,%edx</span><br><span class="line">400451:   be 18 00 00 00          mov    $0x18,%esi</span><br><span class="line">400456:   bf f0 05 40 00          mov    $0x4005f0,%edi</span><br><span class="line">40045b:   31 c0                   xor    %eax,%eax</span><br><span class="line">40045d:   e8 ae ff ff ff          callq  400410 &lt;printf@plt&gt;</span><br><span class="line">400462:   31 c0                   xor    %eax,%eax</span><br><span class="line">400464:   48 83 c4 08             add    $0x8,%rsp</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">400504:   41 b8 10 00 00 00       mov    $0x10,%r8d</span><br><span class="line">40050a:   b9 08 00 00 00          mov    $0x8,%ecx</span><br><span class="line">40050f:   31 d2                   xor    %edx,%edx</span><br><span class="line">400511:   be 18 00 00 00          mov    $0x18,%esi</span><br><span class="line">400516:   bf b0 06 40 00          mov    $0x4006b0,%edi</span><br><span class="line">40051b:   31 c0                   xor    %eax,%eax</span><br><span class="line">40051d:   e8 ae ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">400522:   31 c0                   xor    %eax,%eax</span><br><span class="line">400524:   48 83 c4 08             add    $0x8,%rsp</span><br></pre></td></tr></table></figure>

<p>是不是也完全一样？当我们在c++里像c一样定义struct时，编译器会给我们一个与c的struct完全相同的结构。</p>
<h2 id="为struct添加静态成员"><a href="#为struct添加静态成员" class="headerlink" title="为struct添加静态成员"></a>为struct添加静态成员</h2><p>我们为<code>S</code>添加一个静态成员变量与静态成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> S::d = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>仍然运行上面的<code>main</code>函数，结果就不贴了，我们会发现与c的struct仍然相同。这说明：</p>
<ol>
<li>静态成员变量不会影响struct布局。换句话说，静态成员变量不存在于对象内部。</li>
<li>静态成员方法也不会影响struct布局，即也不存在于对象内部。</li>
</ol>
<h2 id="为struct添加非静态非虚成员函数"><a href="#为struct添加非静态非虚成员函数" class="headerlink" title="为struct添加非静态非虚成员函数"></a>为struct添加非静态非虚成员函数</h2><h3 id="为struct添加构造、析构、复制、移动函数"><a href="#为struct添加构造、析构、复制、移动函数" class="headerlink" title="为struct添加构造、析构、复制、移动函数"></a>为struct添加构造、析构、复制、移动函数</h3><p>假设我们向<code>S</code>中添加上述函数，上面的结论会有什么变化？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">S</span>(<span class="type">int8_t</span> x, <span class="type">int64_t</span> y, <span class="type">int32_t</span> z) &#123;</span><br><span class="line">        a = x;</span><br><span class="line">        b = y;</span><br><span class="line">        c = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">S</span>() &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">        b = <span class="number">0</span>;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">S</span>(<span class="type">const</span> S&amp; s) &#123;</span><br><span class="line">        a = s.a;</span><br><span class="line">        b = s.b;</span><br><span class="line">        c = s.c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">S</span>(S&amp;&amp; s) &#123;</span><br><span class="line">        a = s.a;</span><br><span class="line">        b = s.b;</span><br><span class="line">        c = s.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行结果没有任何变化，汇编指令也完全相同。这说明struct加上构造函数并没有改变它的布局，即：</p>
<ul>
<li>以上函数均不存在于对象内部。</li>
<li>以上函数均未带来额外开销。</li>
</ul>
<p>但我们不能说这些函数对struct没有任何影响，后面会讲到，当我们添加了这些函数后：</p>
<ul>
<li>这个struct不再满足POD的定义，即不再有bitwise语义。</li>
<li>如果上述函数未被定义为内联（inline）函数，则其会带来额外开销。</li>
</ul>
<h3 id="为struct添加普通非虚函数"><a href="#为struct添加普通非虚函数" class="headerlink" title="为struct添加普通非虚函数"></a>为struct添加普通非虚函数</h3><p>我们比较以下两种写法。写法一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(S* s)</span> </span>&#123;</span><br><span class="line">    s-&gt;a += <span class="number">1</span>;</span><br><span class="line">    s-&gt;b -= <span class="number">1</span>;</span><br><span class="line">    s-&gt;c *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:%d b:%ld c:%d\n&quot;</span>, s-&gt;a, s-&gt;b, s-&gt;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与写法二：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        b -= <span class="number">1</span>;</span><br><span class="line">        c *= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a:%d b:%ld c:%d\n&quot;</span>, a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应的<code>main</code>函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    s.<span class="built_in">Func</span>(); <span class="comment">// or Func(&amp;s);</span></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;size:%d &amp;a-&amp;s:%d, &amp;b-&amp;s:%d &amp;c-&amp;s:%d\n&quot;</span>,</span><br><span class="line">        <span class="built_in">sizeof</span>(s),</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.a - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.b - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.c - (<span class="type">char</span>*)&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法一的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a:2 b:1 c:6</span><br><span class="line">size:24 &amp;a-&amp;s:0, &amp;b-&amp;s:8 &amp;c-&amp;s:16</span><br><span class="line"></span><br><span class="line">  400500:   48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  400504:   48 89 e7                mov    %rsp,%rdi</span><br><span class="line">  400507:   c6 04 24 01             movb   $0x1,(%rsp)</span><br><span class="line">  40050b:   48 c7 44 24 08 02 00    movq   $0x2,0x8(%rsp)</span><br><span class="line">  400512:   00 00</span><br><span class="line">  400514:   c7 44 24 10 03 00 00    movl   $0x3,0x10(%rsp)</span><br><span class="line">  40051b:   00</span><br><span class="line">  40051c:   e8 1f 01 00 00          callq  400640 &lt;_Z4FuncP1S&gt;</span><br><span class="line">  400521:   41 b8 10 00 00 00       mov    $0x10,%r8d</span><br><span class="line">  400527:   b9 08 00 00 00          mov    $0x8,%ecx</span><br><span class="line">  40052c:   31 d2                   xor    %edx,%edx</span><br><span class="line">  40052e:   be 18 00 00 00          mov    $0x18,%esi</span><br><span class="line">  400533:   bf 18 07 40 00          mov    $0x400718,%edi</span><br><span class="line">  400538:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40053a:   e8 91 ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">  40053f:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400541:   48 83 c4 28             add    $0x28,%rsp</span><br></pre></td></tr></table></figure>

<p>写法二的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a:2 b:1 c:6</span><br><span class="line">size:24 &amp;a-&amp;s:0, &amp;b-&amp;s:8 &amp;c-&amp;s:16</span><br><span class="line"></span><br><span class="line">  400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400504:   b9 06 00 00 00          mov    $0x6,%ecx</span><br><span class="line">  400509:   ba 01 00 00 00          mov    $0x1,%edx</span><br><span class="line">  40050e:   be 02 00 00 00          mov    $0x2,%esi</span><br><span class="line">  400513:   bf c0 06 40 00          mov    $0x4006c0,%edi</span><br><span class="line">  400518:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40051a:   e8 b1 ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">  40051f:   41 b8 10 00 00 00       mov    $0x10,%r8d</span><br><span class="line">  400525:   b9 08 00 00 00          mov    $0x8,%ecx</span><br><span class="line">  40052a:   31 d2                   xor    %edx,%edx</span><br><span class="line">  40052c:   be 18 00 00 00          mov    $0x18,%esi</span><br><span class="line">  400531:   bf d8 06 40 00          mov    $0x4006d8,%edi</span><br><span class="line">  400536:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400538:   e8 93 ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">  40053d:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40053f:   48 83 c4 08             add    $0x8,%rsp</span><br></pre></td></tr></table></figure>

<p>对比两种写法的结果，我们发现：</p>
<ul>
<li>成员布局上，两者相同，即普通的非虚成员函数不存在于对象中，不会占用空间。</li>
<li>汇编指令上，第一种写法调用了<code>Func(S*)</code>，而第二种写法完全看不到<code>S::Func</code>，而是直接调用了<code>printf</code>。</li>
</ul>
<p>上面的第二条发现，实际上就是inline的效果。c++标准规定了定义在类（无论是class还是struct）定义中的函数都默认带有inline效果，因此它被编译器直接展开到调用处了。</p>
<p>如果我们给<code>Func(S*)</code>前面加上<code>inline</code>，我们会得到与写法二完全相同的汇编指令（不贴了）。因此结论就是：</p>
<ul>
<li>普通的非虚成员函数不会占用对象空间，也不会带来额外开销，与对应的非成员函数完全相同。</li>
<li><code>Func(S*)</code>等效于<code>S::Func()</code>。</li>
</ul>
<p>针对上面的第二点，实际上<code>S::Func()</code>会被编译器变成一个非成员函数，类似为<code>S_Func(S* const this)</code>，而<code>S::Func() const</code>则对应<code>S_Func(const S* const this)</code>。</p>
<h2 id="为struct添加虚成员函数"><a href="#为struct添加虚成员函数" class="headerlink" title="为struct添加虚成员函数"></a>为struct添加虚成员函数</h2><p>我们将<code>S::Func</code>改为一个虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        b -= <span class="number">1</span>;</span><br><span class="line">        c *= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a:%d b:%ld c:%d\n&quot;</span>, a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应的<code>main</code>函数不变，直接运行会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct.cpp: In function ‘int main()’:</span><br><span class="line">struct.cpp:18:19: error: in C++98 ‘s’ must be initialized by constructor, not by ‘&#123;...&#125;’</span><br><span class="line">     S s = &#123;1, 2, 3&#125;;</span><br><span class="line">                   ^</span><br><span class="line">struct.cpp:18:19: error: could not convert ‘&#123;1, 2, 3&#125;’ from ‘&lt;brace-enclosed initializer list&gt;’ to ‘S’</span><br></pre></td></tr></table></figure>

<p>似乎此时struct与c的struct已经不一样了。我们给它加上一个构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S::<span class="built_in">S</span>(<span class="type">int8_t</span> x, <span class="type">int64_t</span> y, <span class="type">int32_t</span> z) &#123;</span><br><span class="line">    a = x;</span><br><span class="line">    b = y;</span><br><span class="line">    c = z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以编译过了。先运行前面的<code>main</code>函数（构造那行要改），结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:32 &amp;a-&amp;s:8, &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>我们发现：</p>
<ul>
<li>加入虚函数后，对象变大了，说明虚函数占用了一部分对象空间。</li>
<li>对象变大了8字节（实际是虚表指针），且正好在对象的最前面，其它成员变量的位置依次向下8字节。</li>
</ul>
<p>这是第一个与c的struct布局不同的场景。我们知道虚函数是为了实现运行期多态的，那么就需要有信息来帮助程序在运行期根据对象的不同而选择不同的行为，这种信息就会带来运行期的额外开销。</p>
<p>但调用虚函数真的就会有运行期开销吗？我们分别看一下直接通过对象来调用虚函数，与通过指针或引用调用虚函数的区别。</p>
<p>我们添加三个Test函数，并在main函数中调用它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">(S s)</span> </span>&#123;</span><br><span class="line">    s.<span class="built_in">Func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test2</span><span class="params">(S* s)</span> </span>&#123;</span><br><span class="line">    s-&gt;<span class="built_in">Func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test3</span><span class="params">(S&amp; s)</span> </span>&#123;</span><br><span class="line">    s.<span class="built_in">Func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的汇编指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">0000000000400710 &lt;_Z5Test11S&gt;:</span><br><span class="line">  400710:   0f b6 47 08             movzbl 0x8(%rdi),%eax</span><br><span class="line">  400714:   8d 70 01                lea    0x1(%rax),%esi</span><br><span class="line">  400717:   48 8b 47 10             mov    0x10(%rdi),%rax</span><br><span class="line">  40071b:   40 88 77 08             mov    %sil,0x8(%rdi)</span><br><span class="line">  40071f:   40 0f be f6             movsbl %sil,%esi</span><br><span class="line">  400723:   48 8d 50 ff             lea    -0x1(%rax),%rdx</span><br><span class="line">  400727:   8b 47 18                mov    0x18(%rdi),%eax</span><br><span class="line">  40072a:   48 89 57 10             mov    %rdx,0x10(%rdi)</span><br><span class="line">  40072e:   8d 0c 00                lea    (%rax,%rax,1),%ecx</span><br><span class="line">  400731:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400733:   89 4f 18                mov    %ecx,0x18(%rdi)</span><br><span class="line">  400736:   bf 20 08 40 00          mov    $0x400820,%edi</span><br><span class="line">  40073b:   e9 20 fe ff ff          jmpq   400560 &lt;printf@plt&gt;</span><br><span class="line"></span><br><span class="line">0000000000400740 &lt;_Z5Test2P1S&gt;:</span><br><span class="line">  400740:   48 8b 07                mov    (%rdi),%rax</span><br><span class="line">  400743:   48 8b 00                mov    (%rax),%rax</span><br><span class="line">  400746:   ff e0                   jmpq   *%rax</span><br><span class="line">  400748:   0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)</span><br><span class="line">  40074f:   00</span><br><span class="line"></span><br><span class="line">0000000000400750 &lt;_Z5Test3R1S&gt;:</span><br><span class="line">  400750:   48 8b 07                mov    (%rdi),%rax</span><br><span class="line">  400753:   48 8b 00                mov    (%rax),%rax</span><br><span class="line">  400756:   ff e0                   jmpq   *%rax</span><br><span class="line">  400758:   0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)</span><br><span class="line">  40075f:   00</span><br></pre></td></tr></table></figure>

<p>我们发现：</p>
<ul>
<li><code>Test1</code>中<code>Func</code>被展开了，看不到直接的<code>Func</code>调用，这点与调用一个非虚函数的行为相同。</li>
<li><code>Test2</code>中通过间接跳转（jmpq）调用了<code>Func</code>，方法是先取出<code>s</code>（%rdi）的前8字节到%rax，再从%rax取出前8字节放到%rax，这就是<code>Func</code>的地址，之后就是一次间接跳转。</li>
<li><code>Test3</code>与<code>Test2</code>完全相同。</li>
</ul>
<p>结论：</p>
<ul>
<li>通过一个对象调用虚函数时，编译器没有采用运行期多态，而是直接像调用一个非虚函数一样，没有运行期开销。</li>
<li>通过指针调用虚函数时，有运行期开销，即需要一次间接跳转，此时虚函数无法展开。</li>
<li>引用与指针此处无区别，引用就是一种语法糖。</li>
</ul>
<h2 id="为struct添加一个非虚继承的基类"><a href="#为struct添加一个非虚继承的基类" class="headerlink" title="为struct添加一个非虚继承的基类"></a>为struct添加一个非虚继承的基类</h2><h3 id="为struct添加一个无虚函数的非虚继承基类"><a href="#为struct添加一个无虚函数的非虚继承基类" class="headerlink" title="为struct添加一个无虚函数的非虚继承基类"></a>为struct添加一个无虚函数的非虚继承基类</h3><p>我们修改一下<code>S</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行前面的<code>main</code>函数，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:24 &amp;a-&amp;s:4, &amp;b-&amp;s:8 &amp;c-&amp;s:16</span><br></pre></td></tr></table></figure>

<p>此时<code>S</code>的布局可以认为是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> ba;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    Base base;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>两者的区别在于，前者是基类的所有成员都可以被当作子类的成员，而后者是基类子对象就是子类的第一个成员。</p>
<p>到底是哪种呢？当基类为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> ba;</span><br><span class="line">    <span class="type">int8_t</span> bb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时，如果按前者，<code>Base::bb</code>和<code>S::a</code>之间应该没有padding，即此时<code>S</code>的大小仍然是24；如果按后者，<code>Base</code>的alignment为8，此时<code>Base::bb</code>后面会有padding，<code>S</code>的大小应该是32。我们试一下，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:32 &amp;a-&amp;s:8, &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>说明：基类子对象可以被当作子类对象的第一个成员，且保持自己的alignment和padding。</p>
<h3 id="为struct添加第二个非虚基类"><a href="#为struct添加第二个非虚基类" class="headerlink" title="为struct添加第二个非虚基类"></a>为struct添加第二个非虚基类</h3><p>我们再加一个基类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> ba;</span><br><span class="line">    <span class="type">int8_t</span> bb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> ca;</span><br><span class="line">    <span class="type">int8_t</span> cb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> Base, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据上节的结论，我们可以认为<code>Base2</code>也是<code>S</code>的一个成员，且应排列在<code>Base</code>后面，<code>S</code>的大小应该是40。实验结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:40 &amp;a-&amp;s:16, &amp;b-&amp;s:24 &amp;c-&amp;s:32</span><br></pre></td></tr></table></figure>

<p>证实了我们的猜测。</p>
<h3 id="为struct添加空的基类"><a href="#为struct添加空的基类" class="headerlink" title="为struct添加空的基类"></a>为struct添加空的基类</h3><p>所谓空类型，指：</p>
<ul>
<li>没有任何非静态成员变量。</li>
<li>没有任何虚函数。</li>
<li>没有任何虚基类。</li>
<li>其上没有基类，或只有空基类。</li>
</ul>
<p>当我们给<code>S</code>添加一个空类型的基类时，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int64_t</span> b; <span class="comment">// 注意该场景中没有成员a</span></span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据之前的结论，<code>S</code>应该相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    Base base;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们知道，c++中任何类型的size都至少是1，这是为了避免不同变量对应相同的内存地址。那么<code>base</code>的size就是1，<code>S</code>的size就应该是24。实际上呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:16 &amp;b-&amp;s:0 &amp;c-&amp;s:8</span><br></pre></td></tr></table></figure>

<p>居然是16！这就是c++的空基类优化（Empty Base Optimization，EBO），当基类子对象为空时，其不必在子类对象中占据空间，且与子类对象共享相同的地址。这里是一个c的oop无法模拟的点。</p>
<h2 id="为struct添加有虚函数的非虚继承基类"><a href="#为struct添加有虚函数的非虚继承基类" class="headerlink" title="为struct添加有虚函数的非虚继承基类"></a>为struct添加有虚函数的非虚继承基类</h2><h3 id="基类无成员变量"><a href="#基类无成员变量" class="headerlink" title="基类无成员变量"></a>基类无成员变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;Base:%d S:%d &amp;base-&amp;s:%d &amp;a-&amp;s:%d &amp;b-&amp;s:%d &amp;c-&amp;s:%d\n&quot;</span>,</span><br><span class="line">        <span class="built_in">sizeof</span>(Base),</span><br><span class="line">        <span class="built_in">sizeof</span>(S),</span><br><span class="line">        (<span class="type">char</span>*)<span class="built_in">static_cast</span>&lt;Base*&gt;(&amp;s) - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.a - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.b - (<span class="type">char</span>*)&amp;s,</span><br><span class="line">        (<span class="type">char</span>*)&amp;s.c - (<span class="type">char</span>*)&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:8 S:32 &amp;base-&amp;s:0 &amp;a-&amp;s:8 &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>有虚函数的类型，其对象中需要有1个虚表指针来存放运行期信息，不再是空类型，作为基类也没办法应用EBO。</li>
<li>子类对象中不会有2个虚表指针（基类子对象1个，子类对象1个），而是与基类共用1个虚表指针。</li>
</ul>
<h3 id="基类有成员变量"><a href="#基类有成员变量" class="headerlink" title="基类有成员变量"></a>基类有成员变量</h3><p>假设我们给基类添加一个成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="type">int8_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据前文规则，<code>Base</code>大小为16，其alignment为8，<code>S</code>的大小就会是40，且<code>Base::bb</code>与<code>S::a</code>之间有padding。但运行结果却是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:16 S:32 &amp;base-&amp;s:0 &amp;a-&amp;s:9 &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>与我们的猜测不符，<code>Base::bb</code>与<code>S::a</code>之间没有padding。</p>
<p>后面我们会说到c++有一种标准布局（Standard Layout），这种布局需要与c的struct布局兼容（外加空基类优化）。而当<code>Base</code>或<code>S</code>中加入虚函数后，它们就不再符合标准布局了，编译器就可以应用更紧凑的布局了。</p>
<p>为什么标准布局需要与c的struct布局兼容？因为POD（Plain Old Data）类型首先需要是标准布局类型，而POD类型本身就是为了与c兼容而提出的概念。</p>
<h2 id="为struct添加虚继承基类"><a href="#为struct添加虚继承基类" class="headerlink" title="为struct添加虚继承基类"></a>为struct添加虚继承基类</h2><p>注：大多数c++项目都禁止使用虚继承，因此下面的几个场景我们只给输出和大概的结论，不进行更多的探索和解释了。</p>
<h3 id="基类为空类型"><a href="#基类为空类型" class="headerlink" title="基类为空类型"></a>基类为空类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:1 S:32 &amp;base-&amp;s:0 &amp;a-&amp;s:8 &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>虚基类会在子类中占用额外空间（1个指针），位置在子类最前面，此时无法应用EBO。</li>
</ul>
<h3 id="基类为非空无虚函数类型"><a href="#基类为非空无虚函数类型" class="headerlink" title="基类为非空无虚函数类型"></a>基类为非空无虚函数类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:1 S:32 &amp;base-&amp;s:28 &amp;a-&amp;s:8 &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>子类对象最前面仍然是1个指针。</li>
<li>此时基类子对象位于子类最后。</li>
</ul>
<h3 id="基类为非空有虚函数类型"><a href="#基类为非空有虚函数类型" class="headerlink" title="基类为非空有虚函数类型"></a>基类为非空有虚函数类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="type">int8_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:16 S:48 &amp;base-&amp;s:32 &amp;a-&amp;s:8 &amp;b-&amp;s:16 &amp;c-&amp;s:24</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>此时子类对象的前8字节不再是虚表指针，而是指向虚基类子对象的指针。</li>
<li>基类子对象的前8字节是虚表指针，且其整体位于子类最后一个成员变量的后面。</li>
</ul>
<h3 id="无虚函数的菱形继承"><a href="#无虚函数的菱形继承" class="headerlink" title="无虚函数的菱形继承"></a>无虚函数的菱形继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int32_t</span> ca;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int32_t</span> da;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> C, <span class="keyword">public</span> D &#123;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:1 C:16 D:16 S:48 &amp;Base-&amp;S:44 &amp;C-&amp;S:0 &amp;D-&amp;S:16 &amp;b-&amp;s:32 &amp;c-&amp;s:40</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>此时<code>C</code>的子对象与<code>S</code>对象共享一个虚基类指针，而<code>D</code>则自己使用一个虚基类指针。</li>
<li><code>C</code>与<code>D</code>依次位于<code>S</code>的前端，而<code>Base</code>依然在最后端。</li>
<li>调用来自虚基类的虚函数时，相比非虚基类的虚函数，要多一次间接跳转：先通过虚基类指针找到虚表指针，再通过虚表指针找到对应函数地址。</li>
</ul>
<h3 id="有虚函数的菱形继承"><a href="#有虚函数的菱形继承" class="headerlink" title="有虚函数的菱形继承"></a>有虚函数的菱形继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="type">int8_t</span> ba;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int32_t</span> ca;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">    <span class="type">int32_t</span> da;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>: <span class="keyword">public</span> C, <span class="keyword">public</span> D &#123;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base:16 C:32 D:32 S:64 &amp;Base-&amp;S:48 &amp;C-&amp;S:0 &amp;D-&amp;S:16 &amp;b-&amp;s:32 &amp;c-&amp;s:40</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li><code>C</code>和<code>D</code>依然位于<code>S</code>的前端，而<code>Base</code>位于后端。</li>
<li><code>C</code>与<code>S</code>共享一个虚基类指针，<code>D</code>自己使用一个虚基类指针。</li>
<li><code>C</code>与<code>D</code>与<code>S</code>与<code>Base</code>共享一个虚表指针。</li>
</ul>
<h1 id="struct与class"><a href="#struct与class" class="headerlink" title="struct与class"></a>struct与class</h1><p>第二个问题，c++中的struct和class有什么区别？</p>
<p>答案是，除了默认访问权限不同（struct默认为public，而class默认为private）外，其它完全相同。</p>
<p>上面的例子中，我们把每个struct都换成class，仍然能得到相同的结论。决定对象模型的不是用哪个关键字修饰它，而是它本身的性质，是否有基类，是否有虚函数，是否有虚基类。</p>
<h2 id="然而struct不能用于修饰模板参数类型"><a href="#然而struct不能用于修饰模板参数类型" class="headerlink" title="然而struct不能用于修饰模板参数类型"></a>然而struct不能用于修饰模板参数类型</h2><p>但struct却不能用于下面这个场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">struct</span> <span class="title class_">X</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">sizeof</span>(X));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们编译时，报错信息为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct.cpp:19:18: error: ‘struct X’ is not a valid type for a template non-type parameter</span><br><span class="line"> template &lt;struct X&gt;</span><br><span class="line">                  ^</span><br></pre></td></tr></table></figure>

<p>而当我们把struct改成class或typename后，就可以编译成功了。</p>
<h1 id="struct的零额外开销"><a href="#struct的零额外开销" class="headerlink" title="struct的零额外开销"></a>struct的零额外开销</h1><p>众所周知，c++的一个核心理念就是保证某个功能对不使用它的用户零额外开销。我们从几方面看一下struct是如何实现零额外开销的。</p>
<h2 id="使用栈上的struct成员"><a href="#使用栈上的struct成员" class="headerlink" title="使用栈上的struct成员"></a>使用栈上的struct成员</h2><p>下面两段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">Func</span><span class="params">(<span class="type">int8_t</span> x, <span class="type">int64_t</span> y, <span class="type">int32_t</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">    a = x;</span><br><span class="line">    b = y;</span><br><span class="line">    c = z;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> a;</span><br><span class="line">    <span class="type">int64_t</span> b;</span><br><span class="line">    <span class="type">int32_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">Func</span><span class="params">(<span class="type">int8_t</span> x, <span class="type">int64_t</span> y, <span class="type">int32_t</span> z)</span> </span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    s.a = x;</span><br><span class="line">    s.b = y;</span><br><span class="line">    s.c = z;</span><br><span class="line">    <span class="keyword">return</span> s.a + s.b + s.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们对应的汇编指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000004005b0 &lt;_Z4Funcali&gt;:</span><br><span class="line">  4005b0:   48 0f be ff             movsbq %dil,%rdi</span><br><span class="line">  4005b4:   48 63 d2                movslq %edx,%rdx</span><br><span class="line">  4005b7:   48 01 fe                add    %rdi,%rsi</span><br><span class="line">  4005ba:   48 8d 04 16             lea    (%rsi,%rdx,1),%rax</span><br><span class="line">  4005be:   c3                      retq</span><br><span class="line">  4005bf:   90                      nop</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000004005b0 &lt;_Z4Funcali&gt;:</span><br><span class="line">  4005b0:   48 0f be ff             movsbq %dil,%rdi</span><br><span class="line">  4005b4:   48 63 d2                movslq %edx,%rdx</span><br><span class="line">  4005b7:   48 01 fe                add    %rdi,%rsi</span><br><span class="line">  4005ba:   48 8d 04 16             lea    (%rsi,%rdx,1),%rax</span><br><span class="line">  4005be:   c3                      retq</span><br><span class="line">  4005bf:   90                      nop</span><br></pre></td></tr></table></figure>

<p>完全相同，说明使用栈上的struct成员，与使用栈上变量完全相同，零额外开销。</p>
<h2 id="传递小struct"><a href="#传递小struct" class="headerlink" title="传递小struct"></a>传递小struct</h2><p>下面两段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">int32_t</span> x, <span class="type">int32_t</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x:%d y:%d\n&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int32_t</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> x;</span><br><span class="line">    <span class="type">int32_t</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(S s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x:%d y:%d\n&quot;</span>, s.x, s.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    s.x = <span class="number">1</span>;</span><br><span class="line">    s.y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Func</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的汇编指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000400500 &lt;main&gt;:</span><br><span class="line">  400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400504:   ba 02 00 00 00          mov    $0x2,%edx</span><br><span class="line">  400509:   be 01 00 00 00          mov    $0x1,%esi</span><br><span class="line">  40050e:   bf b0 06 40 00          mov    $0x4006b0,%edi</span><br><span class="line">  400513:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400515:   e8 b6 ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">  40051a:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40051c:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  400520:   c3                      retq</span><br><span class="line">  400521:   0f 1f 00                nopl   (%rax)</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000400500 &lt;main&gt;:</span><br><span class="line">  400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400504:   ba 02 00 00 00          mov    $0x2,%edx</span><br><span class="line">  400509:   be 01 00 00 00          mov    $0x1,%esi</span><br><span class="line">  40050e:   bf c0 06 40 00          mov    $0x4006c0,%edi</span><br><span class="line">  400513:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400515:   e8 b6 ff ff ff          callq  4004d0 &lt;printf@plt&gt;</span><br><span class="line">  40051a:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40051c:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  400520:   c3                      retq</span><br><span class="line">  400521:   0f 1f 00                nopl   (%rax)</span><br></pre></td></tr></table></figure>

<p>注意此时两个<code>Func</code>函数都被inline掉了，因此我们可以直接对应<code>main</code>的汇编代码。可以看到它们完全相同，也符合上节的结论。</p>
<p>当我们把inline关掉后，先看一下<code>main</code>（看参数是如何传递的）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000000000400500 &lt;main&gt;:</span><br><span class="line">  400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400504:   be 02 00 00 00          mov    $0x2,%esi</span><br><span class="line">  400509:   bf 01 00 00 00          mov    $0x1,%edi</span><br><span class="line">  40050e:   e8 fd 00 00 00          callq  400610 &lt;_Z4Funcii&gt;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000000000400500 &lt;main&gt;:</span><br><span class="line">  400500:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400504:   48 bf 01 00 00 00 02    movabs $0x200000001,%rdi</span><br><span class="line">  40050b:   00 00 00</span><br><span class="line">  40050e:   e8 fd 00 00 00          callq  400610 &lt;_Z4Func1S&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到直接传递一个struct反倒少了一条指令！原因是此时<code>S</code>为8个字节，刚好可以放入一个寄存器中，因此可以一条指令传递过去。而如果分成两个<code>int32_t</code>，则编译器必须用两个寄存器传递，多了一条指令。</p>
<p>再对比一下<code>Func</code>的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0000000000400610 &lt;_Z4Funcii&gt;:</span><br><span class="line">  400610:   89 f2                   mov    %esi,%edx</span><br><span class="line">  400612:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400614:   89 fe                   mov    %edi,%esi</span><br><span class="line">  400616:   bf b0 06 40 00          mov    $0x4006b0,%edi</span><br><span class="line">  40061b:   e9 b0 fe ff ff          jmpq   4004d0 &lt;printf@plt&gt;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0000000000400610 &lt;_Z4FuncS&gt;:</span><br><span class="line">  400610:   48 89 fa                mov    %rdi,%rdx</span><br><span class="line">  400613:   89 fe                   mov    %edi,%esi</span><br><span class="line">  400615:   31 c0                   xor    %eax,%eax</span><br><span class="line">  400617:   48 c1 fa 20             sar    $0x20,%rdx</span><br><span class="line">  40061b:   bf c0 06 40 00          mov    $0x4006c0,%edi</span><br><span class="line">  400620:   e9 ab fe ff ff          jmpq   4004d0 &lt;printf@plt&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到传递<code>S</code>的版本多了一条<code>sar $0x20,%rdx</code>，这是因为我们用一个寄存器传递了两个值，但在调用<code>printf</code>时还是要把它们分开，因此这里需要先把低4字节放到另一个寄存器里，再把%rdx的内容右移32位，从而得到高4字节的值。</p>
<p>把<code>main</code>和<code>Func</code>加起来，两个版本的汇编指令数量仍然完全相同，区别在于前者传递时多一次赋值，后者运算时多一次右移，可以认为开销相同。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/07/cpp-object-model-alignment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/07/cpp-object-model-alignment/" class="post-title-link" itemprop="url">C++对象模型（一）Alignment</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-07 20:31:30" itemprop="dateCreated datePublished" datetime="2018-03-07T20:31:30+08:00">2018-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="word"><a href="#word" class="headerlink" title="word"></a>word</h1><p>第一个概念，word（字）。</p>
<p>word是cpu领域的一个重要概念，它被定义为cpu使用数据的一个自然单位（natural unit），cpu的很多数据长度都与其相关，比如：</p>
<ul>
<li>通常cpu的大多数寄存器长度为一个word。</li>
<li>通常cpu最大寻址空间为一个word（即指针大小通常是一个word）。</li>
<li>总线宽度通常为一个word，即cpu单次读写内存的量通常最大为一个word。</li>
<li>很多cpu每条指令的长度也为一个word。</li>
</ul>
<p>32位&#x2F;64位cpu中的32位和64位就是指它的字长（word-length或word-size）为32位或64位。</p>
<p>这里不详细介绍不同cpu的word的具体含义。我们说一下word对内存读写的影响：</p>
<ul>
<li>早期的cpu通常只能沿着一个word的边界读写数据，如果一次读&#x2F;写操作的目标地址不是字长的整数倍，cpu会报错。</li>
<li>现代的X86 cpu可以在任意地址读写数据，但如果目标地址不是字长的整数倍，底层会将这次操作按word分界分成多个读写操作，对性能有明显影响。</li>
<li>X86-64 cpu可以在任意地址读写数据，且不会有明显的性能影响。</li>
</ul>
<p><img src="http://7xipsa.com1.z0.glb.clouddn.com/alignment.png" alt="alignment"></p>
<p>上图的第一个例子，我们按alignment存放了1个int（4字节数据），cpu只需要一次内存操作就可以完成存取。而第二个例子中，cpu需要两次内存操作来完成int的存取。</p>
<p>现代的cpu通常有多个字长概念（word、1&#x2F;2word、1&#x2F;4word等），针对不同的数据长度，可以有不同的字长。X86和X86-64对长度为1&#x2F;2&#x2F;4&#x2F;8字节的数据，其字长也为1&#x2F;2&#x2F;4&#x2F;8字节。</p>
<h1 id="alignment和padding"><a href="#alignment和padding" class="headerlink" title="alignment和padding"></a>alignment和padding</h1><p>第二个概念，alignment。</p>
<p>考虑到数据不按word边界存放可能引起的问题，编译器在排列变量时，会尽量将其按对应的字长来排列。这种行为就被称为对齐（alignment），而因为alignment导致的数据间产生未使用的空洞，则被称为填充（padding）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int16_t</span> i16;</span><br><span class="line">    <span class="type">int32_t</span> i32;</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c:%ld i16:%ld i32:%ld i64:%ld\n&quot;</span>, &amp;c, &amp;i16, &amp;i32, &amp;i64);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我的环境下（X86-64，gcc4.8.5），输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:140730763468703 i16:140730763468700 i32:140730763468696 i64:140730763468688</span><br></pre></td></tr></table></figure>

<p>可以看到<code>i16</code>与<code>c</code>之间有2字节的padding，<code>i32</code>与<code>i16</code>之间有2字节的padding，<code>i64</code>与<code>i32</code>之间有4字节的padding，实际上是这么排列的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">char</span> padding0[<span class="number">2</span>];</span><br><span class="line"><span class="type">int16_t</span> i16;</span><br><span class="line"><span class="type">char</span> padding1[<span class="number">2</span>];</span><br><span class="line"><span class="type">int32_t</span> i32;</span><br><span class="line"><span class="type">char</span> padding2[<span class="number">4</span>];</span><br><span class="line"><span class="type">int64_t</span> i64;</span><br></pre></td></tr></table></figure>

<h1 id="struct的alignment"><a href="#struct的alignment" class="headerlink" title="struct的alignment"></a>struct的alignment</h1><p>struct的alignment规则很简单：</p>
<ul>
<li>空struct的size与alignment均为1。</li>
<li>非空的struct，其alignment为各成员的alignment的最大值。其最后一个成员后面若有需要，也要padding。</li>
</ul>
<p>注意第2条规则，会导致struct占用的空间比我们预期的更多，例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c0;</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它的自然大小为10B（1+8+1），但考虑到alignment的影响，真实大小却是24B（8+8+8）！</p>
<p>因此<code>S</code>的真实布局为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c0;</span><br><span class="line">    <span class="type">char</span> padding0[<span class="number">7</span>]；</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">char</span> padding1[<span class="number">7</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而当<code>S</code>作为其它struct的成员时，它的size和alignment分别是24和8，会影响到上层struct的alignment。</p>
<p>适当的重新排列<code>S</code>的成员，可以显著减小它的size：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c0;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时它的真实布局为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c0;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">char</span> padding[<span class="number">6</span>];</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>S</code>的size减小到了16B。</p>
<h1 id="与alignment有关的编译器扩展"><a href="#与alignment有关的编译器扩展" class="headerlink" title="与alignment有关的编译器扩展"></a>与alignment有关的编译器扩展</h1><p>这里只介绍gcc的相关扩展。</p>
<p>gcc允许我们用<code>__attribute__</code>来修饰变量，其中用于改变alignment的有以下几种。</p>
<p>注意：修改alignment可能会影响ABI兼容性和可移植性，通常不推荐。</p>
<h2 id="aligned"><a href="#aligned" class="headerlink" title="aligned"></a>aligned</h2><p>语法1：<code>__attribute__ ((aligned (size_in_byte)))</code>，显式指定alignment。注意：指定比默认更小的alignment是无效的，会被编译器忽略。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x __attribute__ ((aligned (<span class="number">16</span>))) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x[<span class="number">2</span>] __attribute__ ((aligned (<span class="number">8</span>)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">R</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; __attribute__ ((aligned (<span class="number">8</span>)));</span><br></pre></td></tr></table></figure>

<p>语法2：<code>__attribute__ ((aligned))</code>，让编译器选择可能的最大alignment，对64位环境而言通常是8。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">R</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; __attribute__ ((aligned));</span><br></pre></td></tr></table></figure>

<h2 id="packed"><a href="#packed" class="headerlink" title="packed"></a>packed</h2><p>语法：<code>__attribute__ ((packed))</code>，表示该变量或struct选择可能的最小alignment，对64位环境而言通常是1。</p>
<p>下面这个struct，加上<code>packed</code>后其大小变为10，与其自然大小相等：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c0;</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p>编译时如果加上<code>-fpack-struct</code>，则默认所有变量和struct都会按<code>packed</code>处理。</p>
<p>如果加上<code>-Wpadded</code>，则编译器增加padding的地方会有warning。注意只包含struct场景。</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a target="_blank" rel="noopener" href="https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-paper.pdf">Alignment in C</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Word_(computer_architecture)">Wiki - Word</a></li>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html">Specifying Attributes of Variables</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/03/05/high-concurrency-work/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/05/high-concurrency-work/" class="post-title-link" itemprop="url">高并发工作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-05 13:56:37" itemprop="dateCreated datePublished" datetime="2018-03-05T13:56:37+08:00">2018-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大体来讲，我们每个人头上都不会只有一项工作，很可能在某阶段，头上会有N项工作。我们当然希望这些工作能按部就班的、一项一项的顺序完成。但现实是残酷的，总有些工作会depend其它人，而不得不暂停下来；也总有些工作每天都有人催，需要尽快完成。所以，结论就是每个人都需要高并发工作，也需要知道怎么实现高并发工作。</p>
<p>有种观点是，编程中的所有概念都是人类活动的延续，反映了人类自己的思维方式与组织架构。这句话反过来说也不无道理，即人类的思维方式与组织架构，往往可以从编程中找到对应的概念。</p>
<p>某种程度上，实现高并发工作的方法与实现高并发编程是类似的。本文就参照高并发编程的一些要素，来分析一下如何达到高并发工作。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/03/05/high-concurrency-work/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2018/01/30/future-promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/30/future-promise/" class="post-title-link" itemprop="url">Future与Promise</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-30 11:55:30" itemprop="dateCreated datePublished" datetime="2018-01-30T11:55:30+08:00">2018-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Future和Promise</p>
<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p>有没有某个时刻，你觉得你的程序可以分成多个部分，其中一些部分不需要等待其它部分运行结束？比如当程序发出一个http请求后，在它返回之前，程序似乎还可以做点别的事情；比如当程序在等待一个请求的response的序列化完成时，似乎它可以做下个请求的参数检查了。这时候，你就需要了解异步编程了。</p>
<p>当程序分成多部分，这些部分之间的消息通信就成了一件很重要的事情。通常我们将消息通信分成同步和异步两种，其中同步就是消息的发送方要等待消息返回才能继续处理其它事情，而异步就是消息的发送方不需要等待消息返回就可以处理其它事情。很显然异步允许我们同时做更多事情，往往也能获得更高的性能。尤其对于JavaScript这种通常是单线程环境的语言，更需要将长延时的阻塞操作异步化来保证其它操作的顺利进行。</p>
<p>异步编程的核心问题是如何处理通信：要么有办法知道通信有没有完成，要么能保证在通信完成后执行一段特定的逻辑。前者就是通知机制，比如信号量、条件变量等；后者就是callback，即回调。</p>
<h2 id="回调噩梦"><a href="#回调噩梦" class="headerlink" title="回调噩梦"></a>回调噩梦</h2><p>当一项任务需要分成多个异步阶段完成时，就需要在每个阶段的回调函数中加入下阶段回调的代码，最终产生下面这样金字塔形状的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">getData = <span class="keyword">function</span>(<span class="params">param, callback</span>)&#123;</span><br><span class="line">  $.<span class="title function_">get</span>(<span class="string">&#x27;http://example.com/get/&#x27;</span>+param,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">responseText</span>)&#123;</span><br><span class="line">      <span class="title function_">callback</span>(responseText);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getData</span>(<span class="number">0</span>, <span class="keyword">function</span>(<span class="params">a</span>)&#123;</span><br><span class="line">  <span class="title function_">getData</span>(a, <span class="keyword">function</span>(<span class="params">b</span>)&#123;</span><br><span class="line">    <span class="title function_">getData</span>(b, <span class="keyword">function</span>(<span class="params">c</span>)&#123;</span><br><span class="line">      <span class="title function_">getData</span>(c, <span class="keyword">function</span>(<span class="params">d</span>)&#123;</span><br><span class="line">        <span class="title function_">getData</span>(d, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以想象当回调层次继续增加时，代码有多恐怖。这就是回调噩梦。</p>
<h1 id="Future和Promise"><a href="#Future和Promise" class="headerlink" title="Future和Promise"></a>Future和Promise</h1><p>Future指一个<strong>只读</strong>的值的容器，这个值可能立即可用，也可能在未来某个时间可用。而Promise则是一个只能写入一次的对象。每个Promise关联一个Future，对Promise的写入会令Future的值可用。我们只讨论Promise和Future一对一的场景，在这个场景中Future就是值，而Promise是产生值的方法。</p>
<p>Future和Promise来源于函数式语言，其目的是分离一个值和产生值的方法，从而简化异步代码的处理。</p>
<h2 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h2><p>Future与Promise配合起来可以实现一种可靠的通知机制，即我们可以异步执行一个方法，通过返回的Future来知道异步方法何时结束、是否成功、返回值是什么。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SyncOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">    <span class="built_in">RunAsync</span>(std::<span class="built_in">bind</span>(AsyncFunc, promise));</span><br><span class="line">    Future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">GetFuture</span>();</span><br><span class="line">    <span class="type">int</span> result = future.<span class="built_in">Get</span>(); <span class="comment">// wait until future is done</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收方</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncFunc</span><span class="params">(Promise&lt;<span class="type">int</span>&gt; promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    promise.<span class="built_in">Done</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式回调"><a href="#链式回调" class="headerlink" title="链式回调"></a>链式回调</h2><p>Promise的一个重要特性就是它支持<code>then</code>，可以将金字塔式的回调组织为链式，极大地降低了理解和维护的难度：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getData = <span class="keyword">function</span>(<span class="params">param, callback</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    $.<span class="title function_">get</span>(<span class="string">&#x27;http://example.com/get/&#x27;</span>+param,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">responseText</span>)&#123;</span><br><span class="line">      <span class="title function_">resolve</span>(responseText);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getData</span>(<span class="number">0</span>).<span class="title function_">then</span>(getData)</span><br><span class="line">  .<span class="title function_">then</span>(getData)</span><br><span class="line">  .<span class="title function_">then</span>(getData)</span><br><span class="line">  .<span class="title function_">then</span>(getData);</span><br></pre></td></tr></table></figure>

<h2 id="Async和Await"><a href="#Async和Await" class="headerlink" title="Async和Await"></a>Async和Await</h2><p>C#在5.0之后支持了<code>async</code>和<code>await</code>关键字，允许写出这样的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">AccessTheWebAsync</span>()</span>  </span><br><span class="line">&#123;   </span><br><span class="line">    HttpClient client = <span class="keyword">new</span> HttpClient();  </span><br><span class="line">    Task&lt;<span class="built_in">string</span>&gt; getStringTask = client.GetStringAsync(<span class="string">&quot;http://msdn.microsoft.com&quot;</span>);  </span><br><span class="line">    DoIndependentWork();  </span><br><span class="line">    <span class="built_in">string</span> urlContents = <span class="keyword">await</span> getStringTask;  </span><br><span class="line">    <span class="keyword">return</span> urlContents.Length;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> urlContents = <span class="keyword">await</span> client.GetStringAsync();</span><br></pre></td></tr></table></figure>

<p>其中<code>async</code>要求函数必须返回<code>Task</code>或<code>Task&lt;T&gt;</code>，这里的<code>Task</code>可以理解为一种Future。用<code>async</code>修饰函数表明这是个可异步执行的函数，而用<code>await</code>会等待Future结束，返回Future的值，将异步又转成了同步。</p>
<p>上面js的例子用<code>await</code>来实现就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">getData = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">param, callback</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    $.<span class="title function_">get</span>(<span class="string">&#x27;http://example.com/get/&#x27;</span>+param,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">responseText</span>)&#123;</span><br><span class="line">      <span class="title function_">resolve</span>(responseText);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">await</span> <span class="title function_">getData</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> data1 = <span class="keyword">await</span> <span class="title function_">getData</span>(data);</span><br><span class="line"><span class="keyword">var</span> data2 = <span class="keyword">await</span> <span class="title function_">getData</span>(data1);</span><br><span class="line"><span class="keyword">var</span> data3 = <span class="keyword">await</span> <span class="title function_">getData</span>(data2);</span><br><span class="line"><span class="keyword">var</span> data4 = <span class="keyword">await</span> <span class="title function_">getData</span>(data3);</span><br></pre></td></tr></table></figure>

<p>这种写法要比Promise链更接近同步，也更易懂，但其底层依然是Promise。这种写法很接近于协程：用Promise来实现yield和resume，它就是一种协程。</p>
<h2 id="不同语言中的Future和Promise"><a href="#不同语言中的Future和Promise" class="headerlink" title="不同语言中的Future和Promise"></a>不同语言中的Future和Promise</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>C++11中增加了<code>std::future</code>和<code>std::promise</code>，基本是按照Future只读、Promise只写来设计的。它的缺点是：</p>
<ol>
<li>其实现绑定了<code>std::thread</code>，很难扩展到其它执行器上。</li>
<li>Promise不支持链式回调。</li>
</ol>
<h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h3><p>C#的<code>Task</code>就类似于Future，它的<code>async</code>和<code>await</code>也很方便。</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>Java之前就有<code>Future</code>，类似于C++11的<code>std::promise</code>，没有链式回调能力。Java8中增加了<code>CompletableFuture</code>，可以认为是一个完全的Promise了。</p>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>ES6开始，JavaScript增加了Promise、async、await等特性，极大改善了JS代码中维护回调难的问题。</p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Python3.5之后增加了对<code>async</code>和<code>await</code>的支持。</p>
<h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><p>Scala中的<code>Future</code>与<code>Promise</code>完全符合上面的介绍，它的一个特点是一个<code>Future</code>可以增加多个回调，但不保证这些回调的执行顺序。</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Futures_and_promises">Futures and promises</a></li>
<li><a target="_blank" rel="noopener" href="http://dist-prog-book.com/chapter/2/futures.html">Futures and Promises</a></li>
<li><a target="_blank" rel="noopener" href="http://ifeve.com/promise-future-callback/">并发编程 Promise, Future 和 Callback</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.coding.net/blog/how-do-promises-work">理解 Promise 的工作原理</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.scala-lang.org/overviews/core/futures.html">Scala: FUTURES AND PROMISES</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8">Understand promises before you start using async&#x2F;await</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Await">Await</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/index">Asynchronous programming with async and await (C#)</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2017/11/07/persistent-data-structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/07/persistent-data-structure/" class="post-title-link" itemprop="url">Persistent Data Structure</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-07 23:29:27" itemprop="dateCreated datePublished" datetime="2017-11-07T23:29:27+08:00">2017-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Persistent-Data-Structure"><a href="#Persistent-Data-Structure" class="headerlink" title="Persistent Data Structure"></a>Persistent Data Structure</h1><p>Persistent Data Structure，直译就是“持久性数据结构”。根据<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Persistent_data_structure">Wiki定义</a>，如果一种数据结构，能保留它每一次被修改前的版本，就可以被称为“持久性数据结构”。而与之相对的就是Ephemeral Data Structure，即“暂存性数据结构”。</p>
<p>C++中，我们熟悉的数据结构大多数都属于暂存性数据结构，比如<code>std::vector</code>，当我们修改了一个<code>std::vector</code>，与之相关的所有已存在的Iterator就失效了，不能再访问了。而如果我们修改了一个持久性数据结构，我们仍然能够访问到它修改之前的版本，比如Iterator（假如有的话）不会失效，不会读到修改后的数据等。从这个角度讲，持久性数据结构也是不可变（Immutable）的。</p>
<p>什么地方需要用到持久性数据结构？</p>
<ol>
<li>函数式编程语言。它的定义就要求了不能有可变数据和可变数据结构。</li>
<li>并发编程。</li>
</ol>
<p>（另外，使用Persistent Map&#x2F;HashMap有助于简化Prototype的实现，也算是一个用途。）</p>
<p>持久性数据结构对Lazy Evaluation也很有帮助：如果一个数据结构是可变的，我们肯定不会放心对它使用Lazy Evaluation。</p>
<h2 id="Persistent-Data-Structure与并发"><a href="#Persistent-Data-Structure与并发" class="headerlink" title="Persistent Data Structure与并发"></a>Persistent Data Structure与并发</h2><p>并发编程的核心问题是竞争，即不同线程同时访问相同数据。对此我们往往需要用到一些同步手段来保证临界区的原子性，即同时只有一个线程能读出或写入相同的共享数据。</p>
<p>最常见的同步手段就是锁，但锁也会引起一大堆的问题：</p>
<ul>
<li>死锁。</li>
<li>活锁。</li>
<li>临界区太大导致性能低下。</li>
<li>错误地在临界区外访问数据导致数据竞争。</li>
<li>控制反转。</li>
<li>…</li>
</ul>
<p>另一种同步手段基于原子操作，从而实现出一套lock-free的数据结构。它的问题在于：</p>
<ul>
<li>原子操作本质上也是锁（总线锁），因此高并发度时开销还是会很大。</li>
<li>需要非常精细的实现一个lock-free的数据结构，维护难度大，且很难证明其正确性。一些久经考验的数据结构仍然可能存在bug。</li>
</ul>
<p>而当我们在不同线程间访问相同的持久性数据结构时，我们很清楚其中不会有任何的数据竞争，因为无论其他线程如何修改这个结构，当前线程看到的结构永远是不变的。这不需要异常复杂的实现和同样复杂的测试来保证。</p>
<p>可以认为通过锁和原子操作实现的并发数据结构追求的是“没有明显的错误”，而持久性数据结构则是“明显没有错误”。</p>
<p>而从性能角度，持久性数据结构也并非一定处于劣势。实现良好的持久性数据结构，通常都可以提供一种或多种操作，其时间和空间复杂度与对应的暂存性数据结构相同。且编译器针对持久性数据结构的不变性，往往能给出更优化的目标代码。</p>
<h1 id="如何实现Persistent-Data-Structure"><a href="#如何实现Persistent-Data-Structure" class="headerlink" title="如何实现Persistent Data Structure"></a>如何实现Persistent Data Structure</h1><p>想要实现一种持久性数据结构，最简单的方法就是“Copy Anything”，即每当我们修改原结构时，实际上我们都创建了一个副本，再在副本上修改。</p>
<p>当然这种方法的缺点也是很明显的：开销太大。</p>
<p>第二种方法是修改时不创建数据的副本，而是保存每次对结构的修改操作，当需要读取的时候再创建数据的副本，再在其上应用每个操作。显然这种方法在读取时的开销非常大。一种改进方案是每K个修改操作创建一次数据副本。</p>
<p>第三种方法是路径复制（Path Copy），即对于基于Node的数据结构，当我们进行修改时，我们会复制路径上经过的Node，直到最终修改发生的Node。这里我们用“构造”代替了“修改”。</p>
<p>目前最常用的实现方法就是路径复制。</p>
<h2 id="垃圾回收与引用计数"><a href="#垃圾回收与引用计数" class="headerlink" title="垃圾回收与引用计数"></a>垃圾回收与引用计数</h2><p>持久性数据结构的一个核心思想是为当前每个持有的人保留一个版本，即对于相同的数据可能同时存在多个版本。这样我们就需要有垃圾回收机制，对于每个版本的数据，在没有人持有之后回收掉。</p>
<p>对于C++而言，通常引用计数就足够了。因为持久化数据结构有一个特点：它的引用链一定是无回路的，只有新对象引用老对象，不可能有老对象引用新对象，因此单纯的引用计数就可以完全回收掉所有垃圾数据。</p>
<p>同时，这个特点对Java类的分代GC也是很有好处的。</p>
<p>有位老同志指出：对于非特定的基于引用计数的数据结构，不能使用<code>std::shared_ptr</code>，原因是它的析构是链式递归进行的，C++的编译器不一定能去掉所有的尾递归，可能会打爆栈。一种解法是从Root节点开始，收集后面所有的节点，然后循环析构。</p>
<p>为什么<code>std::map</code>可以递归析构？因为平衡树的析构链长度为lgn，假设系统的栈深度上限为100，需要<code>std::map</code>中有2^100个元素以上才会栈溢出，此时内存早就爆掉了。</p>
<h1 id="Persistent-List"><a href="#Persistent-List" class="headerlink" title="Persistent List"></a>Persistent List</h1><p>Persistent List可能是最简单的持久性数据结构。它支持两种基本操作：构造、插入头节点，即：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">List</span>();</span><br><span class="line">    <span class="built_in">List</span>(T val, List tail);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里我们使用的实现方法就是路径复制：当我们插入或删除或修改List的第N个节点时，我们需要复制前N-1个节点。</p>
<p>因此，插入或删除头节点都是O(1)的开销，而任意位置插入或删除节点则是O(n)的开销。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>以下是List的一个最简单实现，包括了支持的几个O(1)操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">        <span class="built_in">Item</span>(<span class="type">const</span> T&amp; v, <span class="type">const</span> Item* tail) : <span class="built_in">mValue</span>(v), <span class="built_in">mNext</span>(tail) &#123;&#125;</span><br><span class="line">        T mValue;</span><br><span class="line">        <span class="type">const</span> Item* mNext;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">List</span><span class="params">(<span class="type">const</span> Item* item)</span>: mHead(item) &#123;</span>&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">List</span>(): <span class="built_in">mHead</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">List</span>(<span class="type">const</span> T&amp; val, List tail): <span class="built_in">mHead</span>(<span class="keyword">new</span> <span class="built_in">Item</span>(val, tail.mHead)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mHead == <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">Front</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(mHead);</span><br><span class="line">        <span class="keyword">return</span> *mHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List <span class="title">PushFront</span><span class="params">(<span class="type">const</span> T&amp; val)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">List</span>(val, mHead);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List <span class="title">PopFront</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">List</span>(mHead-&gt;mNext);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> Item* mHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到这个实现中还没有任何引用计数有关的代码。我们有两种方式来实现引用计数：</p>
<ol>
<li>使用<code>std::shared_ptr</code>，这样只需要把每个使用<code>const Item*</code>的地方都换成<code>std::shared_ptr&lt;const Item&gt;</code>即可。</li>
<li>自己实现一种侵入式的引用计数基类<code>Reference</code>，并令<code>Item</code>继承自它。</li>
</ol>
<h2 id="其它列表操作"><a href="#其它列表操作" class="headerlink" title="其它列表操作"></a>其它列表操作</h2><p>当我们拥有了一个持久性的List后，我们就可以在其上实现一套函数式的操作：</p>
<ul>
<li>fmap</li>
<li>filter</li>
<li>foldl&#x2F;foldr</li>
<li>forEach</li>
</ul>
<p>实现<a target="_blank" rel="noopener" href="https://github.com/BartoszMilewski/Okasaki/blob/master/SimpleList/ListGC.h">戳这里</a>。</p>
<h1 id="Persistent-Map"><a href="#Persistent-Map" class="headerlink" title="Persistent Map"></a>Persistent Map</h1><p>Persistent Map的实现也是基于路径复制的。算法导论上有这么一道习题，清晰的体现了它的实现思路：</p>
<p><img src="/images/2020-11/persistent-data-structure-01.png" alt="Persistent Map"></p>
<p>当我们插入或删除一个节点时，路径上的每个节点都需要被复制一次，因此这样的操作的开销是O(lgn)的。</p>
<p>插入操作是很简单的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">Insert</span><span class="params">(Node* root, <span class="type">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;mValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(root-&gt;mValue, <span class="built_in">Insert</span>(root-&gt;mLeft, val), root-&gt;mRight);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;mValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(root-&gt;mValue, root-&gt;mLeft, <span class="built_in">Insert</span>(root-&gt;mRight, val));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除操作有些麻烦，需要处理删除的节点有子节点的情况。原则就是：用构造代替所有的修改。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">Delete</span><span class="params">(Node* root, <span class="type">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;mValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(root-&gt;mValue, <span class="built_in">Delete</span>(root-&gt;mLeft, val), root-&gt;mRight);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;mValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(root-&gt;mValue, root-&gt;mLeft, <span class="built_in">Delete</span>(root-&gt;mRight, val));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;mLeft) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;mRight;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;mRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;mLeft;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node* leftMost;</span><br><span class="line">            <span class="built_in">tie</span>(leftMost, root-&gt;mRight) = <span class="built_in">RemoveLeftMost</span>(root-&gt;mRight);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(leftMost-&gt;mValue, root-&gt;mLeft, root-&gt;mRight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：以上代码均未考虑垃圾回收。</p>
<p>对于红黑树而言，每次它平衡时，同样要复制涉及到的节点。每次平衡最多涉及3个节点，因此平衡的开销是O(1)。</p>
<p>实现<a target="_blank" rel="noopener" href="https://github.com/BartoszMilewski/Okasaki/blob/master/RBTree/RBTree.h">戳这里</a>。不过这个实现没有删除功能。</p>
<h1 id="Persistent-Vector"><a href="#Persistent-Vector" class="headerlink" title="Persistent Vector"></a>Persistent Vector</h1><p>Persistent Vector的基本思想与Persistent Map非常接近：你把Persistent Vector想象成以下标为Key的Map即可：</p>
<p><img src="/images/2020-11/persistent-data-structure-02.png" alt="Basic Persistent Vector"></p>
<p>图中就是一个这样的Map，它有如下特点：</p>
<ol>
<li>分为内部节点和叶节点两类，其中数据都在叶节点上。</li>
<li>所有叶节点的高度相同。</li>
<li>每个内部节点有两个子节点。</li>
<li>每层节点中，只有最后一个节点有可能是半满的，其它节点都是满的。</li>
</ol>
<p>当然这样的实现效率是很低的，每次Update、PushBack的时间复杂度是O(lgn)。因此实践上我们会使用类似于Trie树的结构，即每个节点能容纳多于两个子节点，通常为32个，这样一个6层的Map就可以容纳最多1073741824个元素，每次Update、PushBack最多需要复制6个节点，可以认为变成了一次O(1)操作。</p>
<p>查找：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">Get</span><span class="params">(Node* root, <span class="type">int32_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!root-&gt;<span class="built_in">IsLeaf</span>()) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int32_t</span> mask = root-&gt;<span class="built_in">Mask</span>();</span><br><span class="line">        root = root-&gt;<span class="built_in">Get</span>(index / mask);</span><br><span class="line">        index %= mask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">const</span> T*)root-&gt;<span class="built_in">Get</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="保留Tail节点来提高PushBack性能"><a href="#保留Tail节点来提高PushBack性能" class="headerlink" title="保留Tail节点来提高PushBack性能"></a>保留Tail节点来提高PushBack性能</h2><p>想想一个Persistent Vector执行PushBack的时候都发生了什么？从Root开始，一直复制到Tail叶节点。原因是当我们复制了一个子节点，我们就需要修改它的父节点，根据“修改即构造”原则，就需要重新构造一个父节点，从而一直到Root都要构造一遍。</p>
<p>那么，假如Persistent Vector直接持有Tail节点呢？这样当它未满时，PushBack只要复制两个节点：Tail节点和Vector本身。当Tail节点已满时，我们才需要真正做一次PushBack。对于32个子节点的Persistent Vector来说，有31&#x2F;32的PushBack是真正的O(1)操作，其它1&#x2F;32的PushBack才需要O(lgn)。</p>
<p><img src="/images/2020-11/persistent-data-structure-03.png" alt="Tail"></p>
<p>新的查找也很简单。为了配合查找，我们要记录下Tail节点的offset：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> lookup_index &lt; tail_offset:</span><br><span class="line">  <span class="comment"># tree_lookup = old lookup technique</span></span><br><span class="line">  <span class="keyword">return</span> tree_lookup(lookup_index)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="keyword">return</span> tail[lookup_index - tail_offset]</span><br></pre></td></tr></table></figure>

<h2 id="Transient"><a href="#Transient" class="headerlink" title="Transient"></a>Transient</h2><p>当我们要对Persistent Vector进行一系列修改时，每次Update&#x2F;PushBack&#x2F;PopBack都要复制lgn节点，即使有了Tail节点优化，也只能对PushBack和PopBack有一定的效果。问题在于，我们即使每个操作都复制了一个新节点，下次操作这个节点时还是要再复制，因为我们要保证不破坏其它人的使用。那么什么时候可以直接重用这个节点，不用复制呢？</p>
<ol>
<li>只能被当前Vector访问到的节点。</li>
<li>当前Vector在这次操作后不会被其它人使用。</li>
</ol>
<p>对于条件1，很好解决：我们每次修改Vector时都申请一个UUID，并放到这次修改创建的节点中，这样通过UUID就能判断节点是不是当前Vector创建出来的。</p>
<p>对于条件2，我们没有办法阻止用户在所有修改完成之前使用这个Vector。因此我们使用一个新类型Transient来进行批量修改。好处：显式的让用户知道，我们要做一些不一样的事情啦，在它结束之前不要访问这个Vector。</p>
<p>在批量修改结束之后，还需要一个操作来把Transient变为Persistent，这步操作会把每个节点中的ID置为NULL，保证合法的Vector的节点没有ID，从而避免一个Transient被误用。</p>
<h1 id="Persistent-HashMap"><a href="#Persistent-HashMap" class="headerlink" title="Persistent HashMap"></a>Persistent HashMap</h1><p>当我们有了一个Persistent Vector的实现之后，实现一个Persistent HashMap也就不困难了。</p>
<p>一个HashMap是什么？如果我们使用分桶链表来实现HashMap，它就是一个Vector，其中每个元素是一个List。那么我们可以用Persistent Vector + Persistent List来实现Persistent HashMap。如果我们使用开放散列法来实现HashMap，它就是单纯的一个Vector，只要用Persistent Vector来实现就可以了。</p>
<h1 id="Persistent-Data-Structure的一个使用场景"><a href="#Persistent-Data-Structure的一个使用场景" class="headerlink" title="Persistent Data Structure的一个使用场景"></a>Persistent Data Structure的一个使用场景</h1><p>想象我们有一个UserMap，保存每个UserID和对应的NickName。有两种操作：</p>
<ul>
<li>NewUser：增加一对新的UserID和NickName。</li>
<li>Update：修改已有UserID对应的NickName。</li>
</ul>
<p>现在我们用一个Persistent HashMap作为UserMap。有若干个前台线程可以访问和修改UserMap。</p>
<p>最简单的做法：</p>
<ol>
<li>前台线程获得当前UserMap，称为M0。</li>
<li>前台线程修改UserMap，得到M1。</li>
<li>前台线程将M0替换为M1，原有的M0析构。</li>
</ol>
<p>只有一个前台线程时，这种用法是没什么问题的。但当我们有多个前台线程时，就会有问题：</p>
<ol>
<li>线程T1获得M0。</li>
<li>线程T2获得M0。</li>
<li>线程T1修改M0，得到M1。</li>
<li>线程T2修改M0，得到M2。</li>
<li>线程T1将M0替换为M1。</li>
<li>线程T2将M1替换为M2。</li>
</ol>
<p>结果就是丢了一次数据！实际上这就是一个很经典的RMW操作，先Read，再本地Modify，再Write写回。对于RMW操作，必不可少的操作就是CompareAndExchange，也就是在Write时比较一下原对象有没有在你的Read之后被修改过。如果有的话，需要重试整个RMW操作。</p>
<p>在我们这个场景中，我们需要做的就是每个线程在替换UserMap时确认一下UserMap的最后修改时间是否与自己手上持有的M0的修改时间相同，如果相同才能完成替换，否则就整个操作重来。这种先确认数据是否冲突再写入的操作，就是一种很典型的Transaction。因此我们可以使用STM（Software Transactional Memory）来更规范的使用UserMap：</p>
<ol>
<li>线程创建Transaction t。</li>
<li>线程通过t获得M0。</li>
<li>线程通过t修改M0，得到M1。</li>
<li>线程通过t替换UserMap为M1。</li>
</ol>
<p>这个过程中，如果有数据冲突，根据STM的实现不同，可能在不同的地方失败，只有当没有数据冲突时，整个操作才能顺利走下去。</p>
<p>可以看到，当我们使用Persistent Data Structure时，数据冲突的概率决定了它的使用是否高效。上面的例子中，对于全局唯一的UserMap，如果有大量的修改操作同时进行，那么其中只会有非常少量的操作能成功，其它操作都会因为数据冲突而失败。那么我们在使用时，就要考虑能否减少UserMap的粒度，从而降低冲突概率，提高性能。比如，我们将UserMap分成4096个桶，每个桶是一个Persistent HashMap，那么冲突概率就会小很多，整体性能就上去了。</p>
<p>当然，在分桶后，如果有涉及多个UserID的操作，我们就需要一次性原子的替换多个UserMap。这不是一件容易的事情，幸好，STM就是干这个的。这也说明Persistent Data Structure和STM确实是好朋友。</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a target="_blank" rel="noopener" href="http://hypirion.com/musings/understanding-persistent-vector-pt-1">Understanding Clojure’s Persistent Vectors, pt. 1</a></li>
<li><a target="_blank" rel="noopener" href="http://hypirion.com/musings/understanding-persistent-vector-pt-2">Understanding Clojure’s Persistent Vectors, pt. 2</a></li>
<li><a target="_blank" rel="noopener" href="http://hypirion.com/musings/understanding-persistent-vector-pt-3">Understanding Clojure’s Persistent Vectors, pt. 3</a></li>
<li><a target="_blank" rel="noopener" href="http://hypirion.com/musings/understanding-clojure-transients">Understanding Clojure’s Transients</a></li>
<li><a target="_blank" rel="noopener" href="http://hypirion.com/musings/persistent-vector-performance-summarised">Persistent Vector Performance Summarised</a></li>
<li><a target="_blank" rel="noopener" href="https://bartoszmilewski.com/2013/11/13/functional-data-structures-in-c-lists/">Functional Data Structures in C++: Lists</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice">Understanding Clojure’s PersistentHashMap</a></li>
<li><a target="_blank" rel="noopener" href="https://gotocon.com/dl/goto-amsterdam-2012/slides/KarlKrukow_IntroductionToConcurrencyandDataStructuresInClojure.pdf">Intro to Clojure data structures</a></li>
<li><a target="_blank" rel="noopener" href="https://kunigami.blog/2017/03/18/amortization-and-persistence-via-lazy-evaluation/">Amortization and Persistence via Lazy Evaluation</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/rsms/immutable-cpp">GitHub: Immutable Array via C++</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1536953/recommend-a-fast-scalable-persistent-map-java">Recommend a fast &amp; scalable persistent Map - Java</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fuzhe1989.github.io/2017/10/29/cpp-type-erasure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fu Zhe">
      <meta itemprop="description" content="High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fu Zhe's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/29/cpp-type-erasure/" class="post-title-link" itemprop="url">C++: Type Erasure</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-29 17:26:20" itemprop="dateCreated datePublished" datetime="2017-10-29T17:26:20+08:00">2017-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 08:01:50" itemprop="dateModified" datetime="2022-07-26T08:01:50+08:00">2022-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Type Erasure，直译就是“类型擦除”。什么时候需要擦除类型？当我们想令一些代码具备多态性质时，我们往往没办法保留对象本身的类型，而需要用一种通用的类型去使用它们，这个时候，就需要擦除对象原有的类型。</p>
<h1 id="Type-Erasure的几种形式"><a href="#Type-Erasure的几种形式" class="headerlink" title="Type Erasure的几种形式"></a>Type Erasure的几种形式</h1><h2 id="void"><a href="#void" class="headerlink" title="void*"></a><code>void*</code></h2><p>在C语言中，很多通用算法函数都会使用<code>void*</code>作为参数类型，比如<code>qsort</code>，它的原型是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span> <span class="params">(<span class="type">void</span>* base, <span class="type">size_t</span> num, <span class="type">size_t</span> size, <span class="type">int</span> (*compare)(<span class="type">const</span> <span class="type">void</span>*,<span class="type">const</span> <span class="type">void</span>*))</span>;</span><br></pre></td></tr></table></figure>

<p>为了使<code>qsort</code>有处理多种类型的能力，它只能把参数类型设为<code>void*</code>，这样我们可以用同一个<code>qsort</code>函数，处理各种各样的类型。代价就是对象原有的类型被擦除了，我们只能看到<code>void*</code>。</p>
<p>这种方法的缺点是，它不能保证类型安全。当我们擦除了一个对象的类型后，总会在某个时刻需要把它再找回来的。在<code>qsort</code>中，我们总是需要能拿到对象的正确类型的，才能进行正确的排序。而这个工作是通过<code>compare</code>完成的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">int_compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">const</span> <span class="type">int</span>*)a - *(<span class="type">const</span> <span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">str_compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)a, (<span class="type">const</span> <span class="type">char</span>*)b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们传递了错误的<code>compare</code>，谁能知道这件事？编译器不知道，因为你把类型擦除掉了。你自己也不知道，因为代码就是你写的。测试程序可能知道，也可能不知道，因为这个时候程序的行为是未定义的。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在面向对象语言中，继承是最常见的Type Erasure。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Increase</span><span class="params">(<span class="type">int</span> v)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Decrease</span><span class="params">(<span class="type">int</span> v)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Value</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(Counter c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldValue</span> <span class="operator">=</span> c.Value();</span><br><span class="line">        <span class="keyword">while</span> (c.Value() != <span class="number">0</span>) &#123;</span><br><span class="line">            c.Decrease(<span class="number">1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        Assert.assertEqual(count, oldValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在<code>Test.down</code>中，我们只知道<code>c</code>的类型是<code>Counter</code>，但不知道它是哪个实现类型，这里它的类型就被擦除了。</p>
<p>继承当然是比<code>void*</code>要好的，因为我们操作对象时调用的是对象具体的实现API，换句话说，我们只擦除了调用处对象的类型，实际上它并没有丢掉自己的类型，也保证了类型安全性。</p>
<p>继承的问题在于，它的侵入性，即它要求每个实现类型都继承自某个基类。在很多情况下，这是很难做到的，或者是很别扭的。</p>
<p>比如说<code>RedApple</code>，一个红色的苹果，当我们想使用“红色”这个泛型概念时，它需要实现<code>Red</code>这个接口；而当我们想使用“苹果”这个概念时，它又需要实现<code>Apple</code>这个接口。某天当我们想使用“类球形”这个概念时，它又要实现<code>RoundLike</code>接口吗？</p>
<p>当接口一个又一个的出现时，有人会说，干脆我们到处传递<code>Object</code>吧，用的时候再down_cast成具体的类型。于是我们又回到了<code>void*</code>的时代。</p>
<p>尤其是，有些类型我们是没有办法改的，比如三方库中定义的类型，比如内置类型。这些情况下，继承就无能为力了。</p>
<h2 id="Duck-Typing和Template"><a href="#Duck-Typing和Template" class="headerlink" title="Duck Typing和Template"></a>Duck Typing和Template</h2><p>如果一个东西，走路像鸭子，叫声也像鸭子，那么它就是鸭子。换句话说，如果一个东西，满足我们对鸭子的所有要求，那么它就是鸭子。如果一个<code>T</code>，满足我们对<code>X</code>的所有要求，那么它就是<code>X</code>。这就是duck typing，即鸭子类型。</p>
<p>Python中大量应用了duck typing：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RedApple</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">color</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">round_like</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">map_by_color</span>(<span class="params">items</span>):</span><br><span class="line">    ret = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        ret[item.color()].append(item)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">color_map = map_by_color([..., RedApple(), ...])</span><br></pre></td></tr></table></figure>

<p>在<code>map_by_color</code>中，我们对<code>items</code>有两项要求：</p>
<ol>
<li>可遍历。</li>
<li>其中每个元素都有<code>color</code>方法。</li>
</ol>
<p>但不要求<code>items</code>或其中每个<code>item</code>继承自哪个特定的接口。</p>
<p>这也是Type Erasure，但明显比继承来得更自由。当然自由都是有代价的，duck typing的代价就是它的运行时性能损失。Python中每个对象都会保留自己的类型信息，在调用时进行动态绑定。Go的<code>interface</code>有着类似的用法，也有着类似的优缺点。</p>
<p>C++的模板也是一种duck typing：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CountByColor</span><span class="params">(<span class="type">const</span> C&amp; container, Color color)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item: container) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.<span class="built_in">Color</span>() == color) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面有个模板参数<code>C</code>，我们对它的要求是：</p>
<ol>
<li>可遍历，具体来说是支持<code>begin(container)</code>和<code>end(container)</code>两种API。</li>
<li>遍历出来的每个元素有<code>T Color() const</code>方法，且<code>T</code>与<code>Color</code>类型有合适的<code>operator==</code>函数存在。</li>
</ol>
<p>所有满足这个条件的<code>C</code>都可以作为<code>CountByColor</code>的参数类型。</p>
<p>当然C++的模板与Python的duck typing还是有很大区别的，因为它并没有真的擦除掉元素类型：<code>C</code>是<code>CountByColor</code>原型的一部分。这样我们其实一直都保留着元素的具体类型信息，好处：</p>
<ol>
<li>完整的类型安全性，没有任何环节丢掉了类型信息。</li>
<li>因此不需要动态绑定，所有环节都是静态的，没有运行时性能损失。</li>
</ol>
<p>但也有坏处：</p>
<ol>
<li>模板类型会作为模板函数或模板类的原型的一部分，即<code>vector&lt;int&gt;</code>和<code>vector&lt;double&gt;</code>是两个类型，没办法用一个类型来表示，也就没办法实现出上面Python例子中的<code>map_by_color</code>函数。</li>
<li>每次用不同的参数类型来实例化模板时，都会新生成一份代码，导致编译出来的二进制文件很大。</li>
</ol>
<h2 id="C-中结合继承与Template的Type-Erasure"><a href="#C-中结合继承与Template的Type-Erasure" class="headerlink" title="C++中结合继承与Template的Type Erasure"></a>C++中结合继承与Template的Type Erasure</h2><p>在C++中我们可以结合继承与Template，实现出一种Type Erasure，它既有duck typing的优点，又可以将不同类型用同一种类型表示。</p>
<p>假设我们现在要重新设计上面的<code>Counter</code>接口，首先我们定义一个内部的基类，<code>Counter</code>的每个方法都对应它的一个虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CounterBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~CounterBase &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Increase</span><span class="params">(<span class="type">int</span> v)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Decrease</span><span class="params">(<span class="type">int</span> v)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Count</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们使用模板实现一个通用的子类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CounterImpl</span>: <span class="keyword">public</span> CounterBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CounterImpl</span><span class="params">(T t)</span>: mImpl(std::move(t)) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Increase</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mImpl.<span class="built_in">Increase</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Decrease</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mImpl.<span class="built_in">Decrease</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mImpl.<span class="built_in">Count</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T mImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后我们还要定义一个<code>Counter</code>类型，但它不需要有任何的虚函数，也不需要作为任何类型的基类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">Counter</span>(T t): <span class="built_in">mPtr</span>(<span class="keyword">new</span> <span class="built_in">CounterImpl</span>(std::forward&lt;T&gt;(t))) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Increase</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        mPtr-&gt;<span class="built_in">Increase</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Decrease</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        mPtr-&gt;<span class="built_in">Decrease</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mPtr-&gt;<span class="built_in">Count</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;CounterBase&gt; mPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以使用<code>Counter</code>来表示所有满足条件的类型了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Counter <span class="title">c1</span><span class="params">(ClassA&#123;&#125;)</span></span>;</span><br><span class="line"><span class="function">Counter <span class="title">c2</span><span class="params">(ClassB&#123;<span class="number">5</span>&#125;)</span></span>;</span><br><span class="line">Counter c3 = ClassC&#123;<span class="number">3</span>, <span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>对于没有<code>Increase</code>、<code>Decrease</code>、<code>Count</code>接口的类型，比如内置类型<code>int</code>，我们还可以特化模板来满足要求：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CounterImpl</span>&lt;<span class="type">int</span>&gt;: <span class="keyword">public</span> CounterBase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CounterImpl</span><span class="params">(<span class="type">int</span> v)</span>: mValue(v) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Increase</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mValue += v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Decrease</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mValue -= v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mValue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Counter c = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>是不是很赞？</p>
<h1 id="C-中Type-Erasure的例子"><a href="#C-中Type-Erasure的例子" class="headerlink" title="C++中Type Erasure的例子"></a>C++中Type Erasure的例子</h1><h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p>我们知道<code>std::shared_ptr</code>的Deleter不是<code>std::shared_ptr</code>类型的一部分（参见<a href="/2017/05/19/cpp-different-role-of-deleter-in-unique-ptr-and-shared-ptr/">为什么unique_ptr的Deleter是模板类型参数，而shared_ptr的Deleter不是</a>），这给使用者带来了很多好处（相比<code>std::unique_ptr</code>）：</p>
<ul>
<li>对于<code>std::shared_ptr&lt;T&gt;</code>，使用者不需要知道<code>T</code>的完整类型（当然创建者需要）。</li>
<li>两个<code>std::shared_ptr&lt;T&gt;</code>对象类型相同，可以相互赋值，即使它们的Deleter类型不同。</li>
<li>销毁<code>T</code>使用的Deleter永远是来自创建<code>std::shared_ptr</code>的编译单元，跨DLL和so使用时不会有销毁问题。</li>
</ul>
<p>它的秘诀就是Type Erasure。参考clang的实现，<code>std::shared_ptr</code>只有两个成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Tp* __ptr__;</span><br><span class="line">    __shared_weak_count* __cntrl__;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>__shared_weak_count</code>的定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">__shared_weak_count</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到不包含Deleter的类型。实际上构造的类型是它的子类<code>__shared_ptr_pointer</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Dp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__shared_ptr_pointer</span>: <span class="keyword">public</span> __shared_weak_count;</span><br></pre></td></tr></table></figure>

<p>具体的实现略。可以看到这里就使用了我们上面提到的继承与Template结合的方法。</p>
<h2 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h2><p><code>std::function</code>中使用了一个基类<code>__base</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> ..._ArgTypes&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__base</span>&lt;_Rp(_ArgTypes...)&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> _Rp <span class="title">operator</span><span class="params">()</span><span class="params">(_ArgTypes&amp;&amp; ...)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样地，具体的子类通过模板来保留类型信息，而通过基类来实现统一的存储与调用。</p>
<h2 id="boost-any"><a href="#boost-any" class="headerlink" title="boost::any"></a>boost::any</h2><p><code>boost::any</code>是非常典型的应用了Type Erasure方法的类型。它允许你用一种类型来保存任何类型的对象，且通过<code>type_info</code>方法返回具体的对象类型。这样我们可以使用一个<code>boost::any</code>的容器保存任意类型的对象。它的实现很短，只有313行，很值得看一下。</p>
<h2 id="std-any"><a href="#std-any" class="headerlink" title="std::any"></a>std::any</h2><p><code>std::any</code>是C++17引入的新类型，与<code>boost::any</code>的接口几乎完全相同，区别在于，它使用了SBO(Small Buffer Optimization)方法，可以把小对象直接构造在类型内部，性能更好。</p>
<h2 id="基于Type-Erasure实现Unified-Call-Syntax"><a href="#基于Type-Erasure实现Unified-Call-Syntax" class="headerlink" title="基于Type Erasure实现Unified Call Syntax"></a>基于Type Erasure实现Unified Call Syntax</h2><p>假设我们想实现一个接口类型<code>Fooable</code>，它有一个方法<code>foo</code>，使得<code>Fooable::foo</code>和<code>foo(Fooable)</code>都可以用来表示<code>T::foo</code>和<code>foo(T)</code>两种调用方式，即：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NonMember</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> NonMember&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">Fooable member_erased &#123;Member&#123;&#125;&#125;;</span><br><span class="line"><span class="built_in">foo</span>(member_erased);</span><br><span class="line">member_erased.<span class="built_in">foo</span>();</span><br><span class="line"></span><br><span class="line">Fooable non_member_erased &#123;non_member&#123;&#125;&#125;;</span><br><span class="line"><span class="built_in">foo</span>(non_member_erased);</span><br><span class="line">non_member_erased.<span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure>

<p>第一步我们先定义基类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二步定义模板子类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">bool</span> HasMemberFoo = has_member_foo&lt;T&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> StorageImpl: Storage &#123;</span><br><span class="line">   T <span class="type">m_t</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">StorageImpl</span> (T t): <span class="type">m_t</span> &#123;std::<span class="built_in">move</span>(t)&#125; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="type">m_t</span>.<span class="built_in">foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>has_member_foo</code>是用来判断<code>T::foo</code>是否存在的辅助类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> has_member_foo: std::false_type&#123;&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_member_foo</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">foo</span>())&gt;&gt; : std::true_type&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>当<code>T::foo()</code>是个合法的表达式时，<code>has_member_foo&lt;T&gt;::value</code>就是<code>true</code>，否则就是<code>false</code>。</p>
<p>然后我们为<code>false</code>准备一个特化版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StorageImpl</span>&lt;T, <span class="literal">false</span>&gt; : Storage &#123;</span><br><span class="line">    T <span class="type">m_t</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">StorageImpl</span> (T t) : <span class="type">m_t</span> &#123;std::<span class="built_in">move</span>(t)&#125; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">foo</span>(<span class="type">m_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后实现<code>Fooable</code>类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fooable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">Fooable</span> (T t) </span><br><span class="line">        : m_storage &#123;std::make_unique&lt;StorageImpl&lt;T&gt;&gt;(std::<span class="built_in">move</span>(t))&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; m_storage-&gt;<span class="built_in">call</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Storage&gt; m_storage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(Fooable&amp; f)</span> </span>&#123; f-&gt;<span class="built_in">foo</span>(); &#125;</span><br></pre></td></tr></table></figure>

<h1 id="什么时候使用Type-Erasure"><a href="#什么时候使用Type-Erasure" class="headerlink" title="什么时候使用Type Erasure"></a>什么时候使用Type Erasure</h1><p>简单来说，如果你有下面两个需求，你可能是需要Type Erasure的：</p>
<ul>
<li>你需要用同一种方式处理不同的类型。</li>
<li>你需要用同一种类型或容器保存不同类型的对象。</li>
</ul>
<p>然而在很多情况下，你可能只需要用<code>std::shared_ptr</code>或<code>std::function</code>就能达到这个目的，这个时候就不需要自己实现Type Erasure了。</p>
<h1 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h1><ul>
<li><a target="_blank" rel="noopener" href="http://www.cplusplus.com/articles/oz18T05o/">C++ type erasure</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Erasure">More C++ Idioms&#x2F;Type Erasure</a></li>
<li><a target="_blank" rel="noopener" href="http://davekilian.com/cpp-type-erasure.html">C++ ‘Type Erasure’ Explained</a></li>
<li><a target="_blank" rel="noopener" href="http://aherrmann.github.io/programming/2014/10/19/type-erasure-with-merged-concepts/">Type Erasure with Merged Concepts</a></li>
<li><a target="_blank" rel="noopener" href="http://nullprogram.com/blog/2014/04/01/">Duck Typing vs. Type Erasure</a></li>
<li><a target="_blank" rel="noopener" href="https://akrzemi1.wordpress.com/2013/11/18/type-erasure-part-i/">Type erasure — Part I</a></li>
<li><a target="_blank" rel="noopener" href="https://akrzemi1.wordpress.com/2013/12/06/type-erasure-part-ii/">Type erasure — Part II</a></li>
<li><a target="_blank" rel="noopener" href="https://akrzemi1.wordpress.com/2013/12/11/type-erasure-part-iii/">Type erasure — Part III</a></li>
<li><a target="_blank" rel="noopener" href="https://akrzemi1.wordpress.com/2014/01/13/type-erasure-part-iv/">Type erasure — Part IV</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5450159/type-erasure-techniques">Type erasure techniques</a></li>
<li><a target="_blank" rel="noopener" href="https://a4z.bitbucket.io/blog/2017/01/11/exterm_typererasure-using-std::function.html">Extreme type erasure via std::function</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>


        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fu Zhe"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Fu Zhe</p>
  <div class="site-description" itemprop="description">High-Flyer AI<br/>PingCAP<br/>Google<br/>Alibaba Cloud<br/>Harbin Institute of Technology</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">122</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">81</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fu Zhe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v6.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
